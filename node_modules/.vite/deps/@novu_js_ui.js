var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/@novu/js/dist/esm/chunk-STZMOEWR.mjs
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value2) => {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value2) => {
      try {
        step(generator.throw(value2));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/mitt/dist/mitt.mjs
function mitt_default(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i2 = n.get(t);
    i2 ? i2.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i2 = n.get(t);
    i2 && (e ? i2.splice(i2.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i2 = n.get(t);
    i2 && i2.slice().map(function(n2) {
      n2(e);
    }), (i2 = n.get("*")) && i2.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}

// node_modules/engine.io-parser/build/esm/commons.js
var PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = { type: "error", data: "parser error" };

// node_modules/engine.io-parser/build/esm/encodePacket.browser.js
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = ({ type, data: data2 }, supportsBinary, callback) => {
  if (withNativeBlob && data2 instanceof Blob) {
    if (supportsBinary) {
      return callback(data2);
    } else {
      return encodeBlobAsBase64(data2, callback);
    }
  } else if (withNativeArrayBuffer && (data2 instanceof ArrayBuffer || isView(data2))) {
    if (supportsBinary) {
      return callback(data2);
    } else {
      return encodeBlobAsBase64(new Blob([data2]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data2 || ""));
};
var encodeBlobAsBase64 = (data2, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data2);
};
function toArray(data2) {
  if (data2 instanceof Uint8Array) {
    return data2;
  } else if (data2 instanceof ArrayBuffer) {
    return new Uint8Array(data2);
  } else {
    return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
  }
}
var TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer && (packet.data instanceof ArrayBuffer || isView(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}

// node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i2 = 0; i2 < chars.length; i2++) {
  lookup[chars.charCodeAt(i2)] = i2;
}
var decode = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup[base64.charCodeAt(i2)];
    encoded2 = lookup[base64.charCodeAt(i2 + 1)];
    encoded3 = lookup[base64.charCodeAt(i2 + 2)];
    encoded4 = lookup[base64.charCodeAt(i2 + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};

// node_modules/engine.io-parser/build/esm/decodePacket.browser.js
var withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
var decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
var decodeBase64Packet = (data2, binaryType) => {
  if (withNativeArrayBuffer2) {
    const decoded = decode(data2);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data: data2 };
  }
};
var mapBinary = (data2, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data2 instanceof Blob) {
        return data2;
      } else {
        return new Blob([data2]);
      }
    case "arraybuffer":
    default:
      if (data2 instanceof ArrayBuffer) {
        return data2;
      } else {
        return data2.buffer;
      }
  }
};

// node_modules/engine.io-parser/build/esm/index.js
var SEPARATOR = String.fromCharCode(30);
var encodePayload = (packets, callback) => {
  const length2 = packets.length;
  const encodedPackets = new Array(length2);
  let count = 0;
  packets.forEach((packet, i2) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i2] = encodedPacket;
      if (++count === length2) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
var decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i2 = 0; i2 < encodedPackets.length; i2++) {
    const decodedPacket = decodePacket(encodedPackets[i2], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
var TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size2) {
  if (chunks[0].length === size2) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size2);
  let j = 0;
  for (let i2 = 0; i2 < size2; i2++) {
    buffer[i2] = chunks[0][j++];
    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }
  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n = view.getUint32(0);
          if (n > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data2 = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data2 : TEXT_DECODER.decode(data2), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
var protocol = 4;

// node_modules/@socket.io/component-emitter/lib/esm/index.js
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks) return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    cb = callbacks[i2];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i2, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i2 = 1; i2 < arguments.length; i2++) {
    args[i2 - 1] = arguments[i2];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
      callbacks[i2].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};

// node_modules/engine.io-client/build/esm/globalThis.browser.js
var globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();

// node_modules/engine.io-client/build/esm/util.js
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
var BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c = 0, length2 = 0;
  for (let i2 = 0, l = str.length; i2 < l; i2++) {
    c = str.charCodeAt(i2);
    if (c < 128) {
      length2 += 1;
    } else if (c < 2048) {
      length2 += 2;
    } else if (c < 55296 || c >= 57344) {
      length2 += 3;
    } else {
      i2++;
      length2 += 4;
    }
  }
  return length2;
}

// node_modules/engine.io-client/build/esm/contrib/parseqs.js
function encode(obj) {
  let str = "";
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str;
}
function decode2(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i2 = 0, l = pairs.length; i2 < l; i2++) {
    let pair = pairs[i2].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}

// node_modules/engine.io-client/build/esm/transport.js
var TransportError = class extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
};
var Transport = class extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    } else {
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data2) {
    const packet = decodePacket(data2, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
};

// node_modules/engine.io-client/build/esm/contrib/yeast.js
var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
var length = 64;
var map = {};
var seed = 0;
var i = 0;
var prev;
function encode2(num) {
  let encoded = "";
  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
function yeast() {
  const now = encode2(+/* @__PURE__ */ new Date());
  if (now !== prev)
    return seed = 0, prev = now;
  return now + "." + encode2(seed++);
}
for (; i < length; i++)
  map[alphabet[i]] = i;

// node_modules/engine.io-client/build/esm/contrib/has-cors.js
var value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
var hasCORS = value;

// node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js
function XHR(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
function createCookieJar() {
}

// node_modules/engine.io-client/build/esm/transports/polling.js
function empty() {
}
var hasXHR2 = function() {
  const xhr = new XHR({
    xdomain: false
  });
  return null != xhr.responseType;
}();
var Polling = class extends Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    this.polling = false;
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
    if (this.opts.withCredentials) {
      this.cookieJar = createCookieJar();
    }
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    this.polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data2) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data2, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this.polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this.poll();
      } else {
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data2) => {
      this.doWrite(data2, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);
    return new Request(this.uri(), opts);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data2, fn) {
    const req = this.request({
      method: "POST",
      data: data2
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
};
var Request = class _Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(uri, opts) {
    super();
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.data = void 0 !== opts.data ? opts.data : null;
    this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    var _a;
    const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this.opts.xd;
    const xhr = this.xhr = new XHR(opts);
    try {
      xhr.open(this.method, this.uri, true);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i2 in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i2)) {
              xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this.method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a2;
        if (xhr.readyState === 3) {
          (_a2 = this.opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(xhr);
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this.onLoad();
        } else {
          this.setTimeoutFn(() => {
            this.onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this.data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this.onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = _Request.requestsCount++;
      _Request.requests[this.index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(err) {
    this.emitReserved("error", err, this.xhr);
    this.cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    this.xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete _Request.requests[this.index];
    }
    this.xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const data2 = this.xhr.responseText;
    if (data2 !== null) {
      this.emitReserved("data", data2);
      this.emitReserved("success");
      this.cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
};
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i2 in Request.requests) {
    if (Request.requests.hasOwnProperty(i2)) {
      Request.requests[i2].abort();
    }
  }
}

// node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js
var nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
var WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
var usingBrowserWebSocket = true;
var defaultBinaryType = "arraybuffer";

// node_modules/engine.io-client/build/esm/transports/websocket.js
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
var WS = class extends Transport {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data2) => {
        const opts = {};
        if (!usingBrowserWebSocket) {
          if (packet.options) {
            opts.compress = packet.options.compress;
          }
          if (this.opts.perMessageDeflate) {
            const len = (
              // @ts-ignore
              "string" === typeof data2 ? Buffer.byteLength(data2) : data2.length
            );
            if (len < this.opts.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }
        try {
          if (usingBrowserWebSocket) {
            this.ws.send(data2);
          } else {
            this.ws.send(data2, opts);
          }
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!WebSocket;
  }
};

// node_modules/engine.io-client/build/esm/transports/webtransport.js
var WT = class extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    if (typeof WebTransport !== "function") {
      return;
    }
    this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    this.transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this.writer = encoderStream.writable.getWriter();
        const read2 = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read2();
          }).catch((err) => {
          });
        };
        read2();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this.writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      this.writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a;
    (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();
  }
};

// node_modules/engine.io-client/build/esm/transports/index.js
var transports = {
  websocket: WS,
  webtransport: WT,
  polling: Polling
};

// node_modules/engine.io-client/build/esm/contrib/parseuri.js
var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(str) {
  if (str.length > 2e3) {
    throw "URI too long";
  }
  const src = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m[i2] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data2 = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data2[$1] = $2;
    }
  });
  return data2;
}

// node_modules/engine.io-client/build/esm/socket.js
var Socket = class _Socket extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts = {}) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parse(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parse(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = opts.transports || [
      "polling",
      "websocket",
      "webtransport"
    ];
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode2(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        this.beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this.beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close", {
            description: "network connection lost"
          });
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new transports[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let transport;
    if (this.opts.rememberUpgrade && _Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport = "websocket";
    } else if (0 === this.transports.length) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport = this.createTransport(transport);
    } catch (e) {
      this.transports.shift();
      this.open();
      return;
    }
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    _Socket.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          _Socket.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this.upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    _Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
    if ("open" === this.readyState && this.opts.upgrade) {
      let i2 = 0;
      const l = this.upgrades.length;
      for (; i2 < l; i2++) {
        this.probe(this.upgrades[i2]);
      }
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      this.resetPingTimeout();
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this.onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    } else {
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data2) {
    this.emitReserved("handshake", data2);
    this.id = data2.sid;
    this.transport.query.sid = data2.sid;
    this.upgrades = this.filterUpgrades(data2.upgrades);
    this.pingInterval = data2.pingInterval;
    this.pingTimeout = data2.pingTimeout;
    this.maxPayload = data2.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer);
    this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this.getWritablePackets();
      this.transport.send(packets);
      this.prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
      const data2 = this.writeBuffer[i2].data;
      if (data2) {
        payloadSize += byteLength(data2);
      }
      if (i2 > 0 && payloadSize > this.maxPayload) {
        return this.writeBuffer.slice(0, i2);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  send(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(type, data2, options, fn) {
    if ("function" === typeof data2) {
      fn = data2;
      data2 = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data: data2,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this.onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(err) {
    _Socket.priorWebsocketSuccess = false;
    this.emitReserved("error", err);
    this.onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("beforeunload", this.beforeunloadEventListener, false);
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i2 = 0;
    const j = upgrades.length;
    for (; i2 < j; i2++) {
      if (~this.transports.indexOf(upgrades[i2]))
        filteredUpgrades.push(upgrades[i2]);
    }
    return filteredUpgrades;
  }
};
Socket.protocol = protocol;

// node_modules/engine.io-client/build/esm/index.js
var protocol2 = Socket.protocol;

// node_modules/socket.io-client/build/esm/url.js
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

// node_modules/socket.io-parser/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Decoder: () => Decoder,
  Encoder: () => Encoder,
  PacketType: () => PacketType,
  protocol: () => protocol3
});

// node_modules/socket.io-parser/build/esm/is-binary.js
var withNativeArrayBuffer3 = typeof ArrayBuffer === "function";
var isView2 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString = Object.prototype.toString;
var withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer3 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l = obj.length; i2 < l; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}

// node_modules/socket.io-parser/build/esm/binary.js
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data2, buffers) {
  if (!data2)
    return data2;
  if (isBinary(data2)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data2);
    return placeholder;
  } else if (Array.isArray(data2)) {
    const newData = new Array(data2.length);
    for (let i2 = 0; i2 < data2.length; i2++) {
      newData[i2] = _deconstructPacket(data2[i2], buffers);
    }
    return newData;
  } else if (typeof data2 === "object" && !(data2 instanceof Date)) {
    const newData = {};
    for (const key in data2) {
      if (Object.prototype.hasOwnProperty.call(data2, key)) {
        newData[key] = _deconstructPacket(data2[key], buffers);
      }
    }
    return newData;
  }
  return data2;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data2, buffers) {
  if (!data2)
    return data2;
  if (data2 && data2._placeholder === true) {
    const isIndexValid = typeof data2.num === "number" && data2.num >= 0 && data2.num < buffers.length;
    if (isIndexValid) {
      return buffers[data2.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data2)) {
    for (let i2 = 0; i2 < data2.length; i2++) {
      data2[i2] = _reconstructPacket(data2[i2], buffers);
    }
  } else if (typeof data2 === "object") {
    for (const key in data2) {
      if (Object.prototype.hasOwnProperty.call(data2, key)) {
        data2[key] = _reconstructPacket(data2[key], buffers);
      }
    }
  }
  return data2;
}

// node_modules/socket.io-parser/build/esm/index.js
var RESERVED_EVENTS = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
var protocol3 = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
var Encoder = class {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
};
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
var Decoder = class _Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i2 = 0;
    const p = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p.type] === void 0) {
      throw new Error("unknown packet type " + p.type);
    }
    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
      const start = i2 + 1;
      while (str.charAt(++i2) !== "-" && i2 != str.length) {
      }
      const buf = str.substring(start, i2);
      if (buf != Number(buf) || str.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p.attachments = Number(buf);
    }
    if ("/" === str.charAt(i2 + 1)) {
      const start = i2 + 1;
      while (++i2) {
        const c = str.charAt(i2);
        if ("," === c)
          break;
        if (i2 === str.length)
          break;
      }
      p.nsp = str.substring(start, i2);
    } else {
      p.nsp = "/";
    }
    const next = str.charAt(i2 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i2 + 1;
      while (++i2) {
        const c = str.charAt(i2);
        if (null == c || Number(c) != c) {
          --i2;
          break;
        }
        if (i2 === str.length)
          break;
      }
      p.id = Number(str.substring(start, i2 + 1));
    }
    if (str.charAt(++i2)) {
      const payload = this.tryParse(str.substr(i2));
      if (_Decoder.isPayloadValid(p.type, payload)) {
        p.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
};
var BinaryReconstructor = class {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
};

// node_modules/socket.io-client/build/esm/on.js
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}

// node_modules/socket.io-client/build/esm/socket.js
var RESERVED_EVENTS2 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
var Socket2 = class extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    if (RESERVED_EVENTS2.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket) {
    } else if (this.connected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    var _a;
    const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
        if (this.sendBuffer[i2].id === id) {
          this.sendBuffer.splice(i2, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    this.acks[id] = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, [null, ...args]);
    };
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    const withErr = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((resolve, reject) => {
      args.push((arg1, arg2) => {
        if (withErr) {
          return arg1 ? reject(arg1) : resolve(arg2);
        } else {
          return resolve(arg1);
        }
      });
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data2) => {
        this._sendConnectPacket(data2);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data2) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data2) : data2
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if ("function" === typeof ack) {
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    } else {
    }
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
};

// node_modules/socket.io-client/build/esm/contrib/backo2.js
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min2) {
  this.ms = min2;
};
Backoff.prototype.setMax = function(max2) {
  this.max = max2;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};

// node_modules/socket.io-client/build/esm/manager.js
var Manager = class extends Emitter {
  constructor(uri, opts) {
    var _a;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || esm_exports;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data2) {
    try {
      this.decoder.add(data2);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      this.engine.write(encodedPackets[i2], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
    if (this.engine)
      this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(reason, description) {
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
};

// node_modules/socket.io-client/build/esm/index.js
var cache = {};
function lookup2(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup2, {
  Manager,
  Socket: Socket2,
  io: lookup2,
  connect: lookup2
});

// node_modules/@novu/js/dist/esm/chunk-JKFCSXQM.mjs
var NotificationStatus = ((NotificationStatus22) => {
  NotificationStatus22["READ"] = "read";
  NotificationStatus22["SEEN"] = "seen";
  NotificationStatus22["SNOOZED"] = "snoozed";
  NotificationStatus22["UNREAD"] = "unread";
  NotificationStatus22["UNSEEN"] = "unseen";
  NotificationStatus22["UNSNOOZED"] = "unsnoozed";
  return NotificationStatus22;
})(NotificationStatus || {});
var PreferenceLevel = ((PreferenceLevel2) => {
  PreferenceLevel2["GLOBAL"] = "global";
  PreferenceLevel2["TEMPLATE"] = "template";
  return PreferenceLevel2;
})(PreferenceLevel || {});
var ChannelType = ((ChannelType2) => {
  ChannelType2["IN_APP"] = "in_app";
  ChannelType2["EMAIL"] = "email";
  ChannelType2["SMS"] = "sms";
  ChannelType2["CHAT"] = "chat";
  ChannelType2["PUSH"] = "push";
  return ChannelType2;
})(ChannelType || {});
var WebSocketEvent = ((WebSocketEvent2) => {
  WebSocketEvent2["RECEIVED"] = "notification_received";
  WebSocketEvent2["UNREAD"] = "unread_count_changed";
  WebSocketEvent2["UNSEEN"] = "unseen_count_changed";
  return WebSocketEvent2;
})(WebSocketEvent || {});
var arrayValuesEqual = (arr1, arr2) => {
  if (arr1 === arr2) {
    return true;
  }
  if (!arr1 || !arr2) {
    return false;
  }
  if (arr1.length !== arr2.length) {
    return false;
  }
  return arr1.every((value2, index) => value2 === arr2[index]);
};
var areTagsEqual = (tags1, tags2) => {
  return arrayValuesEqual(tags1, tags2) || !tags1 && (tags2 == null ? void 0 : tags2.length) === 0 || (tags1 == null ? void 0 : tags1.length) === 0 && !tags2;
};
var isSameFilter = (filter1, filter2) => {
  return areTagsEqual(filter1.tags, filter2.tags) && filter1.read === filter2.read && filter1.archived === filter2.archived && filter1.snoozed === filter2.snoozed;
};
var DEFAULT_API_VERSION = "v1";
var DEFAULT_BACKEND_URL = "https://api.novu.co";
var DEFAULT_USER_AGENT = `${"@novu/js"}@${"3.3.1"}`;
var HttpClient = class {
  constructor(options = {}) {
    const {
      apiVersion = DEFAULT_API_VERSION,
      apiUrl = DEFAULT_BACKEND_URL,
      userAgent = DEFAULT_USER_AGENT
    } = options || {};
    this.apiVersion = apiVersion;
    this.apiUrl = `${apiUrl}/${this.apiVersion}`;
    this.headers = {
      "Novu-API-Version": "2024-06-26",
      "Content-Type": "application/json",
      "User-Agent": userAgent
    };
  }
  setAuthorizationToken(token) {
    this.headers.Authorization = `Bearer ${token}`;
  }
  setHeaders(headers) {
    this.headers = __spreadValues(__spreadValues({}, this.headers), headers);
  }
  get(path, searchParams, unwrapEnvelope = true) {
    return __async(this, null, function* () {
      return this.doFetch({
        path,
        searchParams,
        options: {
          method: "GET"
        },
        unwrapEnvelope
      });
    });
  }
  post(path, body) {
    return __async(this, null, function* () {
      return this.doFetch({
        path,
        options: {
          method: "POST",
          body
        }
      });
    });
  }
  patch(path, body) {
    return __async(this, null, function* () {
      return this.doFetch({
        path,
        options: {
          method: "PATCH",
          body
        }
      });
    });
  }
  delete(path, body) {
    return __async(this, null, function* () {
      return this.doFetch({
        path,
        options: {
          method: "DELETE",
          body
        }
      });
    });
  }
  doFetch(_0) {
    return __async(this, arguments, function* ({
      path,
      searchParams,
      options,
      unwrapEnvelope = true
    }) {
      const fullUrl = combineUrl(this.apiUrl, path, searchParams ? `?${searchParams.toString()}` : "");
      const reqInit = {
        method: (options == null ? void 0 : options.method) || "GET",
        headers: __spreadValues(__spreadValues({}, this.headers), (options == null ? void 0 : options.headers) || {}),
        body: (options == null ? void 0 : options.body) ? JSON.stringify(options.body) : void 0
      };
      const response = yield fetch(fullUrl, reqInit);
      if (!response.ok) {
        const errorData = yield response.json();
        throw new Error(`${this.headers["User-Agent"]} error. Status: ${response.status}, Message: ${errorData.message}`);
      }
      if (response.status === 204) {
        return void 0;
      }
      const res = yield response.json();
      return unwrapEnvelope ? res.data : res;
    });
  }
};
function combineUrl(...args) {
  return args.reduce((acc, part) => {
    if (part) {
      acc.push(part.replace(new RegExp("(?<!https?:)\\/+", "g"), "/").replace(/^\/+|\/+$/g, ""));
    }
    return acc;
  }, []).join("/").replace(/\/\?/, "?");
}
var INBOX_ROUTE = "/inbox";
var INBOX_NOTIFICATIONS_ROUTE = `${INBOX_ROUTE}/notifications`;
var _httpClient;
var InboxService = class {
  constructor(options = {}) {
    this.isSessionInitialized = false;
    __privateAdd(this, _httpClient);
    __privateSet(this, _httpClient, new HttpClient(options));
  }
  initializeSession(_0) {
    return __async(this, arguments, function* ({
      applicationIdentifier,
      subscriberHash,
      subscriber
    }) {
      const response = yield __privateGet(this, _httpClient).post(`${INBOX_ROUTE}/session`, {
        applicationIdentifier,
        subscriberHash,
        subscriber
      });
      __privateGet(this, _httpClient).setAuthorizationToken(response.token);
      this.isSessionInitialized = true;
      return response;
    });
  }
  fetchNotifications({
    after,
    archived,
    limit = 10,
    offset: offset3,
    read: read2,
    tags,
    snoozed
  }) {
    const searchParams = new URLSearchParams(`limit=${limit}`);
    if (after) {
      searchParams.append("after", after);
    }
    if (offset3) {
      searchParams.append("offset", `${offset3}`);
    }
    if (tags) {
      tags.forEach((tag) => searchParams.append("tags[]", tag));
    }
    if (read2 !== void 0) {
      searchParams.append("read", `${read2}`);
    }
    if (archived !== void 0) {
      searchParams.append("archived", `${archived}`);
    }
    if (snoozed !== void 0) {
      searchParams.append("snoozed", `${snoozed}`);
    }
    return __privateGet(this, _httpClient).get(INBOX_NOTIFICATIONS_ROUTE, searchParams, false);
  }
  count({ filters }) {
    return __privateGet(this, _httpClient).get(
      `${INBOX_NOTIFICATIONS_ROUTE}/count`,
      new URLSearchParams({
        filters: JSON.stringify(filters)
      }),
      false
    );
  }
  read(notificationId) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/read`);
  }
  unread(notificationId) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/unread`);
  }
  archive(notificationId) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/archive`);
  }
  unarchive(notificationId) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/unarchive`);
  }
  snooze(notificationId, snoozeUntil) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/snooze`, { snoozeUntil });
  }
  unsnooze(notificationId) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/unsnooze`);
  }
  readAll({ tags }) {
    return __privateGet(this, _httpClient).post(`${INBOX_NOTIFICATIONS_ROUTE}/read`, { tags });
  }
  archiveAll({ tags }) {
    return __privateGet(this, _httpClient).post(`${INBOX_NOTIFICATIONS_ROUTE}/archive`, { tags });
  }
  archiveAllRead({ tags }) {
    return __privateGet(this, _httpClient).post(`${INBOX_NOTIFICATIONS_ROUTE}/read-archive`, { tags });
  }
  completeAction({
    actionType,
    notificationId
  }) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/complete`, {
      actionType
    });
  }
  revertAction({
    actionType,
    notificationId
  }) {
    return __privateGet(this, _httpClient).patch(`${INBOX_NOTIFICATIONS_ROUTE}/${notificationId}/revert`, {
      actionType
    });
  }
  fetchPreferences(tags) {
    const queryParams = new URLSearchParams();
    if (tags) {
      tags.forEach((tag) => queryParams.append("tags[]", tag));
    }
    const query = queryParams.size ? `?${queryParams.toString()}` : "";
    return __privateGet(this, _httpClient).get(`${INBOX_ROUTE}/preferences${query}`);
  }
  updateGlobalPreferences(channels) {
    return __privateGet(this, _httpClient).patch(`${INBOX_ROUTE}/preferences`, channels);
  }
  updateWorkflowPreferences({
    workflowId,
    channels
  }) {
    return __privateGet(this, _httpClient).patch(`${INBOX_ROUTE}/preferences/${workflowId}`, channels);
  }
};
_httpClient = /* @__PURE__ */ new WeakMap();
var _mittEmitter;
var NovuEventEmitter = class {
  constructor() {
    __privateAdd(this, _mittEmitter);
    __privateSet(this, _mittEmitter, mitt_default());
  }
  on(eventName, listener) {
    __privateGet(this, _mittEmitter).on(eventName, listener);
    return () => {
      this.off(eventName, listener);
    };
  }
  off(eventName, listener) {
    __privateGet(this, _mittEmitter).off(eventName, listener);
  }
  emit(type, event) {
    __privateGet(this, _mittEmitter).emit(type, event);
  }
};
_mittEmitter = /* @__PURE__ */ new WeakMap();
var NovuError = class extends Error {
  constructor(message, originalError) {
    super(message);
    this.originalError = originalError;
  }
};
var _callsQueue;
var _sessionError;
var BaseModule = class {
  constructor({
    inboxServiceInstance,
    eventEmitterInstance
  }) {
    __privateAdd(this, _callsQueue, []);
    __privateAdd(this, _sessionError);
    this._emitter = eventEmitterInstance;
    this._inboxService = inboxServiceInstance;
    this._emitter.on("session.initialize.resolved", ({ error, data: data2 }) => {
      if (data2) {
        this.onSessionSuccess(data2);
        __privateGet(this, _callsQueue).forEach((_0) => __async(this, [_0], function* ({ fn, resolve }) {
          resolve(yield fn());
        }));
        __privateSet(this, _callsQueue, []);
      } else if (error) {
        this.onSessionError(error);
        __privateSet(this, _sessionError, error);
        __privateGet(this, _callsQueue).forEach(({ resolve }) => {
          resolve({ error: new NovuError("Failed to initialize session, please contact the support", error) });
        });
        __privateSet(this, _callsQueue, []);
      }
    });
  }
  onSessionSuccess(_) {
  }
  onSessionError(_) {
  }
  callWithSession(fn) {
    return __async(this, null, function* () {
      if (this._inboxService.isSessionInitialized) {
        return fn();
      }
      if (__privateGet(this, _sessionError)) {
        return Promise.resolve({
          error: new NovuError("Failed to initialize session, please contact the support", __privateGet(this, _sessionError))
        });
      }
      return new Promise((resolve, reject) => {
        __privateGet(this, _callsQueue).push({ fn, resolve, reject });
      });
    });
  }
};
_callsQueue = /* @__PURE__ */ new WeakMap();
_sessionError = /* @__PURE__ */ new WeakMap();
var _emitter;
var _inboxService;
var Notification = class {
  constructor(notification, emitter, inboxService) {
    __privateAdd(this, _emitter);
    __privateAdd(this, _inboxService);
    __privateSet(this, _emitter, emitter);
    __privateSet(this, _inboxService, inboxService);
    this.id = notification.id;
    this.subject = notification.subject;
    this.body = notification.body;
    this.to = notification.to;
    this.isRead = notification.isRead;
    this.isArchived = notification.isArchived;
    this.isSnoozed = notification.isSnoozed;
    this.snoozedUntil = notification.snoozedUntil;
    this.deliveredAt = notification.deliveredAt;
    this.createdAt = notification.createdAt;
    this.readAt = notification.readAt;
    this.archivedAt = notification.archivedAt;
    this.avatar = notification.avatar;
    this.primaryAction = notification.primaryAction;
    this.secondaryAction = notification.secondaryAction;
    this.channelType = notification.channelType;
    this.tags = notification.tags;
    this.redirect = notification.redirect;
    this.data = notification.data;
    this.workflow = notification.workflow;
  }
  read() {
    return read({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      }
    });
  }
  unread() {
    return unread({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      }
    });
  }
  archive() {
    return archive({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      }
    });
  }
  unarchive() {
    return unarchive({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      }
    });
  }
  snooze(snoozeUntil) {
    return snooze({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this,
        snoozeUntil
      }
    });
  }
  unsnooze() {
    return unsnooze({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: { notification: this }
    });
  }
  completePrimary() {
    if (!this.primaryAction) {
      throw new Error("Primary action is not available");
    }
    return completeAction({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      },
      actionType: "primary"
      /* PRIMARY */
    });
  }
  completeSecondary() {
    if (!this.primaryAction) {
      throw new Error("Secondary action is not available");
    }
    return completeAction({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      },
      actionType: "secondary"
      /* SECONDARY */
    });
  }
  revertPrimary() {
    if (!this.primaryAction) {
      throw new Error("Primary action is not available");
    }
    return revertAction({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      },
      actionType: "primary"
      /* PRIMARY */
    });
  }
  revertSecondary() {
    if (!this.primaryAction) {
      throw new Error("Secondary action is not available");
    }
    return revertAction({
      emitter: __privateGet(this, _emitter),
      apiService: __privateGet(this, _inboxService),
      args: {
        notification: this
      },
      actionType: "secondary"
      /* SECONDARY */
    });
  }
  on(eventName, listener) {
    const cleanup = __privateGet(this, _emitter).on(eventName, listener);
    return () => {
      cleanup();
    };
  }
  /**
   * @deprecated
   * Use the cleanup function returned by the "on" method instead.
   */
  off(eventName, listener) {
    __privateGet(this, _emitter).off(eventName, listener);
  }
};
_emitter = /* @__PURE__ */ new WeakMap();
_inboxService = /* @__PURE__ */ new WeakMap();
var read = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isRead: true,
      readAt: (/* @__PURE__ */ new Date()).toISOString(),
      isArchived: false,
      archivedAt: void 0
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.read.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.read(notificationId);
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.read.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.read.resolved", { args, error });
    return { error: new NovuError("Failed to read notification", error) };
  }
});
var unread = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isRead: false,
      readAt: null,
      isArchived: false,
      archivedAt: void 0
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.unread.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.unread(notificationId);
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.unread.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.unread.resolved", { args, error });
    return { error: new NovuError("Failed to unread notification", error) };
  }
});
var archive = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isArchived: true,
      archivedAt: (/* @__PURE__ */ new Date()).toISOString(),
      isRead: true,
      readAt: (/* @__PURE__ */ new Date()).toISOString()
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.archive.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.archive(notificationId);
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.archive.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.archive.resolved", { args, error });
    return { error: new NovuError("Failed to archive notification", error) };
  }
});
var unarchive = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isArchived: false,
      archivedAt: null,
      isRead: true,
      readAt: (/* @__PURE__ */ new Date()).toISOString()
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.unarchive.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.unarchive(notificationId);
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.unarchive.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.unarchive.resolved", { args, error });
    return { error: new NovuError("Failed to unarchive notification", error) };
  }
});
var snooze = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isSnoozed: true,
      snoozedUntil: args.snoozeUntil
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.snooze.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.snooze(notificationId, args.snoozeUntil);
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.snooze.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.snooze.resolved", { args, error });
    return { error: new NovuError("Failed to snooze notification", error) };
  }
});
var unsnooze = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args
}) {
  const { notificationId, optimisticValue } = getNotificationDetails(
    args,
    {
      isSnoozed: false,
      snoozedUntil: null
    },
    {
      emitter,
      apiService
    }
  );
  try {
    emitter.emit("notification.unsnooze.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.unsnooze(notificationId);
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.unsnooze.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.unsnooze.resolved", { args, error });
    return { error: new NovuError("Failed to unsnooze notification", error) };
  }
});
var completeAction = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args,
  actionType
}) {
  const optimisticUpdate = actionType === "primary" ? {
    primaryAction: __spreadProps(__spreadValues({}, "notification" in args ? args.notification.primaryAction : {}), {
      isCompleted: true
    })
  } : {
    secondaryAction: __spreadProps(__spreadValues({}, "notification" in args ? args.notification.secondaryAction : {}), {
      isCompleted: true
    })
  };
  const { notificationId, optimisticValue } = getNotificationDetails(args, optimisticUpdate, {
    emitter,
    apiService
  });
  try {
    emitter.emit("notification.complete_action.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.completeAction({ actionType, notificationId });
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.complete_action.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.complete_action.resolved", { args, error });
    return { error: new NovuError(`Failed to complete ${actionType} action on the notification`, error) };
  }
});
var revertAction = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  args,
  actionType
}) {
  const optimisticUpdate = actionType === "primary" ? {
    primaryAction: __spreadProps(__spreadValues({}, "notification" in args ? args.notification.primaryAction : {}), {
      isCompleted: false
    })
  } : {
    secondaryAction: __spreadProps(__spreadValues({}, "notification" in args ? args.notification.secondaryAction : {}), {
      isCompleted: false
    })
  };
  const { notificationId, optimisticValue } = getNotificationDetails(args, optimisticUpdate, {
    emitter,
    apiService
  });
  try {
    emitter.emit("notification.revert_action.pending", {
      args,
      data: optimisticValue
    });
    const response = yield apiService.revertAction({ actionType, notificationId });
    const updatedNotification = new Notification(response, emitter, apiService);
    emitter.emit("notification.revert_action.resolved", { args, data: updatedNotification });
    return { data: updatedNotification };
  } catch (error) {
    emitter.emit("notification.revert_action.resolved", { args, error });
    return { error: new NovuError("Failed to fetch notifications", error) };
  }
});
var getNotificationDetails = (args, update, dependencies) => {
  if ("notification" in args) {
    return {
      notificationId: args.notification.id,
      optimisticValue: new Notification(
        __spreadValues(__spreadValues({}, args.notification), update),
        dependencies.emitter,
        dependencies.apiService
      )
    };
  } else {
    return {
      notificationId: args.notificationId
    };
  }
};
var readAll = (_0) => __async(void 0, [_0], function* ({
  emitter,
  inboxService,
  notificationsCache,
  tags
}) {
  try {
    const notifications = notificationsCache.getUniqueNotifications({ tags });
    const optimisticNotifications = notifications.map(
      (notification) => new Notification(
        __spreadProps(__spreadValues({}, notification), {
          isRead: true,
          readAt: (/* @__PURE__ */ new Date()).toISOString(),
          isArchived: false,
          archivedAt: void 0
        }),
        emitter,
        inboxService
      )
    );
    emitter.emit("notifications.read_all.pending", { args: { tags }, data: optimisticNotifications });
    yield inboxService.readAll({ tags });
    emitter.emit("notifications.read_all.resolved", { args: { tags }, data: optimisticNotifications });
    return {};
  } catch (error) {
    emitter.emit("notifications.read_all.resolved", { args: { tags }, error });
    return { error: new NovuError("Failed to read all notifications", error) };
  }
});
var archiveAll = (_0) => __async(void 0, [_0], function* ({
  emitter,
  inboxService,
  notificationsCache,
  tags
}) {
  try {
    const notifications = notificationsCache.getUniqueNotifications({ tags });
    const optimisticNotifications = notifications.map(
      (notification) => new Notification(
        __spreadProps(__spreadValues({}, notification), {
          isRead: true,
          readAt: (/* @__PURE__ */ new Date()).toISOString(),
          isArchived: true,
          archivedAt: (/* @__PURE__ */ new Date()).toISOString()
        }),
        emitter,
        inboxService
      )
    );
    emitter.emit("notifications.archive_all.pending", { args: { tags }, data: optimisticNotifications });
    yield inboxService.archiveAll({ tags });
    emitter.emit("notifications.archive_all.resolved", { args: { tags }, data: optimisticNotifications });
    return {};
  } catch (error) {
    emitter.emit("notifications.archive_all.resolved", { args: { tags }, error });
    return { error: new NovuError("Failed to archive all notifications", error) };
  }
});
var archiveAllRead = (_0) => __async(void 0, [_0], function* ({
  emitter,
  inboxService,
  notificationsCache,
  tags
}) {
  try {
    const notifications = notificationsCache.getUniqueNotifications({ tags, read: true });
    const optimisticNotifications = notifications.map(
      (notification) => new Notification(
        __spreadProps(__spreadValues({}, notification), { isArchived: true, archivedAt: (/* @__PURE__ */ new Date()).toISOString() }),
        emitter,
        inboxService
      )
    );
    emitter.emit("notifications.archive_all_read.pending", { args: { tags }, data: optimisticNotifications });
    yield inboxService.archiveAllRead({ tags });
    emitter.emit("notifications.archive_all_read.resolved", { args: { tags }, data: optimisticNotifications });
    return {};
  } catch (error) {
    emitter.emit("notifications.archive_all_read.resolved", { args: { tags }, error });
    return { error: new NovuError("Failed to archive all read notifications", error) };
  }
});
var _cache;
var InMemoryCache = class {
  constructor() {
    __privateAdd(this, _cache);
    __privateSet(this, _cache, /* @__PURE__ */ new Map());
  }
  get(key) {
    return __privateGet(this, _cache).get(key);
  }
  getValues() {
    return Array.from(__privateGet(this, _cache).values());
  }
  entries() {
    return Array.from(__privateGet(this, _cache).entries());
  }
  keys() {
    return Array.from(__privateGet(this, _cache).keys());
  }
  set(key, value2) {
    __privateGet(this, _cache).set(key, value2);
  }
  remove(key) {
    __privateGet(this, _cache).delete(key);
  }
  clear() {
    __privateGet(this, _cache).clear();
  }
};
_cache = /* @__PURE__ */ new WeakMap();
var excludeEmpty = ({ tags, read: read2, archived, snoozed, limit, offset: offset3, after }) => Object.entries({ tags, read: read2, archived, snoozed, limit, offset: offset3, after }).filter(([_, value2]) => value2 !== null && value2 !== void 0 && !(Array.isArray(value2) && value2.length === 0)).reduce((acc, [key, value2]) => {
  acc[key] = value2;
  return acc;
}, {});
var getCacheKey = ({ tags, read: read2, archived, snoozed, limit, offset: offset3, after }) => {
  return JSON.stringify(excludeEmpty({ tags, read: read2, archived, snoozed, limit, offset: offset3, after }));
};
var getFilterKey = ({
  tags,
  read: read2,
  archived,
  snoozed
}) => {
  return JSON.stringify(excludeEmpty({ tags, read: read2, archived, snoozed }));
};
var getFilter = (key) => {
  return JSON.parse(key);
};
var updateEvents = [
  "notification.read.pending",
  "notification.read.resolved",
  "notification.unread.pending",
  "notification.unread.resolved",
  "notification.complete_action.pending",
  "notification.complete_action.resolved",
  "notification.revert_action.pending",
  "notification.revert_action.resolved",
  "notifications.read_all.pending",
  "notifications.read_all.resolved"
];
var removeEvents = [
  "notification.archive.pending",
  "notification.unarchive.pending",
  "notification.snooze.pending",
  "notification.unsnooze.pending",
  "notifications.archive_all.pending",
  "notifications.archive_all_read.pending"
];
var _emitter2;
var _cache2;
var NotificationsCache = class {
  constructor({ emitter }) {
    __privateAdd(this, _emitter2);
    __privateAdd(this, _cache2);
    this.updateNotification = (key, data2) => {
      const notificationsResponse = __privateGet(this, _cache2).get(key);
      if (!notificationsResponse) {
        return false;
      }
      const index = notificationsResponse.notifications.findIndex((el) => el.id === data2.id);
      if (index === -1) {
        return false;
      }
      const updatedNotifications = [...notificationsResponse.notifications];
      updatedNotifications[index] = data2;
      __privateGet(this, _cache2).set(key, __spreadProps(__spreadValues({}, notificationsResponse), { notifications: updatedNotifications }));
      return true;
    };
    this.removeNotification = (key, data2) => {
      const notificationsResponse = __privateGet(this, _cache2).get(key);
      if (!notificationsResponse) {
        return false;
      }
      const index = notificationsResponse.notifications.findIndex((el) => el.id === data2.id);
      if (index === -1) {
        return false;
      }
      const newNotifications = [...notificationsResponse.notifications];
      newNotifications.splice(index, 1);
      __privateGet(this, _cache2).set(key, __spreadProps(__spreadValues({}, notificationsResponse), {
        notifications: newNotifications
      }));
      return true;
    };
    this.handleNotificationEvent = ({ remove } = { remove: false }) => ({ data: data2 }) => {
      if (!data2) {
        return;
      }
      const notifications = Array.isArray(data2) ? data2 : [data2];
      const uniqueFilterKeys = /* @__PURE__ */ new Set();
      __privateGet(this, _cache2).keys().forEach((key) => {
        notifications.forEach((notification) => {
          let isNotificationFound = false;
          if (remove) {
            isNotificationFound = this.removeNotification(key, notification);
          } else {
            isNotificationFound = this.updateNotification(key, notification);
          }
          if (isNotificationFound) {
            uniqueFilterKeys.add(getFilterKey(getFilter(key)));
          }
        });
      });
      uniqueFilterKeys.forEach((key) => {
        const notificationsResponse = this.getAggregated(getFilter(key));
        __privateGet(this, _emitter2).emit("notifications.list.updated", {
          data: notificationsResponse
        });
      });
    };
    __privateSet(this, _emitter2, emitter);
    updateEvents.forEach((event) => {
      __privateGet(this, _emitter2).on(event, this.handleNotificationEvent());
    });
    removeEvents.forEach((event) => {
      __privateGet(this, _emitter2).on(event, this.handleNotificationEvent({ remove: true }));
    });
    __privateSet(this, _cache2, new InMemoryCache());
  }
  getAggregated(filter) {
    const cacheKeys = __privateGet(this, _cache2).keys().filter((key) => {
      const parsedFilter = getFilter(key);
      return isSameFilter(parsedFilter, filter);
    });
    return cacheKeys.map((key) => __privateGet(this, _cache2).get(key)).reduce(
      (acc, el) => {
        if (!el) {
          return acc;
        }
        return {
          hasMore: el.hasMore,
          filter: el.filter,
          notifications: [...acc.notifications, ...el.notifications]
        };
      },
      { hasMore: false, filter: {}, notifications: [] }
    );
  }
  has(args) {
    return __privateGet(this, _cache2).get(getCacheKey(args)) !== void 0;
  }
  set(args, data2) {
    __privateGet(this, _cache2).set(getCacheKey(args), data2);
  }
  update(args, data2) {
    this.set(args, data2);
    const notificationsResponse = this.getAggregated(getFilter(getCacheKey(args)));
    __privateGet(this, _emitter2).emit("notifications.list.updated", {
      data: notificationsResponse
    });
  }
  getAll(args) {
    if (this.has(args)) {
      return this.getAggregated({ tags: args.tags, read: args.read, snoozed: args.snoozed, archived: args.archived });
    }
  }
  /**
   * Get unique notifications based on specified filter fields.
   * The same tags can be applied to multiple filters which means that the same notification can be duplicated.
   */
  getUniqueNotifications({ tags, read: read2 }) {
    const keys = __privateGet(this, _cache2).keys();
    const uniqueNotifications = /* @__PURE__ */ new Map();
    keys.forEach((key) => {
      const filter = getFilter(key);
      if (areTagsEqual(tags, filter.tags)) {
        const value2 = __privateGet(this, _cache2).get(key);
        if (!value2) {
          return;
        }
        value2.notifications.filter((el) => typeof read2 === "undefined" || read2 === el.isRead).forEach((notification) => uniqueNotifications.set(notification.id, notification));
      }
    });
    return Array.from(uniqueNotifications.values());
  }
  clear(filter) {
    const keys = __privateGet(this, _cache2).keys();
    keys.forEach((key) => {
      if (isSameFilter(getFilter(key), filter)) {
        __privateGet(this, _cache2).remove(key);
      }
    });
  }
  clearAll() {
    __privateGet(this, _cache2).clear();
  }
};
_emitter2 = /* @__PURE__ */ new WeakMap();
_cache2 = /* @__PURE__ */ new WeakMap();
var _useCache;
var Notifications = class extends BaseModule {
  constructor({
    useCache,
    inboxServiceInstance,
    eventEmitterInstance
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance
    });
    __privateAdd(this, _useCache);
    this.cache = new NotificationsCache({
      emitter: eventEmitterInstance
    });
    __privateSet(this, _useCache, useCache);
  }
  list() {
    return __async(this, arguments, function* (_a = {}) {
      var _b = _a, { limit = 10 } = _b, restOptions = __objRest(_b, ["limit"]);
      return this.callWithSession(() => __async(this, null, function* () {
        const args = __spreadValues({ limit }, restOptions);
        try {
          const shouldUseCache = "useCache" in args ? args.useCache : __privateGet(this, _useCache);
          let data2 = shouldUseCache ? this.cache.getAll(args) : void 0;
          this._emitter.emit("notifications.list.pending", { args, data: data2 });
          if (!data2) {
            const response = yield this._inboxService.fetchNotifications(__spreadValues({
              limit
            }, restOptions));
            data2 = {
              hasMore: response.hasMore,
              filter: response.filter,
              notifications: response.data.map((el) => new Notification(el, this._emitter, this._inboxService))
            };
            if (shouldUseCache) {
              this.cache.set(args, data2);
              data2 = this.cache.getAll(args);
            }
          }
          this._emitter.emit("notifications.list.resolved", { args, data: data2 });
          return { data: data2 };
        } catch (error) {
          this._emitter.emit("notifications.list.resolved", { args, error });
          return { error: new NovuError("Failed to fetch notifications", error) };
        }
      }));
    });
  }
  count(args) {
    return __async(this, null, function* () {
      return this.callWithSession(() => __async(this, null, function* () {
        const filters = args && "filters" in args ? args.filters : [__spreadValues({}, args)];
        try {
          this._emitter.emit("notifications.count.pending", { args });
          const response = yield this._inboxService.count({
            filters
          });
          const data2 = args && "filters" in args ? { counts: response.data } : response.data[0];
          this._emitter.emit("notifications.count.resolved", {
            args,
            data: data2
          });
          return { data: data2 };
        } catch (error) {
          this._emitter.emit("notifications.count.resolved", { args, error });
          return { error: new NovuError("Failed to count notifications", error) };
        }
      }));
    });
  }
  read(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return read({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  unread(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return unread({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  archive(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return archive({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  unarchive(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return unarchive({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  snooze(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return snooze({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  unsnooze(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return unsnooze({
            emitter: this._emitter,
            apiService: this._inboxService,
            args
          });
        })
      );
    });
  }
  completePrimary(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return completeAction({
            emitter: this._emitter,
            apiService: this._inboxService,
            args,
            actionType: "primary"
            /* PRIMARY */
          });
        })
      );
    });
  }
  completeSecondary(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return completeAction({
            emitter: this._emitter,
            apiService: this._inboxService,
            args,
            actionType: "secondary"
            /* SECONDARY */
          });
        })
      );
    });
  }
  revertPrimary(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return revertAction({
            emitter: this._emitter,
            apiService: this._inboxService,
            args,
            actionType: "primary"
            /* PRIMARY */
          });
        })
      );
    });
  }
  revertSecondary(args) {
    return __async(this, null, function* () {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return revertAction({
            emitter: this._emitter,
            apiService: this._inboxService,
            args,
            actionType: "secondary"
            /* SECONDARY */
          });
        })
      );
    });
  }
  readAll() {
    return __async(this, arguments, function* ({ tags } = {}) {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return readAll({
            emitter: this._emitter,
            inboxService: this._inboxService,
            notificationsCache: this.cache,
            tags
          });
        })
      );
    });
  }
  archiveAll() {
    return __async(this, arguments, function* ({ tags } = {}) {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return archiveAll({
            emitter: this._emitter,
            inboxService: this._inboxService,
            notificationsCache: this.cache,
            tags
          });
        })
      );
    });
  }
  archiveAllRead() {
    return __async(this, arguments, function* ({ tags } = {}) {
      return this.callWithSession(
        () => __async(this, null, function* () {
          return archiveAllRead({
            emitter: this._emitter,
            inboxService: this._inboxService,
            notificationsCache: this.cache,
            tags
          });
        })
      );
    });
  }
  clearCache({ filter } = {}) {
    if (filter) {
      return this.cache.clear(filter != null ? filter : {});
    }
    return this.cache.clearAll();
  }
};
_useCache = /* @__PURE__ */ new WeakMap();
var updatePreference = (_0) => __async(void 0, [_0], function* ({
  emitter,
  apiService,
  cache: cache2,
  useCache,
  args
}) {
  const { workflowId, channels } = args;
  try {
    emitter.emit("preference.update.pending", {
      args,
      data: args.preference ? new Preference(
        __spreadProps(__spreadValues({}, args.preference), {
          channels: __spreadValues(__spreadValues({}, args.preference.channels), channels)
        }),
        {
          emitterInstance: emitter,
          inboxServiceInstance: apiService,
          cache: cache2,
          useCache
        }
      ) : void 0
    });
    let response;
    if (workflowId) {
      response = yield apiService.updateWorkflowPreferences({ workflowId, channels });
    } else {
      optimisticUpdateWorkflowPreferences({ emitter, apiService, cache: cache2, useCache, args });
      response = yield apiService.updateGlobalPreferences(channels);
    }
    const preference = new Preference(response, {
      emitterInstance: emitter,
      inboxServiceInstance: apiService,
      cache: cache2,
      useCache
    });
    emitter.emit("preference.update.resolved", { args, data: preference });
    return { data: preference };
  } catch (error) {
    emitter.emit("preference.update.resolved", { args, error });
    return { error: new NovuError("Failed to fetch notifications", error) };
  }
});
var optimisticUpdateWorkflowPreferences = ({
  emitter,
  apiService,
  cache: cache2,
  useCache,
  args
}) => {
  const allPreferences = useCache ? cache2 == null ? void 0 : cache2.getAll({}) : void 0;
  allPreferences == null ? void 0 : allPreferences.forEach((el) => {
    var _a;
    if (el.level === "template") {
      const mergedPreference = __spreadProps(__spreadValues({}, el), {
        channels: Object.entries(el.channels).reduce((acc, [key, value2]) => {
          var _a2;
          const channelType = key;
          acc[channelType] = (_a2 = args.channels[channelType]) != null ? _a2 : value2;
          return acc;
        }, {})
      });
      const updatedPreference = args.preference ? new Preference(mergedPreference, {
        emitterInstance: emitter,
        inboxServiceInstance: apiService,
        cache: cache2,
        useCache
      }) : void 0;
      if (updatedPreference) {
        emitter.emit("preference.update.pending", {
          args: {
            workflowId: (_a = el.workflow) == null ? void 0 : _a.id,
            channels: updatedPreference.channels
          },
          data: updatedPreference
        });
      }
    }
  });
};
var _emitter3;
var _apiService;
var _cache3;
var _useCache2;
var Preference = class {
  constructor(preference, {
    emitterInstance,
    inboxServiceInstance,
    cache: cache2,
    useCache
  }) {
    __privateAdd(this, _emitter3);
    __privateAdd(this, _apiService);
    __privateAdd(this, _cache3);
    __privateAdd(this, _useCache2);
    __privateSet(this, _emitter3, emitterInstance);
    __privateSet(this, _apiService, inboxServiceInstance);
    __privateSet(this, _cache3, cache2);
    __privateSet(this, _useCache2, useCache);
    this.level = preference.level;
    this.enabled = preference.enabled;
    this.channels = preference.channels;
    this.workflow = preference.workflow;
  }
  update({
    channels,
    /** @deprecated Use channels instead */
    channelPreferences
  }) {
    var _a;
    return updatePreference({
      emitter: __privateGet(this, _emitter3),
      apiService: __privateGet(this, _apiService),
      cache: __privateGet(this, _cache3),
      useCache: __privateGet(this, _useCache2),
      args: {
        workflowId: (_a = this.workflow) == null ? void 0 : _a.id,
        channels: channels || channelPreferences,
        preference: {
          level: this.level,
          enabled: this.enabled,
          channels: this.channels,
          workflow: this.workflow
        }
      }
    });
  }
};
_emitter3 = /* @__PURE__ */ new WeakMap();
_apiService = /* @__PURE__ */ new WeakMap();
_cache3 = /* @__PURE__ */ new WeakMap();
_useCache2 = /* @__PURE__ */ new WeakMap();
var updateEvents2 = ["preference.update.pending", "preference.update.resolved"];
var excludeEmpty2 = ({ tags }) => Object.entries({ tags }).reduce((acc, [key, value2]) => {
  if (value2 === null || value2 === void 0 || Array.isArray(value2) && value2.length === 0) {
    return acc;
  }
  acc[key] = value2;
  return acc;
}, {});
var getCacheKey2 = ({ tags }) => {
  return JSON.stringify(excludeEmpty2({ tags }));
};
var _emitter4;
var _cache4;
var PreferencesCache = class {
  constructor({ emitterInstance }) {
    __privateAdd(this, _emitter4);
    __privateAdd(this, _cache4);
    this.updatePreference = (key, data2) => {
      const preferences = __privateGet(this, _cache4).get(key);
      if (!preferences) {
        return false;
      }
      const index = preferences.findIndex(
        (el) => {
          var _a, _b;
          return ((_a = el.workflow) == null ? void 0 : _a.id) === ((_b = data2.workflow) == null ? void 0 : _b.id) || el.level === data2.level && data2.level === "global";
        }
      );
      if (index === -1) {
        return false;
      }
      const updatedPreferences = [...preferences];
      updatedPreferences[index] = data2;
      __privateGet(this, _cache4).set(key, updatedPreferences);
      return true;
    };
    this.handlePreferenceEvent = ({ data: data2 }) => {
      if (!data2) {
        return;
      }
      __privateGet(this, _cache4).keys().forEach((key) => {
        const hasUpdatedPreference = this.updatePreference(key, data2);
        const updatedPreference = __privateGet(this, _cache4).get(key);
        if (!hasUpdatedPreference || !updatedPreference) {
          return;
        }
        __privateGet(this, _emitter4).emit("preferences.list.updated", {
          data: updatedPreference
        });
      });
    };
    __privateSet(this, _emitter4, emitterInstance);
    updateEvents2.forEach((event) => {
      __privateGet(this, _emitter4).on(event, this.handlePreferenceEvent);
    });
    __privateSet(this, _cache4, new InMemoryCache());
  }
  has(args) {
    return __privateGet(this, _cache4).get(getCacheKey2(args)) !== void 0;
  }
  set(args, data2) {
    __privateGet(this, _cache4).set(getCacheKey2(args), data2);
  }
  getAll(args) {
    if (this.has(args)) {
      return __privateGet(this, _cache4).get(getCacheKey2(args));
    }
  }
  clearAll() {
    __privateGet(this, _cache4).clear();
  }
};
_emitter4 = /* @__PURE__ */ new WeakMap();
_cache4 = /* @__PURE__ */ new WeakMap();
var _useCache3;
var Preferences = class extends BaseModule {
  constructor({
    useCache,
    inboxServiceInstance,
    eventEmitterInstance
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance
    });
    __privateAdd(this, _useCache3);
    this.cache = new PreferencesCache({
      emitterInstance: this._emitter
    });
    __privateSet(this, _useCache3, useCache);
  }
  list() {
    return __async(this, arguments, function* (args = {}) {
      return this.callWithSession(() => __async(this, null, function* () {
        try {
          let data2 = __privateGet(this, _useCache3) ? this.cache.getAll(args) : void 0;
          this._emitter.emit("preferences.list.pending", { args, data: data2 });
          if (!data2) {
            const response = yield this._inboxService.fetchPreferences(args.tags);
            data2 = response.map(
              (el) => new Preference(el, {
                emitterInstance: this._emitter,
                inboxServiceInstance: this._inboxService,
                cache: this.cache,
                useCache: __privateGet(this, _useCache3)
              })
            );
            if (__privateGet(this, _useCache3)) {
              this.cache.set(args, data2);
              data2 = this.cache.getAll(args);
            }
          }
          this._emitter.emit("preferences.list.resolved", { args, data: data2 });
          return { data: data2 };
        } catch (error) {
          this._emitter.emit("preferences.list.resolved", { args, error });
          throw error;
        }
      }));
    });
  }
};
_useCache3 = /* @__PURE__ */ new WeakMap();
var _emitter5;
var _inboxService2;
var _options;
var Session = class {
  constructor(options, inboxServiceInstance, eventEmitterInstance) {
    __privateAdd(this, _emitter5);
    __privateAdd(this, _inboxService2);
    __privateAdd(this, _options);
    __privateSet(this, _emitter5, eventEmitterInstance);
    __privateSet(this, _inboxService2, inboxServiceInstance);
    __privateSet(this, _options, options);
  }
  get applicationIdentifier() {
    return __privateGet(this, _options).applicationIdentifier;
  }
  get subscriberId() {
    return __privateGet(this, _options).subscriber.subscriberId;
  }
  initialize() {
    return __async(this, null, function* () {
      try {
        const { applicationIdentifier, subscriberHash, subscriber } = __privateGet(this, _options);
        __privateGet(this, _emitter5).emit("session.initialize.pending", { args: __privateGet(this, _options) });
        const response = yield __privateGet(this, _inboxService2).initializeSession({
          applicationIdentifier,
          subscriberHash,
          subscriber
        });
        __privateGet(this, _emitter5).emit("session.initialize.resolved", { args: __privateGet(this, _options), data: response });
      } catch (error) {
        __privateGet(this, _emitter5).emit("session.initialize.resolved", { args: __privateGet(this, _options), error });
      }
    });
  }
};
_emitter5 = /* @__PURE__ */ new WeakMap();
_inboxService2 = /* @__PURE__ */ new WeakMap();
_options = /* @__PURE__ */ new WeakMap();
var PRODUCTION_SOCKET_URL = "https://ws.novu.co";
var NOTIFICATION_RECEIVED = "notifications.notification_received";
var UNSEEN_COUNT_CHANGED = "notifications.unseen_count_changed";
var UNREAD_COUNT_CHANGED = "notifications.unread_count_changed";
var mapToNotification = ({
  _id,
  content,
  read: read2,
  archived,
  snoozedUntil,
  deliveredAt,
  createdAt,
  lastReadDate,
  archivedAt,
  channel,
  subscriber,
  subject,
  avatar,
  cta,
  tags,
  data: data2,
  workflow
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const to = {
    id: subscriber == null ? void 0 : subscriber._id,
    subscriberId: subscriber == null ? void 0 : subscriber.subscriberId,
    firstName: subscriber == null ? void 0 : subscriber.firstName,
    lastName: subscriber == null ? void 0 : subscriber.lastName,
    avatar: subscriber == null ? void 0 : subscriber.avatar,
    locale: subscriber == null ? void 0 : subscriber.locale,
    data: subscriber == null ? void 0 : subscriber.data,
    timezone: subscriber == null ? void 0 : subscriber.timezone,
    email: subscriber == null ? void 0 : subscriber.email,
    phone: subscriber == null ? void 0 : subscriber.phone
  };
  const primaryCta = (_b = (_a = cta.action) == null ? void 0 : _a.buttons) == null ? void 0 : _b.find(
    (button) => button.type === "primary"
    /* PRIMARY */
  );
  const secondaryCta = (_d = (_c = cta.action) == null ? void 0 : _c.buttons) == null ? void 0 : _d.find(
    (button) => button.type === "secondary"
    /* SECONDARY */
  );
  const actionType = (_f = (_e = cta.action) == null ? void 0 : _e.result) == null ? void 0 : _f.type;
  const actionStatus = (_g = cta.action) == null ? void 0 : _g.status;
  return __spreadProps(__spreadValues(__spreadValues({
    id: _id,
    subject,
    body: content,
    to,
    isRead: read2,
    isArchived: archived,
    isSnoozed: !!snoozedUntil
  }, deliveredAt && {
    deliveredAt
  }), snoozedUntil && {
    snoozedUntil
  }), {
    createdAt,
    readAt: lastReadDate,
    archivedAt,
    avatar,
    primaryAction: primaryCta && {
      label: primaryCta.content,
      isCompleted: actionType === "primary" && actionStatus === "done",
      redirect: primaryCta.url ? {
        target: primaryCta.target,
        url: primaryCta.url
      } : void 0
    },
    secondaryAction: secondaryCta && {
      label: secondaryCta.content,
      isCompleted: actionType === "secondary" && actionStatus === "done",
      redirect: secondaryCta.url ? {
        target: secondaryCta.target,
        url: secondaryCta.url
      } : void 0
    },
    channelType: channel,
    tags,
    redirect: ((_h = cta.data) == null ? void 0 : _h.url) ? {
      url: cta.data.url,
      target: cta.data.target
    } : void 0,
    data: data2,
    workflow
  });
};
var _token;
var _emitter6;
var _socketIo;
var _socketUrl;
var _notificationReceived;
var _unseenCountChanged;
var _unreadCountChanged;
var _Socket_instances;
var initializeSocket_fn;
var handleConnectSocket_fn;
var handleDisconnectSocket_fn;
var Socket3 = class extends BaseModule {
  constructor({
    socketUrl,
    inboxServiceInstance,
    eventEmitterInstance
  }) {
    super({
      eventEmitterInstance,
      inboxServiceInstance
    });
    __privateAdd(this, _Socket_instances);
    __privateAdd(this, _token);
    __privateAdd(this, _emitter6);
    __privateAdd(this, _socketIo);
    __privateAdd(this, _socketUrl);
    __privateAdd(this, _notificationReceived, ({ message }) => {
      __privateGet(this, _emitter6).emit(NOTIFICATION_RECEIVED, {
        result: new Notification(mapToNotification(message), __privateGet(this, _emitter6), this._inboxService)
      });
    });
    __privateAdd(this, _unseenCountChanged, ({ unseenCount }) => {
      __privateGet(this, _emitter6).emit(UNSEEN_COUNT_CHANGED, {
        result: unseenCount
      });
    });
    __privateAdd(this, _unreadCountChanged, ({ unreadCount }) => {
      __privateGet(this, _emitter6).emit(UNREAD_COUNT_CHANGED, {
        result: unreadCount
      });
    });
    __privateSet(this, _emitter6, eventEmitterInstance);
    __privateSet(this, _socketUrl, socketUrl != null ? socketUrl : PRODUCTION_SOCKET_URL);
  }
  onSessionSuccess({ token }) {
    __privateSet(this, _token, token);
  }
  isSocketEvent(eventName) {
    return eventName === NOTIFICATION_RECEIVED || eventName === UNSEEN_COUNT_CHANGED || eventName === UNREAD_COUNT_CHANGED;
  }
  connect() {
    return __async(this, null, function* () {
      if (__privateGet(this, _token)) {
        return __privateMethod(this, _Socket_instances, handleConnectSocket_fn).call(this);
      }
      return this.callWithSession(__privateMethod(this, _Socket_instances, handleConnectSocket_fn).bind(this));
    });
  }
  disconnect() {
    return __async(this, null, function* () {
      if (__privateGet(this, _socketIo)) {
        return __privateMethod(this, _Socket_instances, handleDisconnectSocket_fn).call(this);
      }
      return this.callWithSession(__privateMethod(this, _Socket_instances, handleDisconnectSocket_fn).bind(this));
    });
  }
};
_token = /* @__PURE__ */ new WeakMap();
_emitter6 = /* @__PURE__ */ new WeakMap();
_socketIo = /* @__PURE__ */ new WeakMap();
_socketUrl = /* @__PURE__ */ new WeakMap();
_notificationReceived = /* @__PURE__ */ new WeakMap();
_unseenCountChanged = /* @__PURE__ */ new WeakMap();
_unreadCountChanged = /* @__PURE__ */ new WeakMap();
_Socket_instances = /* @__PURE__ */ new WeakSet();
initializeSocket_fn = function() {
  return __async(this, null, function* () {
    var _a, _b, _c;
    if (!!__privateGet(this, _socketIo)) {
      return;
    }
    const args = { socketUrl: __privateGet(this, _socketUrl) };
    __privateGet(this, _emitter6).emit("socket.connect.pending", { args });
    __privateSet(this, _socketIo, lookup2(__privateGet(this, _socketUrl), {
      reconnectionDelayMax: 1e4,
      transports: ["websocket"],
      query: {
        token: `${__privateGet(this, _token)}`
      }
    }));
    __privateGet(this, _socketIo).on("connect", () => {
      __privateGet(this, _emitter6).emit("socket.connect.resolved", { args });
    });
    __privateGet(this, _socketIo).on("connect_error", (error) => {
      __privateGet(this, _emitter6).emit("socket.connect.resolved", { args, error });
    });
    (_a = __privateGet(this, _socketIo)) == null ? void 0 : _a.on("notification_received", __privateGet(this, _notificationReceived));
    (_b = __privateGet(this, _socketIo)) == null ? void 0 : _b.on("unseen_count_changed", __privateGet(this, _unseenCountChanged));
    (_c = __privateGet(this, _socketIo)) == null ? void 0 : _c.on("unread_count_changed", __privateGet(this, _unreadCountChanged));
  });
};
handleConnectSocket_fn = function() {
  return __async(this, null, function* () {
    try {
      yield __privateMethod(this, _Socket_instances, initializeSocket_fn).call(this);
      return {};
    } catch (error) {
      return { error: new NovuError("Failed to initialize the socket", error) };
    }
  });
};
handleDisconnectSocket_fn = function() {
  return __async(this, null, function* () {
    var _a;
    try {
      (_a = __privateGet(this, _socketIo)) == null ? void 0 : _a.disconnect();
      __privateSet(this, _socketIo, void 0);
      return {};
    } catch (error) {
      return { error: new NovuError("Failed to disconnect from the socket", error) };
    }
  });
};
var _emitter7;
var _session;
var _inboxService3;
var Novu = class {
  constructor(options) {
    __privateAdd(this, _emitter7);
    __privateAdd(this, _session);
    __privateAdd(this, _inboxService3);
    var _a, _b;
    __privateSet(this, _inboxService3, new InboxService({
      apiUrl: options.apiUrl || options.backendUrl,
      userAgent: options.__userAgent
    }));
    __privateSet(this, _emitter7, new NovuEventEmitter());
    __privateSet(this, _session, new Session(
      {
        applicationIdentifier: options.applicationIdentifier,
        subscriberHash: options.subscriberHash,
        subscriber: buildSubscriber(options)
      },
      __privateGet(this, _inboxService3),
      __privateGet(this, _emitter7)
    ));
    __privateGet(this, _session).initialize();
    this.notifications = new Notifications({
      useCache: (_a = options.useCache) != null ? _a : true,
      inboxServiceInstance: __privateGet(this, _inboxService3),
      eventEmitterInstance: __privateGet(this, _emitter7)
    });
    this.preferences = new Preferences({
      useCache: (_b = options.useCache) != null ? _b : true,
      inboxServiceInstance: __privateGet(this, _inboxService3),
      eventEmitterInstance: __privateGet(this, _emitter7)
    });
    this.socket = new Socket3({
      socketUrl: options.socketUrl,
      eventEmitterInstance: __privateGet(this, _emitter7),
      inboxServiceInstance: __privateGet(this, _inboxService3)
    });
    this.on = (eventName, listener) => {
      if (this.socket.isSocketEvent(eventName)) {
        this.socket.connect();
      }
      const cleanup = __privateGet(this, _emitter7).on(eventName, listener);
      return () => {
        cleanup();
      };
    };
    this.off = (eventName, listener) => {
      __privateGet(this, _emitter7).off(eventName, listener);
    };
  }
  get applicationIdentifier() {
    return __privateGet(this, _session).applicationIdentifier;
  }
  get subscriberId() {
    return __privateGet(this, _session).subscriberId;
  }
};
_emitter7 = /* @__PURE__ */ new WeakMap();
_session = /* @__PURE__ */ new WeakMap();
_inboxService3 = /* @__PURE__ */ new WeakMap();
function buildSubscriber(options) {
  let subscriberObj;
  if (options.subscriber) {
    subscriberObj = typeof options.subscriber === "string" ? { subscriberId: options.subscriber } : options.subscriber;
  } else {
    subscriberObj = { subscriberId: options.subscriberId };
  }
  return subscriberObj;
}

// node_modules/@novu/js/dist/esm/chunk-GPV65U5R.mjs
var parseMarkdownIntoTokens = (text) => {
  const tokens = [];
  let buffer = "";
  let inBold = false;
  for (let i2 = 0; i2 < text.length; i2 += 1) {
    if (text[i2] === "\\" && text[i2 + 1] === "*") {
      buffer += "*";
      i2 += 1;
    } else if (text[i2] === "*" && text[i2 + 1] === "*") {
      if (buffer) {
        tokens.push({
          type: inBold ? "bold" : "text",
          content: buffer
        });
        buffer = "";
      }
      inBold = !inBold;
      i2 += 1;
    } else {
      buffer += text[i2];
    }
  }
  if (buffer) {
    tokens.push({
      type: inBold ? "bold" : "text",
      content: buffer
    });
  }
  return tokens;
};

// node_modules/solid-js/dist/dev.js
var sharedConfig = {
  context: void 0,
  registry: void 0,
  effects: void 0,
  done: false,
  getContextId() {
    return getContextId(this.context.count);
  },
  getNextContextId() {
    return getContextId(this.context.count++);
  }
};
function getContextId(count) {
  const num = String(count), len = num.length - 1;
  return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
  sharedConfig.context = context;
}
function nextHydrateContext() {
  return {
    ...sharedConfig.context,
    id: sharedConfig.getNextContextId(),
    count: 0
  };
}
var IS_DEV = true;
var equalFn = (a, b) => a === b;
var $PROXY = Symbol("solid-proxy");
var SUPPORTS_PROXY = typeof Proxy === "function";
var $TRACK = Symbol("solid-track");
var $DEVCOMP = Symbol("solid-dev-component");
var signalOptions = {
  equals: equalFn
};
var ERROR = null;
var runEffects = runQueue;
var STALE = 1;
var PENDING = 2;
var UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var NO_INIT = {};
var Owner = null;
var Transition = null;
var Scheduler = null;
var ExternalSourceConfig = null;
var Listener = null;
var Updates = null;
var Effects = null;
var ExecCount = 0;
var DevHooks = {
  afterUpdate: null,
  afterCreateOwner: null,
  afterCreateSignal: null,
  afterRegisterGraph: null
};
function createRoot(fn, detachedOwner) {
  const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? {
    owned: null,
    cleanups: null,
    context: null,
    owner: null
  } : {
    owned: null,
    cleanups: null,
    context: current ? current.context : null,
    owner: current
  }, updateFn = unowned ? () => fn(() => {
    throw new Error("Dispose method must be an explicit argument to createRoot function");
  }) : () => fn(() => untrack(() => cleanNode(root)));
  DevHooks.afterCreateOwner && DevHooks.afterCreateOwner(root);
  Owner = root;
  Listener = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener = listener;
    Owner = owner;
  }
}
function createSignal(value2, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const s = {
    value: value2,
    observers: null,
    observerSlots: null,
    comparator: options.equals || void 0
  };
  {
    if (options.name) s.name = options.name;
    if (options.internal) {
      s.internal = true;
    } else {
      registerGraph(s);
      if (DevHooks.afterCreateSignal) DevHooks.afterCreateSignal(s);
    }
  }
  const setter = (value3) => {
    if (typeof value3 === "function") {
      if (Transition && Transition.running && Transition.sources.has(s)) value3 = value3(s.tValue);
      else value3 = value3(s.value);
    }
    return writeSignal(s, value3);
  };
  return [readSignal.bind(s), setter];
}
function createComputed(fn, value2, options) {
  const c = createComputation(fn, value2, true, STALE, options);
  if (Scheduler && Transition && Transition.running) Updates.push(c);
  else updateComputation(c);
}
function createRenderEffect(fn, value2, options) {
  const c = createComputation(fn, value2, false, STALE, options);
  if (Scheduler && Transition && Transition.running) Updates.push(c);
  else updateComputation(c);
}
function createEffect(fn, value2, options) {
  runEffects = runUserEffects;
  const c = createComputation(fn, value2, false, STALE, options), s = SuspenseContext && useContext(SuspenseContext);
  if (s) c.suspense = s;
  if (!options || !options.render) c.user = true;
  Effects ? Effects.push(c) : updateComputation(c);
}
function createMemo(fn, value2, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const c = createComputation(fn, value2, true, 0, options);
  c.observers = null;
  c.observerSlots = null;
  c.comparator = options.equals || void 0;
  if (Scheduler && Transition && Transition.running) {
    c.tState = STALE;
    Updates.push(c);
  } else updateComputation(c);
  return readSignal.bind(c);
}
function isPromise(v) {
  return v && typeof v === "object" && "then" in v;
}
function createResource(pSource, pFetcher, pOptions) {
  let source;
  let fetcher;
  let options;
  if (typeof pFetcher === "function") {
    source = pSource;
    fetcher = pFetcher;
    options = pOptions || {};
  } else {
    source = true;
    fetcher = pSource;
    options = pFetcher || {};
  }
  let pr = null, initP = NO_INIT, id = null, loadedUnderTransition = false, scheduled2 = false, resolved = "initialValue" in options, dynamic = typeof source === "function" && createMemo(source);
  const contexts = /* @__PURE__ */ new Set(), [value2, setValue] = (options.storage || createSignal)(options.initialValue), [error, setError] = createSignal(void 0), [track, trigger] = createSignal(void 0, {
    equals: false
  }), [state, setState] = createSignal(resolved ? "ready" : "unresolved");
  if (sharedConfig.context) {
    id = sharedConfig.getNextContextId();
    if (options.ssrLoadFrom === "initial") initP = options.initialValue;
    else if (sharedConfig.load && sharedConfig.has(id)) initP = sharedConfig.load(id);
  }
  function loadEnd(p, v, error2, key) {
    if (pr === p) {
      pr = null;
      key !== void 0 && (resolved = true);
      if ((p === initP || v === initP) && options.onHydrated)
        queueMicrotask(
          () => options.onHydrated(key, {
            value: v
          })
        );
      initP = NO_INIT;
      if (Transition && p && loadedUnderTransition) {
        Transition.promises.delete(p);
        loadedUnderTransition = false;
        runUpdates(() => {
          Transition.running = true;
          completeLoad(v, error2);
        }, false);
      } else completeLoad(v, error2);
    }
    return v;
  }
  function completeLoad(v, err) {
    runUpdates(() => {
      if (err === void 0) setValue(() => v);
      setState(err !== void 0 ? "errored" : resolved ? "ready" : "unresolved");
      setError(err);
      for (const c of contexts.keys()) c.decrement();
      contexts.clear();
    }, false);
  }
  function read2() {
    const c = SuspenseContext && useContext(SuspenseContext), v = value2(), err = error();
    if (err !== void 0 && !pr) throw err;
    if (Listener && !Listener.user && c) {
      createComputed(() => {
        track();
        if (pr) {
          if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);
          else if (!contexts.has(c)) {
            c.increment();
            contexts.add(c);
          }
        }
      });
    }
    return v;
  }
  function load(refetching = true) {
    if (refetching !== false && scheduled2) return;
    scheduled2 = false;
    const lookup3 = dynamic ? dynamic() : source;
    loadedUnderTransition = Transition && Transition.running;
    if (lookup3 == null || lookup3 === false) {
      loadEnd(pr, untrack(value2));
      return;
    }
    if (Transition && pr) Transition.promises.delete(pr);
    const p = initP !== NO_INIT ? initP : untrack(
      () => fetcher(lookup3, {
        value: value2(),
        refetching
      })
    );
    if (!isPromise(p)) {
      loadEnd(pr, p, void 0, lookup3);
      return p;
    }
    pr = p;
    if ("value" in p) {
      if (p.status === "success") loadEnd(pr, p.value, void 0, lookup3);
      else loadEnd(pr, void 0, castError(p.value), lookup3);
      return p;
    }
    scheduled2 = true;
    queueMicrotask(() => scheduled2 = false);
    runUpdates(() => {
      setState(resolved ? "refreshing" : "pending");
      trigger();
    }, false);
    return p.then(
      (v) => loadEnd(p, v, void 0, lookup3),
      (e) => loadEnd(p, void 0, castError(e), lookup3)
    );
  }
  Object.defineProperties(read2, {
    state: {
      get: () => state()
    },
    error: {
      get: () => error()
    },
    loading: {
      get() {
        const s = state();
        return s === "pending" || s === "refreshing";
      }
    },
    latest: {
      get() {
        if (!resolved) return read2();
        const err = error();
        if (err && !pr) throw err;
        return value2();
      }
    }
  });
  let owner = Owner;
  if (dynamic) createComputed(() => (owner = Owner, load(false)));
  else load(false);
  return [
    read2,
    {
      refetch: (info) => runWithOwner(owner, () => load(info)),
      mutate: setValue
    }
  ];
}
function batch(fn) {
  return runUpdates(fn, false);
}
function untrack(fn) {
  if (!ExternalSourceConfig && Listener === null) return fn();
  const listener = Listener;
  Listener = null;
  try {
    if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
    return fn();
  } finally {
    Listener = listener;
  }
}
function onMount(fn) {
  createEffect(() => untrack(fn));
}
function onCleanup(fn) {
  if (Owner === null)
    console.warn("cleanups created outside a `createRoot` or `render` will never be run");
  else if (Owner.cleanups === null) Owner.cleanups = [fn];
  else Owner.cleanups.push(fn);
  return fn;
}
function getListener() {
  return Listener;
}
function getOwner() {
  return Owner;
}
function runWithOwner(o, fn) {
  const prev2 = Owner;
  const prevListener = Listener;
  Owner = o;
  Listener = null;
  try {
    return runUpdates(fn, true);
  } catch (err) {
    handleError(err);
  } finally {
    Owner = prev2;
    Listener = prevListener;
  }
}
function startTransition(fn) {
  if (Transition && Transition.running) {
    fn();
    return Transition.done;
  }
  const l = Listener;
  const o = Owner;
  return Promise.resolve().then(() => {
    Listener = l;
    Owner = o;
    let t;
    if (Scheduler || SuspenseContext) {
      t = Transition || (Transition = {
        sources: /* @__PURE__ */ new Set(),
        effects: [],
        promises: /* @__PURE__ */ new Set(),
        disposed: /* @__PURE__ */ new Set(),
        queue: /* @__PURE__ */ new Set(),
        running: true
      });
      t.done || (t.done = new Promise((res) => t.resolve = res));
      t.running = true;
    }
    runUpdates(fn, false);
    Listener = Owner = null;
    return t ? t.done : void 0;
  });
}
var [transPending, setTransPending] = createSignal(false);
function devComponent(Comp, props) {
  const c = createComputation(
    () => untrack(() => {
      Object.assign(Comp, {
        [$DEVCOMP]: true
      });
      return Comp(props);
    }),
    void 0,
    true,
    0
  );
  c.props = props;
  c.observers = null;
  c.observerSlots = null;
  c.name = Comp.name;
  c.component = Comp;
  updateComputation(c);
  return c.tValue !== void 0 ? c.tValue : c.value;
}
function registerGraph(value2) {
  if (Owner) {
    if (Owner.sourceMap) Owner.sourceMap.push(value2);
    else Owner.sourceMap = [value2];
    value2.graph = Owner;
  }
  if (DevHooks.afterRegisterGraph) DevHooks.afterRegisterGraph(value2);
}
function createContext(defaultValue, options) {
  const id = Symbol("context");
  return {
    id,
    Provider: createProvider(id, options),
    defaultValue
  };
}
function useContext(context) {
  let value2;
  return Owner && Owner.context && (value2 = Owner.context[context.id]) !== void 0 ? value2 : context.defaultValue;
}
function children(fn) {
  const children2 = createMemo(fn);
  const memo2 = createMemo(() => resolveChildren(children2()), void 0, {
    name: "children"
  });
  memo2.toArray = () => {
    const c = memo2();
    return Array.isArray(c) ? c : c != null ? [c] : [];
  };
  return memo2;
}
var SuspenseContext;
function readSignal() {
  const runningTransition = Transition && Transition.running;
  if (this.sources && (runningTransition ? this.tState : this.state)) {
    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
    else {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(this), false);
      Updates = updates;
    }
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  if (runningTransition && Transition.sources.has(this)) return this.tValue;
  return this.value;
}
function writeSignal(node, value2, isComp) {
  let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
  if (!node.comparator || !node.comparator(current, value2)) {
    if (Transition) {
      const TransitionRunning = Transition.running;
      if (TransitionRunning || !isComp && Transition.sources.has(node)) {
        Transition.sources.add(node);
        node.tValue = value2;
      }
      if (!TransitionRunning) node.value = value2;
    } else node.value = value2;
    if (node.observers && node.observers.length) {
      runUpdates(() => {
        for (let i2 = 0; i2 < node.observers.length; i2 += 1) {
          const o = node.observers[i2];
          const TransitionRunning = Transition && Transition.running;
          if (TransitionRunning && Transition.disposed.has(o)) continue;
          if (TransitionRunning ? !o.tState : !o.state) {
            if (o.pure) Updates.push(o);
            else Effects.push(o);
            if (o.observers) markDownstream(o);
          }
          if (!TransitionRunning) o.state = STALE;
          else o.tState = STALE;
        }
        if (Updates.length > 1e6) {
          Updates = [];
          if (IS_DEV) throw new Error("Potential Infinite Loop Detected.");
          throw new Error();
        }
      }, false);
    }
  }
  return value2;
}
function updateComputation(node) {
  if (!node.fn) return;
  cleanNode(node);
  const time2 = ExecCount;
  runComputation(
    node,
    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,
    time2
  );
  if (Transition && !Transition.running && Transition.sources.has(node)) {
    queueMicrotask(() => {
      runUpdates(() => {
        Transition && (Transition.running = true);
        Listener = Owner = node;
        runComputation(node, node.tValue, time2);
        Listener = Owner = null;
      }, false);
    });
  }
}
function runComputation(node, value2, time2) {
  let nextValue;
  const owner = Owner, listener = Listener;
  Listener = Owner = node;
  try {
    nextValue = node.fn(value2);
  } catch (err) {
    if (node.pure) {
      if (Transition && Transition.running) {
        node.tState = STALE;
        node.tOwned && node.tOwned.forEach(cleanNode);
        node.tOwned = void 0;
      } else {
        node.state = STALE;
        node.owned && node.owned.forEach(cleanNode);
        node.owned = null;
      }
    }
    node.updatedAt = time2 + 1;
    return handleError(err);
  } finally {
    Listener = listener;
    Owner = owner;
  }
  if (!node.updatedAt || node.updatedAt <= time2) {
    if (node.updatedAt != null && "observers" in node) {
      writeSignal(node, nextValue, true);
    } else if (Transition && Transition.running && node.pure) {
      Transition.sources.add(node);
      node.tValue = nextValue;
    } else node.value = nextValue;
    node.updatedAt = time2;
  }
}
function createComputation(fn, init, pure, state = STALE, options) {
  const c = {
    fn,
    state,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init,
    owner: Owner,
    context: Owner ? Owner.context : null,
    pure
  };
  if (Transition && Transition.running) {
    c.state = 0;
    c.tState = state;
  }
  if (Owner === null)
    console.warn("computations created outside a `createRoot` or `render` will never be disposed");
  else if (Owner !== UNOWNED) {
    if (Transition && Transition.running && Owner.pure) {
      if (!Owner.tOwned) Owner.tOwned = [c];
      else Owner.tOwned.push(c);
    } else {
      if (!Owner.owned) Owner.owned = [c];
      else Owner.owned.push(c);
    }
  }
  if (options && options.name) c.name = options.name;
  if (ExternalSourceConfig && c.fn) {
    const [track, trigger] = createSignal(void 0, {
      equals: false
    });
    const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
    onCleanup(() => ordinary.dispose());
    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
    const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
    c.fn = (x) => {
      track();
      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
    };
  }
  DevHooks.afterCreateOwner && DevHooks.afterCreateOwner(c);
  return c;
}
function runTop(node) {
  const runningTransition = Transition && Transition.running;
  if ((runningTransition ? node.tState : node.state) === 0) return;
  if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
  const ancestors = [node];
  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
    if (runningTransition && Transition.disposed.has(node)) return;
    if (runningTransition ? node.tState : node.state) ancestors.push(node);
  }
  for (let i2 = ancestors.length - 1; i2 >= 0; i2--) {
    node = ancestors[i2];
    if (runningTransition) {
      let top = node, prev2 = ancestors[i2 + 1];
      while ((top = top.owner) && top !== prev2) {
        if (Transition.disposed.has(top)) return;
      }
    }
    if ((runningTransition ? node.tState : node.state) === STALE) {
      updateComputation(node);
    } else if ((runningTransition ? node.tState : node.state) === PENDING) {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(node, ancestors[0]), false);
      Updates = updates;
    }
  }
}
function runUpdates(fn, init) {
  if (Updates) return fn();
  let wait = false;
  if (!init) Updates = [];
  if (Effects) wait = true;
  else Effects = [];
  ExecCount++;
  try {
    const res = fn();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!wait) Effects = null;
    Updates = null;
    handleError(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
    else runQueue(Updates);
    Updates = null;
  }
  if (wait) return;
  let res;
  if (Transition) {
    if (!Transition.promises.size && !Transition.queue.size) {
      const sources = Transition.sources;
      const disposed = Transition.disposed;
      Effects.push.apply(Effects, Transition.effects);
      res = Transition.resolve;
      for (const e2 of Effects) {
        "tState" in e2 && (e2.state = e2.tState);
        delete e2.tState;
      }
      Transition = null;
      runUpdates(() => {
        for (const d of disposed) cleanNode(d);
        for (const v of sources) {
          v.value = v.tValue;
          if (v.owned) {
            for (let i2 = 0, len = v.owned.length; i2 < len; i2++) cleanNode(v.owned[i2]);
          }
          if (v.tOwned) v.owned = v.tOwned;
          delete v.tValue;
          delete v.tOwned;
          v.tState = 0;
        }
        setTransPending(false);
      }, false);
    } else if (Transition.running) {
      Transition.running = false;
      Transition.effects.push.apply(Transition.effects, Effects);
      Effects = null;
      setTransPending(true);
      return;
    }
  }
  const e = Effects;
  Effects = null;
  if (e.length) runUpdates(() => runEffects(e), false);
  else DevHooks.afterUpdate && DevHooks.afterUpdate();
  if (res) res();
}
function runQueue(queue) {
  for (let i2 = 0; i2 < queue.length; i2++) runTop(queue[i2]);
}
function scheduleQueue(queue) {
  for (let i2 = 0; i2 < queue.length; i2++) {
    const item = queue[i2];
    const tasks = Transition.queue;
    if (!tasks.has(item)) {
      tasks.add(item);
      Scheduler(() => {
        tasks.delete(item);
        runUpdates(() => {
          Transition.running = true;
          runTop(item);
        }, false);
        Transition && (Transition.running = false);
      });
    }
  }
}
function runUserEffects(queue) {
  let i2, userLength = 0;
  for (i2 = 0; i2 < queue.length; i2++) {
    const e = queue[i2];
    if (!e.user) runTop(e);
    else queue[userLength++] = e;
  }
  if (sharedConfig.context) {
    if (sharedConfig.count) {
      sharedConfig.effects || (sharedConfig.effects = []);
      sharedConfig.effects.push(...queue.slice(0, userLength));
      return;
    }
    setHydrateContext();
  }
  if (sharedConfig.effects && (sharedConfig.done || !sharedConfig.count)) {
    queue = [...sharedConfig.effects, ...queue];
    userLength += sharedConfig.effects.length;
    delete sharedConfig.effects;
  }
  for (i2 = 0; i2 < userLength; i2++) runTop(queue[i2]);
}
function lookUpstream(node, ignore) {
  const runningTransition = Transition && Transition.running;
  if (runningTransition) node.tState = 0;
  else node.state = 0;
  for (let i2 = 0; i2 < node.sources.length; i2 += 1) {
    const source = node.sources[i2];
    if (source.sources) {
      const state = runningTransition ? source.tState : source.state;
      if (state === STALE) {
        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))
          runTop(source);
      } else if (state === PENDING) lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node) {
  const runningTransition = Transition && Transition.running;
  for (let i2 = 0; i2 < node.observers.length; i2 += 1) {
    const o = node.observers[i2];
    if (runningTransition ? !o.tState : !o.state) {
      if (runningTransition) o.tState = PENDING;
      else o.state = PENDING;
      if (o.pure) Updates.push(o);
      else Effects.push(o);
      o.observers && markDownstream(o);
    }
  }
}
function cleanNode(node) {
  let i2;
  if (node.sources) {
    while (node.sources.length) {
      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(), s = source.observerSlots.pop();
        if (index < obs.length) {
          n.sourceSlots[s] = index;
          obs[index] = n;
          source.observerSlots[index] = s;
        }
      }
    }
  }
  if (node.tOwned) {
    for (i2 = node.tOwned.length - 1; i2 >= 0; i2--) cleanNode(node.tOwned[i2]);
    delete node.tOwned;
  }
  if (Transition && Transition.running && node.pure) {
    reset(node, true);
  } else if (node.owned) {
    for (i2 = node.owned.length - 1; i2 >= 0; i2--) cleanNode(node.owned[i2]);
    node.owned = null;
  }
  if (node.cleanups) {
    for (i2 = node.cleanups.length - 1; i2 >= 0; i2--) node.cleanups[i2]();
    node.cleanups = null;
  }
  if (Transition && Transition.running) node.tState = 0;
  else node.state = 0;
  delete node.sourceMap;
}
function reset(node, top) {
  if (!top) {
    node.tState = 0;
    Transition.disposed.add(node);
  }
  if (node.owned) {
    for (let i2 = 0; i2 < node.owned.length; i2++) reset(node.owned[i2]);
  }
}
function castError(err) {
  if (err instanceof Error) return err;
  return new Error(typeof err === "string" ? err : "Unknown error", {
    cause: err
  });
}
function runErrors(err, fns, owner) {
  try {
    for (const f of fns) f(err);
  } catch (e) {
    handleError(e, owner && owner.owner || null);
  }
}
function handleError(err, owner = Owner) {
  const fns = ERROR && owner && owner.context && owner.context[ERROR];
  const error = castError(err);
  if (!fns) throw error;
  if (Effects)
    Effects.push({
      fn() {
        runErrors(error, fns, owner);
      },
      state: STALE
    });
  else runErrors(error, fns, owner);
}
function resolveChildren(children2) {
  if (typeof children2 === "function" && !children2.length) return resolveChildren(children2());
  if (Array.isArray(children2)) {
    const results2 = [];
    for (let i2 = 0; i2 < children2.length; i2++) {
      const result = resolveChildren(children2[i2]);
      Array.isArray(result) ? results2.push.apply(results2, result) : results2.push(result);
    }
    return results2;
  }
  return children2;
}
function createProvider(id, options) {
  return function provider(props) {
    let res;
    createRenderEffect(
      () => res = untrack(() => {
        Owner.context = {
          ...Owner.context,
          [id]: props.value
        };
        return children(() => props.children);
      }),
      void 0,
      options
    );
    return res;
  };
}
var FALLBACK = Symbol("fallback");
function dispose(d) {
  for (let i2 = 0; i2 < d.length; i2++) d[i2]();
}
function mapArray(list, mapFn, options = {}) {
  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
  onCleanup(() => dispose(disposers));
  return () => {
    let newItems = list() || [], newLen = newItems.length, i2, j;
    newItems[$TRACK];
    return untrack(() => {
      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
      if (newLen === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          indexes && (indexes = []);
        }
        if (options.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot((disposer) => {
            disposers[0] = disposer;
            return options.fallback();
          });
          len = 1;
        }
      } else if (len === 0) {
        mapped = new Array(newLen);
        for (j = 0; j < newLen; j++) {
          items[j] = newItems[j];
          mapped[j] = createRoot(mapper);
        }
        len = newLen;
      } else {
        temp = new Array(newLen);
        tempdisposers = new Array(newLen);
        indexes && (tempIndexes = new Array(newLen));
        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++) ;
        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
          temp[newEnd] = mapped[end];
          tempdisposers[newEnd] = disposers[end];
          indexes && (tempIndexes[newEnd] = indexes[end]);
        }
        newIndices = /* @__PURE__ */ new Map();
        newIndicesNext = new Array(newEnd + 1);
        for (j = newEnd; j >= start; j--) {
          item = newItems[j];
          i2 = newIndices.get(item);
          newIndicesNext[j] = i2 === void 0 ? -1 : i2;
          newIndices.set(item, j);
        }
        for (i2 = start; i2 <= end; i2++) {
          item = items[i2];
          j = newIndices.get(item);
          if (j !== void 0 && j !== -1) {
            temp[j] = mapped[i2];
            tempdisposers[j] = disposers[i2];
            indexes && (tempIndexes[j] = indexes[i2]);
            j = newIndicesNext[j];
            newIndices.set(item, j);
          } else disposers[i2]();
        }
        for (j = start; j < newLen; j++) {
          if (j in temp) {
            mapped[j] = temp[j];
            disposers[j] = tempdisposers[j];
            if (indexes) {
              indexes[j] = tempIndexes[j];
              indexes[j](j);
            }
          } else mapped[j] = createRoot(mapper);
        }
        mapped = mapped.slice(0, len = newLen);
        items = newItems.slice(0);
      }
      return mapped;
    });
    function mapper(disposer) {
      disposers[j] = disposer;
      if (indexes) {
        const [s, set] = createSignal(j, {
          name: "index"
        });
        indexes[j] = set;
        return mapFn(newItems[j], s);
      }
      return mapFn(newItems[j]);
    }
  };
}
var hydrationEnabled = false;
function createComponent(Comp, props) {
  if (hydrationEnabled) {
    if (sharedConfig.context) {
      const c = sharedConfig.context;
      setHydrateContext(nextHydrateContext());
      const r2 = devComponent(Comp, props || {});
      setHydrateContext(c);
      return r2;
    }
  }
  return devComponent(Comp, props || {});
}
function trueFn() {
  return true;
}
var propTraps = {
  get(_, property, receiver) {
    if (property === $PROXY) return receiver;
    return _.get(property);
  },
  has(_, property) {
    if (property === $PROXY) return true;
    return _.has(property);
  },
  set: trueFn,
  deleteProperty: trueFn,
  getOwnPropertyDescriptor(_, property) {
    return {
      configurable: true,
      enumerable: true,
      get() {
        return _.get(property);
      },
      set: trueFn,
      deleteProperty: trueFn
    };
  },
  ownKeys(_) {
    return _.keys();
  }
};
function resolveSource(s) {
  return !(s = typeof s === "function" ? s() : s) ? {} : s;
}
function resolveSources() {
  for (let i2 = 0, length2 = this.length; i2 < length2; ++i2) {
    const v = this[i2]();
    if (v !== void 0) return v;
  }
}
function mergeProps(...sources) {
  let proxy = false;
  for (let i2 = 0; i2 < sources.length; i2++) {
    const s = sources[i2];
    proxy = proxy || !!s && $PROXY in s;
    sources[i2] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
  }
  if (SUPPORTS_PROXY && proxy) {
    return new Proxy(
      {
        get(property) {
          for (let i2 = sources.length - 1; i2 >= 0; i2--) {
            const v = resolveSource(sources[i2])[property];
            if (v !== void 0) return v;
          }
        },
        has(property) {
          for (let i2 = sources.length - 1; i2 >= 0; i2--) {
            if (property in resolveSource(sources[i2])) return true;
          }
          return false;
        },
        keys() {
          const keys = [];
          for (let i2 = 0; i2 < sources.length; i2++)
            keys.push(...Object.keys(resolveSource(sources[i2])));
          return [...new Set(keys)];
        }
      },
      propTraps
    );
  }
  const sourcesMap = {};
  const defined = /* @__PURE__ */ Object.create(null);
  for (let i2 = sources.length - 1; i2 >= 0; i2--) {
    const source = sources[i2];
    if (!source) continue;
    const sourceKeys = Object.getOwnPropertyNames(source);
    for (let i3 = sourceKeys.length - 1; i3 >= 0; i3--) {
      const key = sourceKeys[i3];
      if (key === "__proto__" || key === "constructor") continue;
      const desc = Object.getOwnPropertyDescriptor(source, key);
      if (!defined[key]) {
        defined[key] = desc.get ? {
          enumerable: true,
          configurable: true,
          get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
        } : desc.value !== void 0 ? desc : void 0;
      } else {
        const sources2 = sourcesMap[key];
        if (sources2) {
          if (desc.get) sources2.push(desc.get.bind(source));
          else if (desc.value !== void 0) sources2.push(() => desc.value);
        }
      }
    }
  }
  const target = {};
  const definedKeys = Object.keys(defined);
  for (let i2 = definedKeys.length - 1; i2 >= 0; i2--) {
    const key = definedKeys[i2], desc = defined[key];
    if (desc && desc.get) Object.defineProperty(target, key, desc);
    else target[key] = desc ? desc.value : void 0;
  }
  return target;
}
function splitProps(props, ...keys) {
  if (SUPPORTS_PROXY && $PROXY in props) {
    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
    const res = keys.map((k) => {
      return new Proxy(
        {
          get(property) {
            return k.includes(property) ? props[property] : void 0;
          },
          has(property) {
            return k.includes(property) && property in props;
          },
          keys() {
            return k.filter((property) => property in props);
          }
        },
        propTraps
      );
    });
    res.push(
      new Proxy(
        {
          get(property) {
            return blocked.has(property) ? void 0 : props[property];
          },
          has(property) {
            return blocked.has(property) ? false : property in props;
          },
          keys() {
            return Object.keys(props).filter((k) => !blocked.has(k));
          }
        },
        propTraps
      )
    );
    return res;
  }
  const otherObject = {};
  const objects = keys.map(() => ({}));
  for (const propName of Object.getOwnPropertyNames(props)) {
    const desc = Object.getOwnPropertyDescriptor(props, propName);
    const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
    let blocked = false;
    let objectIndex = 0;
    for (const k of keys) {
      if (k.includes(propName)) {
        blocked = true;
        isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
      }
      ++objectIndex;
    }
    if (!blocked) {
      isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
    }
  }
  return [...objects, otherObject];
}
var narrowedError = (name) => `Attempting to access a stale value from <${name}> that could possibly be undefined. This may occur because you are reading the accessor returned from the component at a time where it has already been unmounted. We recommend cleaning up any stale timers or async, or reading from the initial condition.`;
function For(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return createMemo(
    mapArray(() => props.each, props.children, fallback || void 0),
    void 0,
    {
      name: "value"
    }
  );
}
function Show(props) {
  const keyed = props.keyed;
  const conditionValue = createMemo(() => props.when, void 0, {
    name: "condition value"
  });
  const condition = keyed ? conditionValue : createMemo(conditionValue, void 0, {
    equals: (a, b) => !a === !b,
    name: "condition"
  });
  return createMemo(
    () => {
      const c = condition();
      if (c) {
        const child = props.children;
        const fn = typeof child === "function" && child.length > 0;
        return fn ? untrack(
          () => child(
            keyed ? c : () => {
              if (!untrack(condition)) throw narrowedError("Show");
              return conditionValue();
            }
          )
        ) : child;
      }
      return props.fallback;
    },
    void 0,
    {
      name: "value"
    }
  );
}
function Switch(props) {
  const chs = children(() => props.children);
  const switchFunc = createMemo(() => {
    const ch = chs();
    const mps = Array.isArray(ch) ? ch : [ch];
    let func = () => void 0;
    for (let i2 = 0; i2 < mps.length; i2++) {
      const index = i2;
      const mp = mps[i2];
      const prevFunc = func;
      const conditionValue = createMemo(() => prevFunc() ? void 0 : mp.when, void 0, {
        name: "condition value"
      });
      const condition = mp.keyed ? conditionValue : createMemo(conditionValue, void 0, {
        equals: (a, b) => !a === !b,
        name: "condition"
      });
      func = () => prevFunc() || (condition() ? [index, conditionValue, mp] : void 0);
    }
    return func;
  });
  return createMemo(
    () => {
      const sel = switchFunc()();
      if (!sel) return props.fallback;
      const [index, conditionValue, mp] = sel;
      const child = mp.children;
      const fn = typeof child === "function" && child.length > 0;
      return fn ? untrack(
        () => child(
          mp.keyed ? conditionValue() : () => {
            var _a;
            if (((_a = untrack(switchFunc)()) == null ? void 0 : _a[0]) !== index) throw narrowedError("Match");
            return conditionValue();
          }
        )
      ) : child;
    },
    void 0,
    {
      name: "eval conditions"
    }
  );
}
function Match(props) {
  return props;
}
var SuspenseListContext = createContext();
var DEV = {
  hooks: DevHooks,
  writeSignal,
  registerGraph
};
if (globalThis) {
  if (!globalThis.Solid$$) globalThis.Solid$$ = true;
  else
    console.warn(
      "You appear to have multiple instances of Solid. This can lead to unexpected behavior."
    );
}

// node_modules/solid-js/web/dist/dev.js
var booleans = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected"
];
var Properties = /* @__PURE__ */ new Set([
  "className",
  "value",
  "readOnly",
  "noValidate",
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  ...booleans
]);
var ChildProperties = /* @__PURE__ */ new Set([
  "innerHTML",
  "textContent",
  "innerText",
  "children"
]);
var Aliases = Object.assign(/* @__PURE__ */ Object.create(null), {
  className: "class",
  htmlFor: "for"
});
var PropAliases = Object.assign(/* @__PURE__ */ Object.create(null), {
  class: "className",
  novalidate: {
    $: "noValidate",
    FORM: 1
  },
  formnovalidate: {
    $: "formNoValidate",
    BUTTON: 1,
    INPUT: 1
  },
  ismap: {
    $: "isMap",
    IMG: 1
  },
  nomodule: {
    $: "noModule",
    SCRIPT: 1
  },
  playsinline: {
    $: "playsInline",
    VIDEO: 1
  },
  readonly: {
    $: "readOnly",
    INPUT: 1,
    TEXTAREA: 1
  }
});
function getPropAlias(prop, tagName) {
  const a = PropAliases[prop];
  return typeof a === "object" ? a[tagName] ? a["$"] : void 0 : a;
}
var DelegatedEvents = /* @__PURE__ */ new Set([
  "beforeinput",
  "click",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
]);
var SVGElements = /* @__PURE__ */ new Set([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tref",
  "tspan",
  "use",
  "view",
  "vkern"
]);
var SVGNamespace = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
};
var memo = (fn) => createMemo(() => fn());
function reconcileArrays(parentNode, a, b) {
  let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map2 = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (a[aStart] === b[bStart]) {
      aStart++;
      bStart++;
      continue;
    }
    while (a[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    }
    if (aEnd === aStart) {
      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map2 || !map2.has(a[aStart])) a[aStart].remove();
        aStart++;
      }
    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
      const node = a[--aEnd].nextSibling;
      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
      parentNode.insertBefore(b[--bEnd], node);
      a[aEnd] = b[bEnd];
    } else {
      if (!map2) {
        map2 = /* @__PURE__ */ new Map();
        let i2 = bStart;
        while (i2 < bEnd) map2.set(b[i2], i2++);
      }
      const index = map2.get(a[aStart]);
      if (index != null) {
        if (bStart < index && index < bEnd) {
          let i2 = aStart, sequence = 1, t;
          while (++i2 < aEnd && i2 < bEnd) {
            if ((t = map2.get(a[i2])) == null || t !== index + sequence) break;
            sequence++;
          }
          if (sequence > index - bStart) {
            const node = a[aStart];
            while (bStart < index) parentNode.insertBefore(b[bStart++], node);
          } else parentNode.replaceChild(b[bStart++], a[aStart++]);
        } else aStart++;
      } else a[aStart++].remove();
    }
  }
}
var $$EVENTS = "_$DX_DELEGATE";
function render(code, element, init, options = {}) {
  if (!element) {
    throw new Error(
      "The `element` passed to `render(..., element)` doesn't exist. Make sure `element` exists in the document."
    );
  }
  let disposer;
  createRoot((dispose2) => {
    disposer = dispose2;
    element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);
  }, options.owner);
  return () => {
    disposer();
    element.textContent = "";
  };
}
function template(html, isImportNode, isSVG, isMathML) {
  let node;
  const create = () => {
    if (isHydrating())
      throw new Error(
        "Failed attempt to create new DOM elements during hydration. Check that the libraries you are using support hydration."
      );
    const t = isMathML ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
    t.innerHTML = html;
    return isSVG ? t.content.firstChild.firstChild : isMathML ? t.firstChild : t.content.firstChild;
  };
  const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);
  fn.cloneNode = fn;
  return fn;
}
function delegateEvents(eventNames, document2 = window.document) {
  const e = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
  for (let i2 = 0, l = eventNames.length; i2 < l; i2++) {
    const name = eventNames[i2];
    if (!e.has(name)) {
      e.add(name);
      document2.addEventListener(name, eventHandler);
    }
  }
}
function setAttribute(node, name, value2) {
  if (isHydrating(node)) return;
  if (value2 == null) node.removeAttribute(name);
  else node.setAttribute(name, value2);
}
function setAttributeNS(node, namespace, name, value2) {
  if (isHydrating(node)) return;
  if (value2 == null) node.removeAttributeNS(namespace, name);
  else node.setAttributeNS(namespace, name, value2);
}
function setBoolAttribute(node, name, value2) {
  if (isHydrating(node)) return;
  value2 ? node.setAttribute(name, "") : node.removeAttribute(name);
}
function className(node, value2) {
  if (isHydrating(node)) return;
  if (value2 == null) node.removeAttribute("class");
  else node.className = value2;
}
function addEventListener2(node, name, handler, delegate) {
  if (delegate) {
    if (Array.isArray(handler)) {
      node[`$$${name}`] = handler[0];
      node[`$$${name}Data`] = handler[1];
    } else node[`$$${name}`] = handler;
  } else if (Array.isArray(handler)) {
    const handlerFn = handler[0];
    node.addEventListener(name, handler[0] = (e) => handlerFn.call(node, handler[1], e));
  } else node.addEventListener(name, handler, typeof handler !== "function" && handler);
}
function classList(node, value2, prev2 = {}) {
  const classKeys = Object.keys(value2 || {}), prevKeys = Object.keys(prev2);
  let i2, len;
  for (i2 = 0, len = prevKeys.length; i2 < len; i2++) {
    const key = prevKeys[i2];
    if (!key || key === "undefined" || value2[key]) continue;
    toggleClassKey(node, key, false);
    delete prev2[key];
  }
  for (i2 = 0, len = classKeys.length; i2 < len; i2++) {
    const key = classKeys[i2], classValue = !!value2[key];
    if (!key || key === "undefined" || prev2[key] === classValue || !classValue) continue;
    toggleClassKey(node, key, true);
    prev2[key] = classValue;
  }
  return prev2;
}
function style(node, value2, prev2) {
  if (!value2) return prev2 ? setAttribute(node, "style") : value2;
  const nodeStyle = node.style;
  if (typeof value2 === "string") return nodeStyle.cssText = value2;
  typeof prev2 === "string" && (nodeStyle.cssText = prev2 = void 0);
  prev2 || (prev2 = {});
  value2 || (value2 = {});
  let v, s;
  for (s in prev2) {
    value2[s] == null && nodeStyle.removeProperty(s);
    delete prev2[s];
  }
  for (s in value2) {
    v = value2[s];
    if (v !== prev2[s]) {
      nodeStyle.setProperty(s, v);
      prev2[s] = v;
    }
  }
  return prev2;
}
function spread(node, props = {}, isSVG, skipChildren) {
  const prevProps = {};
  if (!skipChildren) {
    createRenderEffect(
      () => prevProps.children = insertExpression(node, props.children, prevProps.children)
    );
  }
  createRenderEffect(() => typeof props.ref === "function" && use(props.ref, node));
  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));
  return prevProps;
}
function use(fn, element, arg) {
  return untrack(() => fn(element, arg));
}
function insert(parent, accessor, marker, initial) {
  if (marker !== void 0 && !initial) initial = [];
  if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
  createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
  props || (props = {});
  for (const prop in prevProps) {
    if (!(prop in props)) {
      if (prop === "children") continue;
      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);
    }
  }
  for (const prop in props) {
    if (prop === "children") {
      if (!skipChildren) insertExpression(node, props.children);
      continue;
    }
    const value2 = props[prop];
    prevProps[prop] = assignProp(node, prop, value2, prevProps[prop], isSVG, skipRef, props);
  }
}
function getNextElement(template2) {
  let node, key, hydrating = isHydrating();
  if (!hydrating || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {
    if (hydrating) {
      sharedConfig.done = true;
      throw new Error(
        `Hydration Mismatch. Unable to find DOM nodes for hydration key: ${key}
${template2 ? template2().outerHTML : ""}`
      );
    }
    return template2();
  }
  if (sharedConfig.completed) sharedConfig.completed.add(node);
  sharedConfig.registry.delete(key);
  return node;
}
function isHydrating(node) {
  return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);
}
function toPropertyName(name) {
  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
}
function toggleClassKey(node, key, value2) {
  const classNames = key.trim().split(/\s+/);
  for (let i2 = 0, nameLen = classNames.length; i2 < nameLen; i2++)
    node.classList.toggle(classNames[i2], value2);
}
function assignProp(node, prop, value2, prev2, isSVG, skipRef, props) {
  let isCE, isProp, isChildProp, propAlias, forceProp;
  if (prop === "style") return style(node, value2, prev2);
  if (prop === "classList") return classList(node, value2, prev2);
  if (value2 === prev2) return prev2;
  if (prop === "ref") {
    if (!skipRef) value2(node);
  } else if (prop.slice(0, 3) === "on:") {
    const e = prop.slice(3);
    prev2 && node.removeEventListener(e, prev2, typeof prev2 !== "function" && prev2);
    value2 && node.addEventListener(e, value2, typeof value2 !== "function" && value2);
  } else if (prop.slice(0, 10) === "oncapture:") {
    const e = prop.slice(10);
    prev2 && node.removeEventListener(e, prev2, true);
    value2 && node.addEventListener(e, value2, true);
  } else if (prop.slice(0, 2) === "on") {
    const name = prop.slice(2).toLowerCase();
    const delegate = DelegatedEvents.has(name);
    if (!delegate && prev2) {
      const h = Array.isArray(prev2) ? prev2[0] : prev2;
      node.removeEventListener(name, h);
    }
    if (delegate || value2) {
      addEventListener2(node, name, value2, delegate);
      delegate && delegateEvents([name]);
    }
  } else if (prop.slice(0, 5) === "attr:") {
    setAttribute(node, prop.slice(5), value2);
  } else if (prop.slice(0, 5) === "bool:") {
    setBoolAttribute(node, prop.slice(5), value2);
  } else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-") || "is" in props)) {
    if (forceProp) {
      prop = prop.slice(5);
      isProp = true;
    } else if (isHydrating(node)) return value2;
    if (prop === "class" || prop === "className") className(node, value2);
    else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value2;
    else node[propAlias || prop] = value2;
  } else {
    const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
    if (ns) setAttributeNS(node, ns, prop, value2);
    else setAttribute(node, Aliases[prop] || prop, value2);
  }
  return value2;
}
function eventHandler(e) {
  if (sharedConfig.registry && sharedConfig.events) {
    if (sharedConfig.events.find(([el, ev]) => ev === e)) return;
  }
  let node = e.target;
  const key = `$$${e.type}`;
  const oriTarget = e.target;
  const oriCurrentTarget = e.currentTarget;
  const retarget = (value2) => Object.defineProperty(e, "target", {
    configurable: true,
    value: value2
  });
  const handleNode = () => {
    const handler = node[key];
    if (handler && !node.disabled) {
      const data2 = node[`${key}Data`];
      data2 !== void 0 ? handler.call(node, data2, e) : handler.call(node, e);
      if (e.cancelBubble) return;
    }
    node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e.target) && retarget(node.host);
    return true;
  };
  const walkUpTree = () => {
    while (handleNode() && (node = node._$host || node.parentNode || node.host)) ;
  };
  Object.defineProperty(e, "currentTarget", {
    configurable: true,
    get() {
      return node || document;
    }
  });
  if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;
  if (e.composedPath) {
    const path = e.composedPath();
    retarget(path[0]);
    for (let i2 = 0; i2 < path.length - 2; i2++) {
      node = path[i2];
      if (!handleNode()) break;
      if (node._$host) {
        node = node._$host;
        walkUpTree();
        break;
      }
      if (node.parentNode === oriCurrentTarget) {
        break;
      }
    }
  } else walkUpTree();
  retarget(oriTarget);
}
function insertExpression(parent, value2, current, marker, unwrapArray) {
  const hydrating = isHydrating(parent);
  if (hydrating) {
    !current && (current = [...parent.childNodes]);
    let cleaned = [];
    for (let i2 = 0; i2 < current.length; i2++) {
      const node = current[i2];
      if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
      else cleaned.push(node);
    }
    current = cleaned;
  }
  while (typeof current === "function") current = current();
  if (value2 === current) return current;
  const t = typeof value2, multi = marker !== void 0;
  parent = multi && current[0] && current[0].parentNode || parent;
  if (t === "string" || t === "number") {
    if (hydrating) return current;
    if (t === "number") {
      value2 = value2.toString();
      if (value2 === current) return current;
    }
    if (multi) {
      let node = current[0];
      if (node && node.nodeType === 3) {
        node.data !== value2 && (node.data = value2);
      } else node = document.createTextNode(value2);
      current = cleanChildren(parent, current, marker, node);
    } else {
      if (current !== "" && typeof current === "string") {
        current = parent.firstChild.data = value2;
      } else current = parent.textContent = value2;
    }
  } else if (value2 == null || t === "boolean") {
    if (hydrating) return current;
    current = cleanChildren(parent, current, marker);
  } else if (t === "function") {
    createRenderEffect(() => {
      let v = value2();
      while (typeof v === "function") v = v();
      current = insertExpression(parent, v, current, marker);
    });
    return () => current;
  } else if (Array.isArray(value2)) {
    const array = [];
    const currentArray = current && Array.isArray(current);
    if (normalizeIncomingArray(array, value2, current, unwrapArray)) {
      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));
      return () => current;
    }
    if (hydrating) {
      if (!array.length) return current;
      if (marker === void 0) return current = [...parent.childNodes];
      let node = array[0];
      if (node.parentNode !== parent) return current;
      const nodes = [node];
      while ((node = node.nextSibling) !== marker) nodes.push(node);
      return current = nodes;
    }
    if (array.length === 0) {
      current = cleanChildren(parent, current, marker);
      if (multi) return current;
    } else if (currentArray) {
      if (current.length === 0) {
        appendNodes(parent, array, marker);
      } else reconcileArrays(parent, current, array);
    } else {
      current && cleanChildren(parent);
      appendNodes(parent, array);
    }
    current = array;
  } else if (value2.nodeType) {
    if (hydrating && value2.parentNode) return current = multi ? [value2] : value2;
    if (Array.isArray(current)) {
      if (multi) return current = cleanChildren(parent, current, marker, value2);
      cleanChildren(parent, current, null, value2);
    } else if (current == null || current === "" || !parent.firstChild) {
      parent.appendChild(value2);
    } else parent.replaceChild(value2, parent.firstChild);
    current = value2;
  } else console.warn(`Unrecognized value. Skipped inserting`, value2);
  return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap2) {
  let dynamic = false;
  for (let i2 = 0, len = array.length; i2 < len; i2++) {
    let item = array[i2], prev2 = current && current[normalized.length], t;
    if (item == null || item === true || item === false) ;
    else if ((t = typeof item) === "object" && item.nodeType) {
      normalized.push(item);
    } else if (Array.isArray(item)) {
      dynamic = normalizeIncomingArray(normalized, item, prev2) || dynamic;
    } else if (t === "function") {
      if (unwrap2) {
        while (typeof item === "function") item = item();
        dynamic = normalizeIncomingArray(
          normalized,
          Array.isArray(item) ? item : [item],
          Array.isArray(prev2) ? prev2 : [prev2]
        ) || dynamic;
      } else {
        normalized.push(item);
        dynamic = true;
      }
    } else {
      const value2 = String(item);
      if (prev2 && prev2.nodeType === 3 && prev2.data === value2) normalized.push(prev2);
      else normalized.push(document.createTextNode(value2));
    }
  }
  return dynamic;
}
function appendNodes(parent, array, marker = null) {
  for (let i2 = 0, len = array.length; i2 < len; i2++) parent.insertBefore(array[i2], marker);
}
function cleanChildren(parent, current, marker, replacement) {
  if (marker === void 0) return parent.textContent = "";
  const node = replacement || document.createTextNode("");
  if (current.length) {
    let inserted = false;
    for (let i2 = current.length - 1; i2 >= 0; i2--) {
      const el = current[i2];
      if (node !== el) {
        const isParent = el.parentNode === parent;
        if (!inserted && !i2)
          isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
        else isParent && el.remove();
      } else inserted = true;
    }
  } else parent.insertBefore(node, marker);
  return [node];
}
function getHydrationKey() {
  return sharedConfig.getNextContextId();
}
var RequestContext = Symbol();
var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
function createElement(tagName, isSVG = false) {
  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);
}
function Portal(props) {
  const { useShadow } = props, marker = document.createTextNode(""), mount = () => props.mount || document.body, owner = getOwner();
  let content;
  let hydrating = !!sharedConfig.context;
  createEffect(
    () => {
      if (hydrating) getOwner().user = hydrating = false;
      content || (content = runWithOwner(owner, () => createMemo(() => props.children)));
      const el = mount();
      if (el instanceof HTMLHeadElement) {
        const [clean, setClean] = createSignal(false);
        const cleanup = () => setClean(true);
        createRoot((dispose2) => insert(el, () => !clean() ? content() : dispose2(), null));
        onCleanup(cleanup);
      } else {
        const container = createElement(props.isSVG ? "g" : "div", props.isSVG), renderRoot = useShadow && container.attachShadow ? container.attachShadow({
          mode: "open"
        }) : container;
        Object.defineProperty(container, "_$host", {
          get() {
            return marker.parentNode;
          },
          configurable: true
        });
        insert(renderRoot, content);
        el.appendChild(container);
        props.ref && props.ref(container);
        onCleanup(() => el.removeChild(container));
      }
    },
    void 0,
    {
      render: !hydrating
    }
  );
  return marker;
}
function createDynamic(component, props) {
  const cached = createMemo(component);
  return createMemo(() => {
    const component2 = cached();
    switch (typeof component2) {
      case "function":
        Object.assign(component2, {
          [$DEVCOMP]: true
        });
        return untrack(() => component2(props));
      case "string":
        const isSvg = SVGElements.has(component2);
        const el = sharedConfig.context ? getNextElement() : createElement(component2, isSvg);
        spread(el, props, isSvg);
        return el;
    }
  });
}
function Dynamic(props) {
  const [, others] = splitProps(props, ["component"]);
  return createDynamic(() => props.component, others);
}

// node_modules/solid-js/store/dist/dev.js
var $RAW = Symbol("store-raw");
var $NODE = Symbol("store-node");
var $HAS = Symbol("store-has");
var $SELF = Symbol("store-self");
var DevHooks2 = {
  onStoreNodeUpdate: null
};
function wrap$1(value2) {
  let p = value2[$PROXY];
  if (!p) {
    Object.defineProperty(value2, $PROXY, {
      value: p = new Proxy(value2, proxyTraps$1)
    });
    if (!Array.isArray(value2)) {
      const keys = Object.keys(value2), desc = Object.getOwnPropertyDescriptors(value2);
      for (let i2 = 0, l = keys.length; i2 < l; i2++) {
        const prop = keys[i2];
        if (desc[prop].get) {
          Object.defineProperty(value2, prop, {
            enumerable: desc[prop].enumerable,
            get: desc[prop].get.bind(p)
          });
        }
      }
    }
  }
  return p;
}
function isWrappable(obj) {
  let proto;
  return obj != null && typeof obj === "object" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));
}
function unwrap(item, set = /* @__PURE__ */ new Set()) {
  let result, unwrapped, v, prop;
  if (result = item != null && item[$RAW]) return result;
  if (!isWrappable(item) || set.has(item)) return item;
  if (Array.isArray(item)) {
    if (Object.isFrozen(item)) item = item.slice(0);
    else set.add(item);
    for (let i2 = 0, l = item.length; i2 < l; i2++) {
      v = item[i2];
      if ((unwrapped = unwrap(v, set)) !== v) item[i2] = unwrapped;
    }
  } else {
    if (Object.isFrozen(item)) item = Object.assign({}, item);
    else set.add(item);
    const keys = Object.keys(item), desc = Object.getOwnPropertyDescriptors(item);
    for (let i2 = 0, l = keys.length; i2 < l; i2++) {
      prop = keys[i2];
      if (desc[prop].get) continue;
      v = item[prop];
      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;
    }
  }
  return item;
}
function getNodes(target, symbol) {
  let nodes = target[symbol];
  if (!nodes)
    Object.defineProperty(target, symbol, {
      value: nodes = /* @__PURE__ */ Object.create(null)
    });
  return nodes;
}
function getNode(nodes, property, value2) {
  if (nodes[property]) return nodes[property];
  const [s, set] = createSignal(value2, {
    equals: false,
    internal: true
  });
  s.$ = set;
  return nodes[property] = s;
}
function proxyDescriptor$1(target, property) {
  const desc = Reflect.getOwnPropertyDescriptor(target, property);
  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)
    return desc;
  delete desc.value;
  delete desc.writable;
  desc.get = () => target[$PROXY][property];
  return desc;
}
function trackSelf(target) {
  getListener() && getNode(getNodes(target, $NODE), $SELF)();
}
function ownKeys(target) {
  trackSelf(target);
  return Reflect.ownKeys(target);
}
var proxyTraps$1 = {
  get(target, property, receiver) {
    if (property === $RAW) return target;
    if (property === $PROXY) return receiver;
    if (property === $TRACK) {
      trackSelf(target);
      return receiver;
    }
    const nodes = getNodes(target, $NODE);
    const tracked = nodes[property];
    let value2 = tracked ? tracked() : target[property];
    if (property === $NODE || property === $HAS || property === "__proto__") return value2;
    if (!tracked) {
      const desc = Object.getOwnPropertyDescriptor(target, property);
      if (getListener() && (typeof value2 !== "function" || target.hasOwnProperty(property)) && !(desc && desc.get))
        value2 = getNode(nodes, property, value2)();
    }
    return isWrappable(value2) ? wrap$1(value2) : value2;
  },
  has(target, property) {
    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === "__proto__")
      return true;
    getListener() && getNode(getNodes(target, $HAS), property)();
    return property in target;
  },
  set() {
    console.warn("Cannot mutate a Store directly");
    return true;
  },
  deleteProperty() {
    console.warn("Cannot mutate a Store directly");
    return true;
  },
  ownKeys,
  getOwnPropertyDescriptor: proxyDescriptor$1
};
function setProperty(state, property, value2, deleting = false) {
  if (!deleting && state[property] === value2) return;
  const prev2 = state[property], len = state.length;
  DevHooks2.onStoreNodeUpdate && DevHooks2.onStoreNodeUpdate(state, property, value2, prev2);
  if (value2 === void 0) {
    delete state[property];
    if (state[$HAS] && state[$HAS][property] && prev2 !== void 0) state[$HAS][property].$();
  } else {
    state[property] = value2;
    if (state[$HAS] && state[$HAS][property] && prev2 === void 0) state[$HAS][property].$();
  }
  let nodes = getNodes(state, $NODE), node;
  if (node = getNode(nodes, property, prev2)) node.$(() => value2);
  if (Array.isArray(state) && state.length !== len) {
    for (let i2 = state.length; i2 < len; i2++) (node = nodes[i2]) && node.$();
    (node = getNode(nodes, "length", len)) && node.$(state.length);
  }
  (node = nodes[$SELF]) && node.$();
}
function mergeStoreNode(state, value2) {
  const keys = Object.keys(value2);
  for (let i2 = 0; i2 < keys.length; i2 += 1) {
    const key = keys[i2];
    setProperty(state, key, value2[key]);
  }
}
function updateArray(current, next) {
  if (typeof next === "function") next = next(current);
  next = unwrap(next);
  if (Array.isArray(next)) {
    if (current === next) return;
    let i2 = 0, len = next.length;
    for (; i2 < len; i2++) {
      const value2 = next[i2];
      if (current[i2] !== value2) setProperty(current, i2, value2);
    }
    setProperty(current, "length", len);
  } else mergeStoreNode(current, next);
}
function updatePath(current, path, traversed = []) {
  let part, prev2 = current;
  if (path.length > 1) {
    part = path.shift();
    const partType = typeof part, isArray = Array.isArray(current);
    if (Array.isArray(part)) {
      for (let i2 = 0; i2 < part.length; i2++) {
        updatePath(current, [part[i2]].concat(path), traversed);
      }
      return;
    } else if (isArray && partType === "function") {
      for (let i2 = 0; i2 < current.length; i2++) {
        if (part(current[i2], i2)) updatePath(current, [i2].concat(path), traversed);
      }
      return;
    } else if (isArray && partType === "object") {
      const { from = 0, to = current.length - 1, by = 1 } = part;
      for (let i2 = from; i2 <= to; i2 += by) {
        updatePath(current, [i2].concat(path), traversed);
      }
      return;
    } else if (path.length > 1) {
      updatePath(current[part], path, [part].concat(traversed));
      return;
    }
    prev2 = current[part];
    traversed = [part].concat(traversed);
  }
  let value2 = path[0];
  if (typeof value2 === "function") {
    value2 = value2(prev2, traversed);
    if (value2 === prev2) return;
  }
  if (part === void 0 && value2 == void 0) return;
  value2 = unwrap(value2);
  if (part === void 0 || isWrappable(prev2) && isWrappable(value2) && !Array.isArray(value2)) {
    mergeStoreNode(prev2, value2);
  } else setProperty(current, part, value2);
}
function createStore(...[store, options]) {
  const unwrappedStore = unwrap(store || {});
  const isArray = Array.isArray(unwrappedStore);
  if (typeof unwrappedStore !== "object" && typeof unwrappedStore !== "function")
    throw new Error(
      `Unexpected type ${typeof unwrappedStore} received when initializing 'createStore'. Expected an object.`
    );
  const wrappedStore = wrap$1(unwrappedStore);
  DEV.registerGraph({
    value: unwrappedStore,
    name: options && options.name
  });
  function setStore(...args) {
    batch(() => {
      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);
    });
  }
  return [wrappedStore, setStore];
}
var $ROOT = Symbol("store-root");

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// node_modules/tailwind-merge/dist/bundle-mjs.mjs
var CLASS_PART_SEPARATOR = "-";
var createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className2) => {
    const classParts = className2.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className2);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
var getGroupRecursive = (classParts, classPartObject) => {
  var _a;
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return (_a = classPartObject.validators.find(({
    validator
  }) => validator(classRest))) == null ? void 0 : _a.classGroupId;
};
var arbitraryPropertyRegex = /^\[(.+)\]$/;
var getGroupIdForArbitraryProperty = (className2) => {
  if (arbitraryPropertyRegex.test(className2)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className2)[1];
    const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
var createClassMap = (config) => {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
};
var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
var getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
var isThemeGetter = (func) => func.isThemeGetter;
var getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value2]) => [prefix + key, value2]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
};
var createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache2 = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value2) => {
    cache2.set(key, value2);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache2;
      cache2 = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value2 = cache2.get(key);
      if (value2 !== void 0) {
        return value2;
      }
      if ((value2 = previousCache.get(key)) !== void 0) {
        update(key, value2);
        return value2;
      }
    },
    set(key, value2) {
      if (cache2.has(key)) {
        cache2.set(key, value2);
      } else {
        update(key, value2);
      }
    }
  };
};
var IMPORTANT_MODIFIER = "!";
var createParseClassName = (config) => {
  const {
    separator,
    experimentalParseClassName
  } = config;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  const parseClassName = (className2) => {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index = 0; index < className2.length; index++) {
      let currentCharacter = className2[index];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className2.slice(index, index + separatorLength) === separator)) {
          modifiers.push(className2.slice(modifierStart, index));
          modifierStart = index + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className2 : className2.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (experimentalParseClassName) {
    return (className2) => experimentalParseClassName({
      className: className2,
      parseClassName
    });
  }
  return parseClassName;
};
var sortModifiers = (modifiers) => {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
};
var createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  ...createClassGroupUtils(config)
});
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = (classList2, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList2.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index = classNames.length - 1; index >= 0; index -= 1) {
    const originalClassName = classNames[index];
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i2 = 0; i2 < conflictGroups.length; ++i2) {
      const group = conflictGroups[i2];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index < arguments.length) {
    if (argument = arguments[index++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
var toValue = (mix2) => {
  if (typeof mix2 === "string") {
    return mix2;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix2.length; k++) {
    if (mix2[k]) {
      if (resolvedValue = toValue(mix2[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList2) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList2);
  }
  function tailwindMerge(classList2) {
    const cachedResult = cacheGet(classList2);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList2, configUtils);
    cacheSet(classList2, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
var fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
var fractionRegex = /^\d+\/\d+$/;
var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isLength = (value2) => isNumber(value2) || stringLengths.has(value2) || fractionRegex.test(value2);
var isArbitraryLength = (value2) => getIsArbitraryValue(value2, "length", isLengthOnly);
var isNumber = (value2) => Boolean(value2) && !Number.isNaN(Number(value2));
var isArbitraryNumber = (value2) => getIsArbitraryValue(value2, "number", isNumber);
var isInteger = (value2) => Boolean(value2) && Number.isInteger(Number(value2));
var isPercent = (value2) => value2.endsWith("%") && isNumber(value2.slice(0, -1));
var isArbitraryValue = (value2) => arbitraryValueRegex.test(value2);
var isTshirtSize = (value2) => tshirtUnitRegex.test(value2);
var sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
var isArbitrarySize = (value2) => getIsArbitraryValue(value2, sizeLabels, isNever);
var isArbitraryPosition = (value2) => getIsArbitraryValue(value2, "position", isNever);
var imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
var isArbitraryImage = (value2) => getIsArbitraryValue(value2, imageLabels, isImage);
var isArbitraryShadow = (value2) => getIsArbitraryValue(value2, "", isShadow);
var isAny = () => true;
var getIsArbitraryValue = (value2, label, testValue) => {
  const result = arbitraryValueRegex.exec(value2);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
var isLengthOnly = (value2) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value2) && !colorFunctionRegex.test(value2)
);
var isNever = () => false;
var isShadow = (value2) => shadowRegex.test(value2);
var isImage = (value2) => imageRegex.test(value2);
var validators = Object.defineProperty({
  __proto__: null,
  isAny,
  isArbitraryImage,
  isArbitraryLength,
  isArbitraryNumber,
  isArbitraryPosition,
  isArbitraryShadow,
  isArbitrarySize,
  isArbitraryValue,
  isInteger,
  isLength,
  isNumber,
  isPercent,
  isTshirtSize
}, Symbol.toStringTag, {
  value: "Module"
});
var getDefaultConfig = () => {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumberAndArbitrary(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumberAndArbitrary(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumberAndArbitrary(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumberAndArbitrary(),
      scale: getNumberAndArbitrary(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [borderColor]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
var mergeConfigs = (baseConfig, {
  cacheSize,
  prefix,
  separator,
  experimentalParseClassName,
  extend = {},
  override = {}
}) => {
  overrideProperty(baseConfig, "cacheSize", cacheSize);
  overrideProperty(baseConfig, "prefix", prefix);
  overrideProperty(baseConfig, "separator", separator);
  overrideProperty(baseConfig, "experimentalParseClassName", experimentalParseClassName);
  for (const configKey in override) {
    overrideConfigProperties(baseConfig[configKey], override[configKey]);
  }
  for (const key in extend) {
    mergeConfigProperties(baseConfig[key], extend[key]);
  }
  return baseConfig;
};
var overrideProperty = (baseObject, overrideKey, overrideValue) => {
  if (overrideValue !== void 0) {
    baseObject[overrideKey] = overrideValue;
  }
};
var overrideConfigProperties = (baseObject, overrideObject) => {
  if (overrideObject) {
    for (const key in overrideObject) {
      overrideProperty(baseObject, key, overrideObject[key]);
    }
  }
};
var mergeConfigProperties = (baseObject, mergeObject) => {
  if (mergeObject) {
    for (const key in mergeObject) {
      const mergeValue = mergeObject[key];
      if (mergeValue !== void 0) {
        baseObject[key] = (baseObject[key] || []).concat(mergeValue);
      }
    }
  }
};
var extendTailwindMerge = (configExtension, ...createConfig) => typeof configExtension === "function" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
var twMerge = createTailwindMerge(getDefaultConfig);

// node_modules/class-variance-authority/dist/index.mjs
var falsyToString = (value2) => typeof value2 === "boolean" ? `${value2}` : value2 === 0 ? "0" : value2;
var cx = clsx;
var cva = (base, config) => (props) => {
  var _config_compoundVariants;
  if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  const { variants, defaultVariants } = config;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props === null || props === void 0 ? void 0 : props[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
    if (variantProp === null) return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
    let [key, value2] = param;
    if (value2 === void 0) {
      return acc;
    }
    acc[key] = value2;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key, value2] = param2;
      return Array.isArray(value2) ? value2.includes({
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key]) : {
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key] === value2;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value2, end) {
  return max(start, min(value2, end));
}
function evaluate(value2, param) {
  return typeof value2 === "function" ? value2(param) : value2;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data2
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          var _overflowsData$;
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof Node || value2 instanceof getWindow(value2).Node;
}
function isElement(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof Element || value2 instanceof getWindow(value2).Element;
}
function isHTMLElement(value2) {
  if (!hasWindow()) {
    return false;
  }
  return value2 instanceof HTMLElement || value2 instanceof getWindow(value2).HTMLElement;
}
function isShadowRoot(value2) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value2 instanceof ShadowRoot || value2 instanceof getWindow(value2).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value2) => css[value2] ? css[value2] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value2) => (css.willChange || "").includes(value2)) || ["paint", "layout", "strict", "content"].some((value2) => (css.contain || "").includes(value2));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll2, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll2.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll2.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll2, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll2.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll2.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll2 = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll2.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll2.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll2) : createCoords(0);
  const x = rect.left + scroll2.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll2.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data2) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data2.floating);
  return {
    reference: getRectRelativeToOffsetParent(data2.reference, await getOffsetParentFn(data2.floating), data2.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/solid-floating-ui/dist/esm/development/index.mjs
function useFloating(reference, floating, options) {
  const placement = () => {
    var _a;
    return (_a = options == null ? void 0 : options.placement) != null ? _a : "bottom";
  };
  const strategy = () => {
    var _a;
    return (_a = options == null ? void 0 : options.strategy) != null ? _a : "absolute";
  };
  const [data2, setData] = createSignal({
    x: null,
    y: null,
    placement: placement(),
    strategy: strategy(),
    middlewareData: {}
  });
  const [error, setError] = createSignal();
  createEffect(() => {
    const currentError = error();
    if (currentError) {
      throw currentError.value;
    }
  });
  const version = createMemo(() => {
    reference();
    floating();
    return {};
  });
  function update() {
    const currentReference = reference();
    const currentFloating = floating();
    if (currentReference && currentFloating) {
      const capturedVersion = version();
      computePosition2(currentReference, currentFloating, {
        middleware: options == null ? void 0 : options.middleware,
        placement: placement(),
        strategy: strategy()
      }).then(
        (currentData) => {
          if (capturedVersion === version()) {
            setData(currentData);
          }
        },
        (err) => {
          setError(err);
        }
      );
    }
  }
  createEffect(() => {
    const currentReference = reference();
    const currentFloating = floating();
    options == null ? void 0 : options.middleware;
    placement();
    strategy();
    if (currentReference && currentFloating) {
      if (options == null ? void 0 : options.whileElementsMounted) {
        const cleanup = options.whileElementsMounted(
          currentReference,
          currentFloating,
          update
        );
        if (cleanup) {
          onCleanup(cleanup);
        }
      } else {
        update();
      }
    }
  });
  return {
    get x() {
      return data2().x;
    },
    get y() {
      return data2().y;
    },
    get placement() {
      return data2().placement;
    },
    get strategy() {
      return data2().strategy;
    },
    get middlewareData() {
      return data2().middlewareData;
    },
    update
  };
}

// node_modules/@solid-primitives/props/dist/combineProps.js
var extractCSSregex = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
function stringStyleToObject(style3) {
  const object = {};
  let match;
  while (match = extractCSSregex.exec(style3)) {
    object[match[1]] = match[2];
  }
  return object;
}
function combineStyle(a, b) {
  if (typeof a === "string") {
    if (typeof b === "string")
      return `${a};${b}`;
    a = stringStyleToObject(a);
  } else if (typeof b === "string") {
    b = stringStyleToObject(b);
  }
  return { ...a, ...b };
}

// node_modules/@motionone/utils/dist/array.es.js
function addUniqueItem(array, item) {
  array.indexOf(item) === -1 && array.push(item);
}
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  index > -1 && arr.splice(index, 1);
}

// node_modules/@motionone/utils/dist/clamp.es.js
var clamp2 = (min2, max2, v) => Math.min(Math.max(v, min2), max2);

// node_modules/@motionone/utils/dist/defaults.es.js
var defaults = {
  duration: 0.3,
  delay: 0,
  endDelay: 0,
  repeat: 0,
  easing: "ease"
};

// node_modules/@motionone/utils/dist/is-number.es.js
var isNumber2 = (value2) => typeof value2 === "number";

// node_modules/@motionone/utils/dist/is-easing-list.es.js
var isEasingList = (easing) => Array.isArray(easing) && !isNumber2(easing[0]);

// node_modules/@motionone/utils/dist/wrap.es.js
var wrap = (min2, max2, v) => {
  const rangeSize = max2 - min2;
  return ((v - min2) % rangeSize + rangeSize) % rangeSize + min2;
};

// node_modules/@motionone/utils/dist/easing.es.js
function getEasingForSegment(easing, i2) {
  return isEasingList(easing) ? easing[wrap(0, easing.length, i2)] : easing;
}

// node_modules/@motionone/utils/dist/mix.es.js
var mix = (min2, max2, progress2) => -progress2 * min2 + progress2 * max2 + min2;

// node_modules/@motionone/utils/dist/noop.es.js
var noop = () => {
};
var noopReturn = (v) => v;

// node_modules/@motionone/utils/dist/progress.es.js
var progress = (min2, max2, value2) => max2 - min2 === 0 ? 1 : (value2 - min2) / (max2 - min2);

// node_modules/@motionone/utils/dist/offset.es.js
function fillOffset(offset3, remaining) {
  const min2 = offset3[offset3.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = progress(0, remaining, i2);
    offset3.push(mix(min2, 1, offsetProgress));
  }
}
function defaultOffset(length2) {
  const offset3 = [0];
  fillOffset(offset3, length2 - 1);
  return offset3;
}

// node_modules/@motionone/utils/dist/interpolate.es.js
function interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {
  const length2 = output.length;
  const remainder = length2 - input.length;
  remainder > 0 && fillOffset(input, remainder);
  return (t) => {
    let i2 = 0;
    for (; i2 < length2 - 2; i2++) {
      if (t < input[i2 + 1])
        break;
    }
    let progressInRange = clamp2(0, 1, progress(input[i2], input[i2 + 1], t));
    const segmentEasing = getEasingForSegment(easing, i2);
    progressInRange = segmentEasing(progressInRange);
    return mix(output[i2], output[i2 + 1], progressInRange);
  };
}

// node_modules/@motionone/utils/dist/is-cubic-bezier.es.js
var isCubicBezier = (easing) => Array.isArray(easing) && isNumber2(easing[0]);

// node_modules/@motionone/utils/dist/is-easing-generator.es.js
var isEasingGenerator = (easing) => typeof easing === "object" && Boolean(easing.createAnimation);

// node_modules/@motionone/utils/dist/is-function.es.js
var isFunction = (value2) => typeof value2 === "function";

// node_modules/@motionone/utils/dist/is-string.es.js
var isString = (value2) => typeof value2 === "string";

// node_modules/@motionone/utils/dist/time.es.js
var time = {
  ms: (seconds) => seconds * 1e3,
  s: (milliseconds) => milliseconds / 1e3
};

// node_modules/@motionone/utils/dist/velocity.es.js
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}

// node_modules/@motionone/easing/dist/cubic-bezier.es.js
var calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
var subdivisionPrecision = 1e-7;
var subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i2 = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noopReturn;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}

// node_modules/@motionone/easing/dist/steps.es.js
var steps = (steps2, direction = "end") => (progress2) => {
  progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
  const expanded = progress2 * steps2;
  const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
  return clamp2(0, 1, rounded / steps2);
};

// node_modules/@motionone/animation/dist/utils/easing.es.js
var namedEasings = {
  ease: cubicBezier(0.25, 0.1, 0.25, 1),
  "ease-in": cubicBezier(0.42, 0, 1, 1),
  "ease-in-out": cubicBezier(0.42, 0, 0.58, 1),
  "ease-out": cubicBezier(0, 0, 0.58, 1)
};
var functionArgsRegex = /\((.*?)\)/;
function getEasingFunction(definition) {
  if (isFunction(definition))
    return definition;
  if (isCubicBezier(definition))
    return cubicBezier(...definition);
  const namedEasing = namedEasings[definition];
  if (namedEasing)
    return namedEasing;
  if (definition.startsWith("steps")) {
    const args = functionArgsRegex.exec(definition);
    if (args) {
      const argsArray = args[1].split(",");
      return steps(parseFloat(argsArray[0]), argsArray[1].trim());
    }
  }
  return noopReturn;
}

// node_modules/@motionone/animation/dist/Animation.es.js
var Animation = class {
  constructor(output, keyframes = [0, 1], { easing, duration: initialDuration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset: offset3, direction = "normal", autoplay = true } = {}) {
    this.startTime = null;
    this.rate = 1;
    this.t = 0;
    this.cancelTimestamp = null;
    this.easing = noopReturn;
    this.duration = 0;
    this.totalDuration = 0;
    this.repeat = 0;
    this.playState = "idle";
    this.finished = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
    easing = easing || defaults.easing;
    if (isEasingGenerator(easing)) {
      const custom = easing.createAnimation(keyframes);
      easing = custom.easing;
      keyframes = custom.keyframes || keyframes;
      initialDuration = custom.duration || initialDuration;
    }
    this.repeat = repeat;
    this.easing = isEasingList(easing) ? noopReturn : getEasingFunction(easing);
    this.updateDuration(initialDuration);
    const interpolate$1 = interpolate(keyframes, offset3, isEasingList(easing) ? easing.map(getEasingFunction) : noopReturn);
    this.tick = (timestamp) => {
      var _a;
      delay = delay;
      let t = 0;
      if (this.pauseTime !== void 0) {
        t = this.pauseTime;
      } else {
        t = (timestamp - this.startTime) * this.rate;
      }
      this.t = t;
      t /= 1e3;
      t = Math.max(t - delay, 0);
      if (this.playState === "finished" && this.pauseTime === void 0) {
        t = this.totalDuration;
      }
      const progress2 = t / this.duration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      const iterationIsOdd = currentIteration % 2;
      if (direction === "reverse" || direction === "alternate" && iterationIsOdd || direction === "alternate-reverse" && !iterationIsOdd) {
        iterationProgress = 1 - iterationProgress;
      }
      const p = t >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);
      const latest = interpolate$1(this.easing(p));
      output(latest);
      const isAnimationFinished = this.pauseTime === void 0 && (this.playState === "finished" || t >= this.totalDuration + endDelay);
      if (isAnimationFinished) {
        this.playState = "finished";
        (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);
      } else if (this.playState !== "idle") {
        this.frameRequestId = requestAnimationFrame(this.tick);
      }
    };
    if (autoplay)
      this.play();
  }
  play() {
    const now = performance.now();
    this.playState = "running";
    if (this.pauseTime !== void 0) {
      this.startTime = now - this.pauseTime;
    } else if (!this.startTime) {
      this.startTime = now;
    }
    this.cancelTimestamp = this.startTime;
    this.pauseTime = void 0;
    this.frameRequestId = requestAnimationFrame(this.tick);
  }
  pause() {
    this.playState = "paused";
    this.pauseTime = this.t;
  }
  finish() {
    this.playState = "finished";
    this.tick(0);
  }
  stop() {
    var _a;
    this.playState = "idle";
    if (this.frameRequestId !== void 0) {
      cancelAnimationFrame(this.frameRequestId);
    }
    (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);
  }
  cancel() {
    this.stop();
    this.tick(this.cancelTimestamp);
  }
  reverse() {
    this.rate *= -1;
  }
  commitStyles() {
  }
  updateDuration(duration) {
    this.duration = duration;
    this.totalDuration = duration * (this.repeat + 1);
  }
  get currentTime() {
    return this.t;
  }
  set currentTime(t) {
    if (this.pauseTime !== void 0 || this.rate === 0) {
      this.pauseTime = t;
    } else {
      this.startTime = performance.now() - t / this.rate;
    }
  }
  get playbackRate() {
    return this.rate;
  }
  set playbackRate(rate) {
    this.rate = rate;
  }
};

// node_modules/hey-listen/dist/hey-listen.es.js
var warning = function() {
};
var invariant = function() {
};
if (true) {
  warning = function(check, message) {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  };
  invariant = function(check, message) {
    if (!check) {
      throw new Error(message);
    }
  };
}

// node_modules/@motionone/types/dist/MotionValue.es.js
var MotionValue = class {
  setAnimation(animation) {
    this.animation = animation;
    animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => {
    });
  }
  clearAnimation() {
    this.animation = this.generator = void 0;
  }
};

// node_modules/@motionone/dom/dist/animate/data.es.js
var data = /* @__PURE__ */ new WeakMap();
function getAnimationData(element) {
  if (!data.has(element)) {
    data.set(element, {
      transforms: [],
      values: /* @__PURE__ */ new Map()
    });
  }
  return data.get(element);
}
function getMotionValue(motionValues, name) {
  if (!motionValues.has(name)) {
    motionValues.set(name, new MotionValue());
  }
  return motionValues.get(name);
}

// node_modules/@motionone/dom/dist/animate/utils/transforms.es.js
var axes = ["", "X", "Y", "Z"];
var order = ["translate", "scale", "rotate", "skew"];
var transformAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ"
};
var rotation = {
  syntax: "<angle>",
  initialValue: "0deg",
  toDefaultUnit: (v) => v + "deg"
};
var baseTransformProperties = {
  translate: {
    syntax: "<length-percentage>",
    initialValue: "0px",
    toDefaultUnit: (v) => v + "px"
  },
  rotate: rotation,
  scale: {
    syntax: "<number>",
    initialValue: 1,
    toDefaultUnit: noopReturn
  },
  skew: rotation
};
var transformDefinitions = /* @__PURE__ */ new Map();
var asTransformCssVar = (name) => `--motion-${name}`;
var transforms = ["x", "y", "z"];
order.forEach((name) => {
  axes.forEach((axis) => {
    transforms.push(name + axis);
    transformDefinitions.set(asTransformCssVar(name + axis), baseTransformProperties[name]);
  });
});
var compareTransformOrder = (a, b) => transforms.indexOf(a) - transforms.indexOf(b);
var transformLookup = new Set(transforms);
var isTransform = (name) => transformLookup.has(name);
var addTransformToElement = (element, name) => {
  if (transformAlias[name])
    name = transformAlias[name];
  const { transforms: transforms2 } = getAnimationData(element);
  addUniqueItem(transforms2, name);
  element.style.transform = buildTransformTemplate(transforms2);
};
var buildTransformTemplate = (transforms2) => transforms2.sort(compareTransformOrder).reduce(transformListToString, "").trim();
var transformListToString = (template2, name) => `${template2} ${name}(var(${asTransformCssVar(name)}))`;

// node_modules/@motionone/dom/dist/animate/utils/css-var.es.js
var isCssVar = (name) => name.startsWith("--");
var registeredProperties = /* @__PURE__ */ new Set();
function registerCssVariable(name) {
  if (registeredProperties.has(name))
    return;
  registeredProperties.add(name);
  try {
    const { syntax, initialValue } = transformDefinitions.has(name) ? transformDefinitions.get(name) : {};
    CSS.registerProperty({
      name,
      inherits: false,
      syntax,
      initialValue
    });
  } catch (e) {
  }
}

// node_modules/@motionone/dom/dist/animate/utils/feature-detection.es.js
var testAnimation = (keyframes, options) => document.createElement("div").animate(keyframes, options);
var featureTests = {
  cssRegisterProperty: () => typeof CSS !== "undefined" && Object.hasOwnProperty.call(CSS, "registerProperty"),
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate"),
  partialKeyframes: () => {
    try {
      testAnimation({ opacity: [1] });
    } catch (e) {
      return false;
    }
    return true;
  },
  finished: () => Boolean(testAnimation({ opacity: [0, 1] }, { duration: 1e-3 }).finished),
  linearEasing: () => {
    try {
      testAnimation({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch (e) {
      return false;
    }
    return true;
  }
};
var results = {};
var supports = {};
for (const key in featureTests) {
  supports[key] = () => {
    if (results[key] === void 0)
      results[key] = featureTests[key]();
    return results[key];
  };
}

// node_modules/@motionone/dom/dist/animate/utils/easing.es.js
var resolution = 0.015;
var generateLinearEasingPoints = (easing, duration) => {
  let points = "";
  const numPoints = Math.round(duration / resolution);
  for (let i2 = 0; i2 < numPoints; i2++) {
    points += easing(progress(0, numPoints - 1, i2)) + ", ";
  }
  return points.substring(0, points.length - 2);
};
var convertEasing = (easing, duration) => {
  if (isFunction(easing)) {
    return supports.linearEasing() ? `linear(${generateLinearEasingPoints(easing, duration)})` : defaults.easing;
  } else {
    return isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;
  }
};
var cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;

// node_modules/@motionone/dom/dist/animate/utils/keyframes.es.js
function hydrateKeyframes(keyframes, readInitialValue) {
  for (let i2 = 0; i2 < keyframes.length; i2++) {
    if (keyframes[i2] === null) {
      keyframes[i2] = i2 ? keyframes[i2 - 1] : readInitialValue();
    }
  }
  return keyframes;
}
var keyframesList = (keyframes) => Array.isArray(keyframes) ? keyframes : [keyframes];

// node_modules/@motionone/dom/dist/animate/utils/get-style-name.es.js
function getStyleName(key) {
  if (transformAlias[key])
    key = transformAlias[key];
  return isTransform(key) ? asTransformCssVar(key) : key;
}

// node_modules/@motionone/dom/dist/animate/style.es.js
var style2 = {
  get: (element, name) => {
    name = getStyleName(name);
    let value2 = isCssVar(name) ? element.style.getPropertyValue(name) : getComputedStyle(element)[name];
    if (!value2 && value2 !== 0) {
      const definition = transformDefinitions.get(name);
      if (definition)
        value2 = definition.initialValue;
    }
    return value2;
  },
  set: (element, name, value2) => {
    name = getStyleName(name);
    if (isCssVar(name)) {
      element.style.setProperty(name, value2);
    } else {
      element.style[name] = value2;
    }
  }
};

// node_modules/@motionone/dom/dist/animate/utils/stop-animation.es.js
function stopAnimation(animation, needsCommit = true) {
  if (!animation || animation.playState === "finished")
    return;
  try {
    if (animation.stop) {
      animation.stop();
    } else {
      needsCommit && animation.commitStyles();
      animation.cancel();
    }
  } catch (e) {
  }
}

// node_modules/@motionone/dom/dist/animate/utils/get-unit.es.js
function getUnitConverter(keyframes, definition) {
  var _a;
  let toUnit = (definition === null || definition === void 0 ? void 0 : definition.toDefaultUnit) || noopReturn;
  const finalKeyframe = keyframes[keyframes.length - 1];
  if (isString(finalKeyframe)) {
    const unit = ((_a = finalKeyframe.match(/(-?[\d.]+)([a-z%]*)/)) === null || _a === void 0 ? void 0 : _a[2]) || "";
    if (unit)
      toUnit = (value2) => value2 + unit;
  }
  return toUnit;
}

// node_modules/@motionone/dom/dist/animate/animate-style.es.js
function getDevToolsRecord() {
  return window.__MOTION_DEV_TOOLS_RECORD;
}
function animateStyle(element, key, keyframesDefinition, options = {}, AnimationPolyfill) {
  const record = getDevToolsRecord();
  const isRecording = options.record !== false && record;
  let animation;
  let { duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, easing = defaults.easing, persist = false, direction, offset: offset3, allowWebkitAcceleration = false, autoplay = true } = options;
  const data2 = getAnimationData(element);
  const valueIsTransform = isTransform(key);
  let canAnimateNatively = supports.waapi();
  valueIsTransform && addTransformToElement(element, key);
  const name = getStyleName(key);
  const motionValue = getMotionValue(data2.values, name);
  const definition = transformDefinitions.get(name);
  stopAnimation(motionValue.animation, !(isEasingGenerator(easing) && motionValue.generator) && options.record !== false);
  return () => {
    const readInitialValue = () => {
      var _a, _b;
      return (_b = (_a = style2.get(element, name)) !== null && _a !== void 0 ? _a : definition === null || definition === void 0 ? void 0 : definition.initialValue) !== null && _b !== void 0 ? _b : 0;
    };
    let keyframes = hydrateKeyframes(keyframesList(keyframesDefinition), readInitialValue);
    const toUnit = getUnitConverter(keyframes, definition);
    if (isEasingGenerator(easing)) {
      const custom = easing.createAnimation(keyframes, key !== "opacity", readInitialValue, name, motionValue);
      easing = custom.easing;
      keyframes = custom.keyframes || keyframes;
      duration = custom.duration || duration;
    }
    if (isCssVar(name)) {
      if (supports.cssRegisterProperty()) {
        registerCssVariable(name);
      } else {
        canAnimateNatively = false;
      }
    }
    if (valueIsTransform && !supports.linearEasing() && (isFunction(easing) || isEasingList(easing) && easing.some(isFunction))) {
      canAnimateNatively = false;
    }
    if (canAnimateNatively) {
      if (definition) {
        keyframes = keyframes.map((value2) => isNumber2(value2) ? definition.toDefaultUnit(value2) : value2);
      }
      if (keyframes.length === 1 && (!supports.partialKeyframes() || isRecording)) {
        keyframes.unshift(readInitialValue());
      }
      const animationOptions = {
        delay: time.ms(delay),
        duration: time.ms(duration),
        endDelay: time.ms(endDelay),
        easing: !isEasingList(easing) ? convertEasing(easing, duration) : void 0,
        direction,
        iterations: repeat + 1,
        fill: "both"
      };
      animation = element.animate({
        [name]: keyframes,
        offset: offset3,
        easing: isEasingList(easing) ? easing.map((thisEasing) => convertEasing(thisEasing, duration)) : void 0
      }, animationOptions);
      if (!animation.finished) {
        animation.finished = new Promise((resolve, reject) => {
          animation.onfinish = resolve;
          animation.oncancel = reject;
        });
      }
      const target = keyframes[keyframes.length - 1];
      animation.finished.then(() => {
        if (persist)
          return;
        style2.set(element, name, target);
        animation.cancel();
      }).catch(noop);
      if (!allowWebkitAcceleration)
        animation.playbackRate = 1.000001;
    } else if (AnimationPolyfill && valueIsTransform) {
      keyframes = keyframes.map((value2) => typeof value2 === "string" ? parseFloat(value2) : value2);
      if (keyframes.length === 1) {
        keyframes.unshift(parseFloat(readInitialValue()));
      }
      animation = new AnimationPolyfill((latest) => {
        style2.set(element, name, toUnit ? toUnit(latest) : latest);
      }, keyframes, Object.assign(Object.assign({}, options), {
        duration,
        easing
      }));
    } else {
      const target = keyframes[keyframes.length - 1];
      style2.set(element, name, definition && isNumber2(target) ? definition.toDefaultUnit(target) : target);
    }
    if (isRecording) {
      record(element, key, keyframes, {
        duration,
        delay,
        easing,
        repeat,
        offset: offset3
      }, "motion-one");
    }
    motionValue.setAnimation(animation);
    if (animation && !autoplay)
      animation.pause();
    return animation;
  };
}

// node_modules/@motionone/dom/dist/animate/utils/options.es.js
var getOptions = (options, key) => (
  /**
   * TODO: Make test for this
   * Always return a new object otherwise delay is overwritten by results of stagger
   * and this results in no stagger
   */
  options[key] ? Object.assign(Object.assign({}, options), options[key]) : Object.assign({}, options)
);

// node_modules/@motionone/dom/dist/utils/resolve-elements.es.js
function resolveElements(elements, selectorCache) {
  var _a;
  if (typeof elements === "string") {
    if (selectorCache) {
      (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = document.querySelectorAll(elements);
      elements = selectorCache[elements];
    } else {
      elements = document.querySelectorAll(elements);
    }
  } else if (elements instanceof Element) {
    elements = [elements];
  }
  return Array.from(elements || []);
}

// node_modules/@motionone/dom/dist/animate/utils/controls.es.js
var createAnimation = (factory) => factory();
var withControls = (animationFactory, options, duration = defaults.duration) => {
  return new Proxy({
    animations: animationFactory.map(createAnimation).filter(Boolean),
    duration,
    options
  }, controls);
};
var getActiveAnimation = (state) => state.animations[0];
var controls = {
  get: (target, key) => {
    const activeAnimation = getActiveAnimation(target);
    switch (key) {
      case "duration":
        return target.duration;
      case "currentTime":
        return time.s((activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) || 0);
      case "playbackRate":
      case "playState":
        return activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key];
      case "finished":
        if (!target.finished) {
          target.finished = Promise.all(target.animations.map(selectFinished)).catch(noop);
        }
        return target.finished;
      case "stop":
        return () => {
          target.animations.forEach((animation) => stopAnimation(animation));
        };
      case "forEachNative":
        return (callback) => {
          target.animations.forEach((animation) => callback(animation, target));
        };
      default:
        return typeof (activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) === "undefined" ? void 0 : () => target.animations.forEach((animation) => animation[key]());
    }
  },
  set: (target, key, value2) => {
    switch (key) {
      case "currentTime":
        value2 = time.ms(value2);
      // Fall-through
      case "playbackRate":
        for (let i2 = 0; i2 < target.animations.length; i2++) {
          target.animations[i2][key] = value2;
        }
        return true;
    }
    return false;
  }
};
var selectFinished = (animation) => animation.finished;

// node_modules/@motionone/dom/dist/utils/stagger.es.js
function resolveOption(option, i2, total) {
  return isFunction(option) ? option(i2, total) : option;
}

// node_modules/@motionone/dom/dist/animate/create-animate.es.js
function createAnimate(AnimatePolyfill) {
  return function animate2(elements, keyframes, options = {}) {
    elements = resolveElements(elements);
    const numElements = elements.length;
    invariant(Boolean(numElements), "No valid element provided.");
    invariant(Boolean(keyframes), "No keyframes defined.");
    const animationFactories = [];
    for (let i2 = 0; i2 < numElements; i2++) {
      const element = elements[i2];
      for (const key in keyframes) {
        const valueOptions = getOptions(options, key);
        valueOptions.delay = resolveOption(valueOptions.delay, i2, numElements);
        const animation = animateStyle(element, key, keyframes[key], valueOptions, AnimatePolyfill);
        animationFactories.push(animation);
      }
    }
    return withControls(
      animationFactories,
      options,
      /**
       * TODO:
       * If easing is set to spring or glide, duration will be dynamically
       * generated. Ideally we would dynamically generate this from
       * animation.effect.getComputedTiming().duration but this isn't
       * supported in iOS13 or our number polyfill. Perhaps it's possible
       * to Proxy animations returned from animateStyle that has duration
       * as a getter.
       */
      options.duration
    );
  };
}

// node_modules/@motionone/dom/dist/animate/index.es.js
var animate = createAnimate(Animation);

// node_modules/tslib/tslib.es6.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
      if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
        t[p[i2]] = s[p[i2]];
    }
  return t;
}

// node_modules/@motionone/generators/dist/utils/velocity.es.js
var sampleT = 5;
function calcGeneratorVelocity(resolveValue, t, current) {
  const prevT = Math.max(t - sampleT, 0);
  return velocityPerSecond(current - resolveValue(prevT), t - prevT);
}

// node_modules/@motionone/generators/dist/spring/defaults.es.js
var defaults2 = {
  stiffness: 100,
  damping: 10,
  mass: 1
};

// node_modules/@motionone/generators/dist/spring/utils.es.js
var calcDampingRatio = (stiffness = defaults2.stiffness, damping = defaults2.damping, mass = defaults2.mass) => damping / (2 * Math.sqrt(stiffness * mass));

// node_modules/@motionone/generators/dist/utils/has-reached-target.es.js
function hasReachedTarget(origin, target, current) {
  return origin < target && current >= target || origin > target && current <= target;
}

// node_modules/@motionone/generators/dist/spring/index.es.js
var spring = ({ stiffness = defaults2.stiffness, damping = defaults2.damping, mass = defaults2.mass, from = 0, to = 1, velocity = 0, restSpeed, restDistance } = {}) => {
  velocity = velocity ? time.s(velocity) : 0;
  const state = {
    done: false,
    hasReachedTarget: false,
    current: from,
    target: to
  };
  const initialDelta = to - from;
  const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
  const dampingRatio = calcDampingRatio(stiffness, damping, mass);
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
  restDistance || (restDistance = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = undampedAngularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
    resolveSpring = (t) => to - Math.exp(-dampingRatio * undampedAngularFreq * t) * ((-velocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
  } else {
    resolveSpring = (t) => {
      return to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (-velocity + undampedAngularFreq * initialDelta) * t);
    };
  }
  return (t) => {
    state.current = resolveSpring(t);
    const currentVelocity = t === 0 ? velocity : calcGeneratorVelocity(resolveSpring, t, state.current);
    const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
    const isBelowDisplacementThreshold = Math.abs(to - state.current) <= restDistance;
    state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
    state.hasReachedTarget = hasReachedTarget(from, to, state.current);
    return state;
  };
};

// node_modules/@motionone/generators/dist/glide/index.es.js
var glide = ({ from = 0, velocity = 0, power = 0.8, decay = 0.325, bounceDamping, bounceStiffness, changeTarget, min: min2, max: max2, restDistance = 0.5, restSpeed }) => {
  decay = time.ms(decay);
  const state = {
    hasReachedTarget: false,
    done: false,
    current: from,
    target: from
  };
  const isOutOfBounds = (v) => min2 !== void 0 && v < min2 || max2 !== void 0 && v > max2;
  const nearestBoundary = (v) => {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v) < Math.abs(max2 - v) ? min2 : max2;
  };
  let amplitude = power * velocity;
  const ideal = from + amplitude;
  const target = changeTarget === void 0 ? ideal : changeTarget(ideal);
  state.target = target;
  if (target !== ideal)
    amplitude = target - from;
  const calcDelta = (t) => -amplitude * Math.exp(-t / decay);
  const calcLatest = (t) => target + calcDelta(t);
  const applyFriction = (t) => {
    const delta = calcDelta(t);
    const latest = calcLatest(t);
    state.done = Math.abs(delta) <= restDistance;
    state.current = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t) => {
    if (!isOutOfBounds(state.current))
      return;
    timeReachedBoundary = t;
    spring$1 = spring({
      from: state.current,
      to: nearestBoundary(state.current),
      velocity: calcGeneratorVelocity(calcLatest, t, state.current),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDistance,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return (t) => {
    let hasUpdatedFrame = false;
    if (!spring$1 && timeReachedBoundary === void 0) {
      hasUpdatedFrame = true;
      applyFriction(t);
      checkCatchBoundary(t);
    }
    if (timeReachedBoundary !== void 0 && t > timeReachedBoundary) {
      state.hasReachedTarget = true;
      return spring$1(t - timeReachedBoundary);
    } else {
      state.hasReachedTarget = false;
      !hasUpdatedFrame && applyFriction(t);
      return state;
    }
  };
};

// node_modules/@motionone/generators/dist/utils/pregenerate-keyframes.es.js
var timeStep = 10;
var maxDuration = 1e4;
function pregenerateKeyframes(generator, toUnit = noopReturn) {
  let overshootDuration = void 0;
  let timestamp = timeStep;
  let state = generator(0);
  const keyframes = [toUnit(state.current)];
  while (!state.done && timestamp < maxDuration) {
    state = generator(timestamp);
    keyframes.push(toUnit(state.done ? state.target : state.current));
    if (overshootDuration === void 0 && state.hasReachedTarget) {
      overshootDuration = timestamp;
    }
    timestamp += timeStep;
  }
  const duration = timestamp - timeStep;
  if (keyframes.length === 1)
    keyframes.push(state.current);
  return {
    keyframes,
    duration: duration / 1e3,
    overshootDuration: (overshootDuration !== null && overshootDuration !== void 0 ? overshootDuration : duration) / 1e3
  };
}

// node_modules/@motionone/dom/dist/easing/create-generator-easing.es.js
function canGenerate(value2) {
  return isNumber2(value2) && !isNaN(value2);
}
function getAsNumber(value2) {
  return isString(value2) ? parseFloat(value2) : value2;
}
function createGeneratorEasing(createGenerator) {
  const keyframesCache = /* @__PURE__ */ new WeakMap();
  return (options = {}) => {
    const generatorCache = /* @__PURE__ */ new Map();
    const getGenerator = (from = 0, to = 100, velocity = 0, isScale = false) => {
      const key = `${from}-${to}-${velocity}-${isScale}`;
      if (!generatorCache.has(key)) {
        generatorCache.set(key, createGenerator(Object.assign({
          from,
          to,
          velocity
        }, options)));
      }
      return generatorCache.get(key);
    };
    const getKeyframes = (generator, toUnit) => {
      if (!keyframesCache.has(generator)) {
        keyframesCache.set(generator, pregenerateKeyframes(generator, toUnit));
      }
      return keyframesCache.get(generator);
    };
    return {
      createAnimation: (keyframes, shouldGenerate = true, getOrigin, name, motionValue) => {
        let settings;
        let origin;
        let target;
        let velocity = 0;
        let toUnit = noopReturn;
        const numKeyframes = keyframes.length;
        if (shouldGenerate) {
          toUnit = getUnitConverter(keyframes, name ? transformDefinitions.get(getStyleName(name)) : void 0);
          const targetDefinition = keyframes[numKeyframes - 1];
          target = getAsNumber(targetDefinition);
          if (numKeyframes > 1 && keyframes[0] !== null) {
            origin = getAsNumber(keyframes[0]);
          } else {
            const prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;
            if (prevGenerator) {
              const { animation, generatorStartTime } = motionValue;
              const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;
              const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;
              const prevGeneratorCurrent = prevGenerator(currentTime).current;
              origin = prevGeneratorCurrent;
              velocity = calcGeneratorVelocity((t) => prevGenerator(t).current, currentTime, prevGeneratorCurrent);
            } else if (getOrigin) {
              origin = getAsNumber(getOrigin());
            }
          }
        }
        if (canGenerate(origin) && canGenerate(target)) {
          const generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes("scale"));
          settings = Object.assign(Object.assign({}, getKeyframes(generator, toUnit)), { easing: "linear" });
          if (motionValue) {
            motionValue.generator = generator;
            motionValue.generatorStartTime = performance.now();
          }
        }
        if (!settings) {
          const keyframesMetadata = getKeyframes(getGenerator(0, 100));
          settings = {
            easing: "ease",
            duration: keyframesMetadata.overshootDuration
          };
        }
        return settings;
      }
    };
  };
}

// node_modules/@motionone/dom/dist/easing/spring/index.es.js
var spring2 = createGeneratorEasing(spring);

// node_modules/@motionone/dom/dist/easing/glide/index.es.js
var glide2 = createGeneratorEasing(glide);

// node_modules/@motionone/dom/dist/gestures/in-view.es.js
var thresholds = {
  any: 0,
  all: 1
};
function inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = "any" } = {}) {
  if (typeof IntersectionObserver === "undefined") {
    return () => {
    };
  }
  const elements = resolveElements(elementOrSelector);
  const activeIntersections = /* @__PURE__ */ new WeakMap();
  const onIntersectionChange = (entries) => {
    entries.forEach((entry) => {
      const onEnd = activeIntersections.get(entry.target);
      if (entry.isIntersecting === Boolean(onEnd))
        return;
      if (entry.isIntersecting) {
        const newOnEnd = onStart(entry);
        if (isFunction(newOnEnd)) {
          activeIntersections.set(entry.target, newOnEnd);
        } else {
          observer.unobserve(entry.target);
        }
      } else if (onEnd) {
        onEnd(entry);
        activeIntersections.delete(entry.target);
      }
    });
  };
  const observer = new IntersectionObserver(onIntersectionChange, {
    root,
    rootMargin,
    threshold: typeof amount === "number" ? amount : thresholds[amount]
  });
  elements.forEach((element) => observer.observe(element));
  return () => observer.disconnect();
}

// node_modules/@motionone/dom/dist/state/utils/has-changed.es.js
function hasChanged(a, b) {
  if (typeof a !== typeof b)
    return true;
  if (Array.isArray(a) && Array.isArray(b))
    return !shallowCompare(a, b);
  return a !== b;
}
function shallowCompare(next, prev2) {
  const prevLength = prev2.length;
  if (prevLength !== next.length)
    return false;
  for (let i2 = 0; i2 < prevLength; i2++) {
    if (prev2[i2] !== next[i2])
      return false;
  }
  return true;
}

// node_modules/@motionone/dom/dist/state/utils/is-variant.es.js
function isVariant(definition) {
  return typeof definition === "object";
}

// node_modules/@motionone/dom/dist/state/utils/resolve-variant.es.js
function resolveVariant(definition, variants) {
  if (isVariant(definition)) {
    return definition;
  } else if (definition && variants) {
    return variants[definition];
  }
}

// node_modules/@motionone/dom/dist/state/utils/schedule.es.js
var scheduled = void 0;
function processScheduledAnimations() {
  if (!scheduled)
    return;
  const generators = scheduled.sort(compareByDepth).map(fireAnimateUpdates);
  generators.forEach(fireNext);
  generators.forEach(fireNext);
  scheduled = void 0;
}
function scheduleAnimation(state) {
  if (!scheduled) {
    scheduled = [state];
    requestAnimationFrame(processScheduledAnimations);
  } else {
    addUniqueItem(scheduled, state);
  }
}
function unscheduleAnimation(state) {
  scheduled && removeItem(scheduled, state);
}
var compareByDepth = (a, b) => a.getDepth() - b.getDepth();
var fireAnimateUpdates = (state) => state.animateUpdates();
var fireNext = (iterator) => iterator.next();

// node_modules/@motionone/dom/dist/state/utils/events.es.js
var motionEvent = (name, target) => new CustomEvent(name, { detail: { target } });
function dispatchPointerEvent(element, name, event) {
  element.dispatchEvent(new CustomEvent(name, { detail: { originalEvent: event } }));
}
function dispatchViewEvent(element, name, entry) {
  element.dispatchEvent(new CustomEvent(name, { detail: { originalEntry: entry } }));
}

// node_modules/@motionone/dom/dist/state/gestures/in-view.es.js
var inView2 = {
  isActive: (options) => Boolean(options.inView),
  subscribe: (element, { enable, disable }, { inViewOptions = {} }) => {
    const { once } = inViewOptions, viewOptions = __rest(inViewOptions, ["once"]);
    return inView(element, (enterEntry) => {
      enable();
      dispatchViewEvent(element, "viewenter", enterEntry);
      if (!once) {
        return (leaveEntry) => {
          disable();
          dispatchViewEvent(element, "viewleave", leaveEntry);
        };
      }
    }, viewOptions);
  }
};

// node_modules/@motionone/dom/dist/state/gestures/hover.es.js
var mouseEvent = (element, name, action) => (event) => {
  if (event.pointerType && event.pointerType !== "mouse")
    return;
  action();
  dispatchPointerEvent(element, name, event);
};
var hover = {
  isActive: (options) => Boolean(options.hover),
  subscribe: (element, { enable, disable }) => {
    const onEnter = mouseEvent(element, "hoverstart", enable);
    const onLeave = mouseEvent(element, "hoverend", disable);
    element.addEventListener("pointerenter", onEnter);
    element.addEventListener("pointerleave", onLeave);
    return () => {
      element.removeEventListener("pointerenter", onEnter);
      element.removeEventListener("pointerleave", onLeave);
    };
  }
};

// node_modules/@motionone/dom/dist/state/gestures/press.es.js
var press = {
  isActive: (options) => Boolean(options.press),
  subscribe: (element, { enable, disable }) => {
    const onPointerUp = (event) => {
      disable();
      dispatchPointerEvent(element, "pressend", event);
      window.removeEventListener("pointerup", onPointerUp);
    };
    const onPointerDown = (event) => {
      enable();
      dispatchPointerEvent(element, "pressstart", event);
      window.addEventListener("pointerup", onPointerUp);
    };
    element.addEventListener("pointerdown", onPointerDown);
    return () => {
      element.removeEventListener("pointerdown", onPointerDown);
      window.removeEventListener("pointerup", onPointerUp);
    };
  }
};

// node_modules/@motionone/dom/dist/state/index.es.js
var gestures = { inView: inView2, hover, press };
var stateTypes = ["initial", "animate", ...Object.keys(gestures), "exit"];
var mountedStates = /* @__PURE__ */ new WeakMap();
function createMotionState(options = {}, parent) {
  let element;
  let depth = parent ? parent.getDepth() + 1 : 0;
  const activeStates = { initial: true, animate: true };
  const gestureSubscriptions = {};
  const context = {};
  for (const name of stateTypes) {
    context[name] = typeof options[name] === "string" ? options[name] : parent === null || parent === void 0 ? void 0 : parent.getContext()[name];
  }
  const initialVariantSource = options.initial === false ? "animate" : "initial";
  let _a = resolveVariant(options[initialVariantSource] || context[initialVariantSource], options.variants) || {}, target = __rest(_a, ["transition"]);
  const baseTarget = Object.assign({}, target);
  function* animateUpdates() {
    var _a2, _b;
    const prevTarget = target;
    target = {};
    const animationOptions = {};
    for (const name of stateTypes) {
      if (!activeStates[name])
        continue;
      const variant = resolveVariant(options[name]);
      if (!variant)
        continue;
      for (const key in variant) {
        if (key === "transition")
          continue;
        target[key] = variant[key];
        animationOptions[key] = getOptions((_b = (_a2 = variant.transition) !== null && _a2 !== void 0 ? _a2 : options.transition) !== null && _b !== void 0 ? _b : {}, key);
      }
    }
    const allTargetKeys = /* @__PURE__ */ new Set([
      ...Object.keys(target),
      ...Object.keys(prevTarget)
    ]);
    const animationFactories = [];
    allTargetKeys.forEach((key) => {
      var _a3;
      if (target[key] === void 0) {
        target[key] = baseTarget[key];
      }
      if (hasChanged(prevTarget[key], target[key])) {
        (_a3 = baseTarget[key]) !== null && _a3 !== void 0 ? _a3 : baseTarget[key] = style2.get(element, key);
        animationFactories.push(animateStyle(element, key, target[key], animationOptions[key], Animation));
      }
    });
    yield;
    const animations = animationFactories.map((factory) => factory()).filter(Boolean);
    if (!animations.length)
      return;
    const animationTarget = target;
    element.dispatchEvent(motionEvent("motionstart", animationTarget));
    Promise.all(animations.map((animation) => animation.finished)).then(() => {
      element.dispatchEvent(motionEvent("motioncomplete", animationTarget));
    }).catch(noop);
  }
  const setGesture = (name, isActive) => () => {
    activeStates[name] = isActive;
    scheduleAnimation(state);
  };
  const updateGestureSubscriptions = () => {
    for (const name in gestures) {
      const isGestureActive = gestures[name].isActive(options);
      const remove = gestureSubscriptions[name];
      if (isGestureActive && !remove) {
        gestureSubscriptions[name] = gestures[name].subscribe(element, {
          enable: setGesture(name, true),
          disable: setGesture(name, false)
        }, options);
      } else if (!isGestureActive && remove) {
        remove();
        delete gestureSubscriptions[name];
      }
    }
  };
  const state = {
    update: (newOptions) => {
      if (!element)
        return;
      options = newOptions;
      updateGestureSubscriptions();
      scheduleAnimation(state);
    },
    setActive: (name, isActive) => {
      if (!element)
        return;
      activeStates[name] = isActive;
      scheduleAnimation(state);
    },
    animateUpdates,
    getDepth: () => depth,
    getTarget: () => target,
    getOptions: () => options,
    getContext: () => context,
    mount: (newElement) => {
      invariant(Boolean(newElement), "Animation state must be mounted with valid Element");
      element = newElement;
      mountedStates.set(element, state);
      updateGestureSubscriptions();
      return () => {
        mountedStates.delete(element);
        unscheduleAnimation(state);
        for (const key in gestureSubscriptions) {
          gestureSubscriptions[key]();
        }
      };
    },
    isMounted: () => Boolean(element)
  };
  return state;
}

// node_modules/@motionone/dom/dist/animate/utils/style-object.es.js
function createStyles(keyframes) {
  const initialKeyframes = {};
  const transformKeys = [];
  for (let key in keyframes) {
    const value2 = keyframes[key];
    if (isTransform(key)) {
      if (transformAlias[key])
        key = transformAlias[key];
      transformKeys.push(key);
      key = asTransformCssVar(key);
    }
    let initialKeyframe = Array.isArray(value2) ? value2[0] : value2;
    const definition = transformDefinitions.get(key);
    if (definition) {
      initialKeyframe = isNumber2(value2) ? definition.toDefaultUnit(value2) : value2;
    }
    initialKeyframes[key] = initialKeyframe;
  }
  if (transformKeys.length) {
    initialKeyframes.transform = buildTransformTemplate(transformKeys);
  }
  return initialKeyframes;
}

// node_modules/solid-motionone/dist/index.js
var PresenceContext = createContext();
function createAndBindMotionState(el, options, presence_state, parent_state) {
  const state = createMotionState(
    (presence_state == null ? void 0 : presence_state.initial) === false ? { ...options(), initial: false } : options(),
    parent_state
  );
  createEffect(() => {
    if (presence_state && !presence_state.mount()) return;
    const el_ref = el(), unmount = state.mount(el_ref);
    createEffect(() => state.update(options()));
    onCleanup(() => {
      if (presence_state && options().exit) {
        state.setActive("exit", true);
        el_ref.addEventListener("motioncomplete", unmount);
      } else unmount();
    });
  });
  return [state, createStyles(state.getTarget())];
}
var OPTION_KEYS = ["initial", "animate", "inView", "inViewOptions", "hover", "press", "variants", "transition", "exit"];
var ATTR_KEYS = ["tag"];
var ParentContext = createContext();
var MotionComponent = (props) => {
  const [options, , attrs] = splitProps(props, OPTION_KEYS, ATTR_KEYS);
  const [state, style22] = createAndBindMotionState(() => root, () => ({
    ...options
  }), useContext(PresenceContext), useContext(ParentContext));
  let root;
  return createComponent(ParentContext.Provider, {
    value: state,
    get children() {
      return createComponent(Dynamic, mergeProps(attrs, {
        ref: (el) => {
          var _a;
          root = el;
          (_a = props.ref) == null ? void 0 : _a.call(props, el);
        },
        get component() {
          return props.tag || "div";
        },
        get style() {
          return combineStyle(props.style, style22);
        }
      }));
    }
  });
};
var Motion = new Proxy(MotionComponent, {
  get: (_, tag) => (props) => createComponent(MotionComponent, mergeProps(props, {
    tag
  }))
});

// node_modules/@novu/js/dist/esm/ui/index.mjs
var ui_default = `.novu{scrollbar-color:var(--nv-color-secondary-foreground-alpha-300) #0000;:where(*),:where(*) :after,:where(*) :before,:where(*):after,:where(*):before{border:0 solid #e5e7eb;box-sizing:border-box}:where(html,:host){line-height:1.5;-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-feature-settings:normal;font-variation-settings:normal;tab-size:4;-webkit-tap-highlight-color:transparent}:where(body){line-height:inherit;margin:0}:where(hr){border-top-width:1px;color:inherit;height:0}:where(abbr:where([title])){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}:where(h1,h2,h3,h4,h5,h6){font-size:inherit;font-weight:inherit}:where(a){color:inherit;text-decoration:inherit}:where(b,strong){font-weight:bolder}:where(code,kbd,samp,pre){font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-feature-settings:normal;font-size:1em;font-variation-settings:normal}:where(small){font-size:80%}:where(sub,sup){font-size:75%;line-height:0;position:relative;vertical-align:initial}:where(sub){bottom:-.25em}:where(sup){top:-.5em}:where(table){border-collapse:collapse;border-color:inherit;text-indent:0}:where(button,input,optgroup,select,textarea){color:inherit;font-family:inherit;font-feature-settings:inherit;font-size:100%;font-variation-settings:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0}:where(button,select){text-transform:none}:where(button,input:where([type=button]),input:where([type=reset]),input:where([type=submit])){-webkit-appearance:button;background-color:initial;background-image:none}:where(:-moz-focusring){outline:auto}:where(:-moz-ui-invalid){box-shadow:none}:where(progress){vertical-align:initial}:where(*)::-webkit-inner-spin-button,:where(*)::-webkit-outer-spin-button{height:auto}:where([type=search]){-webkit-appearance:textfield;outline-offset:-2px}:where(*)::-webkit-search-decoration{-webkit-appearance:none}:where(*)::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}:where(summary){display:list-item}:where(blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre){margin:0}:where(fieldset){margin:0;padding:0}:where(legend){padding:0}:where(ol,ul,menu){list-style:none;margin:0;padding:0}:where(dialog){padding:0}:where(textarea){resize:vertical}:where(input)::placeholder,:where(textarea)::placeholder{color:#9ca3af;opacity:1}:where(button,[role=button]){cursor:pointer}:where(:disabled){cursor:default}:where(img,svg,video,canvas,audio,iframe,embed,object){display:block;vertical-align:middle}:where(img,video){height:auto;max-width:100%}:where([hidden]){display:none}:where(*),:where(*) :after,:where(*) :before,:where(*):after,:where(*):before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:#3b82f680;--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }:where(*) ::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:#3b82f680;--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::-webkit-scrollbar{height:.5rem;width:.5rem}::-webkit-scrollbar-thumb{background-clip:"padding-box";background-color:var(--nv-color-secondary-foreground-alpha-300);border-radius:.25rem}::-webkit-scrollbar-corner,::-webkit-scrollbar-track{background-color:initial}input::-webkit-inner-spin-button,input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}input[type=number]{-moz-appearance:textfield}}.nt-sr-only{height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;clip:rect(0,0,0,0);border-width:0;white-space:nowrap}.\\!nt-pointer-events-auto{pointer-events:auto!important}.nt-invisible{visibility:hidden}.nt-absolute{position:absolute}.nt-relative{position:relative}.nt-inset-0{inset:0}.nt-inset-2{inset:.5rem}.nt-left-0\\.5{left:.125rem}.nt-right-0{right:0}.nt-right-3{right:.75rem}.nt-top-0{top:0}.nt-top-0\\.5{top:.125rem}.nt-top-3{top:.75rem}.nt-z-10{z-index:10}.nt-z-\\[-1\\]{z-index:-1}.nt-mx-auto{margin-left:auto;margin-right:auto}.nt-mb-2{margin-bottom:.5rem}.nt-mb-4{margin-bottom:1rem}.nt-mb-\\[0\\.625rem\\]{margin-bottom:.625rem}.nt-ml-2{margin-left:.5rem}.nt-ml-auto{margin-left:auto}.nt-mr-2{margin-right:.5rem}.nt-mr-auto{margin-right:auto}.nt-mt-auto{margin-top:auto}.nt-block{display:block}.nt-flex{display:flex}.nt-inline-flex{display:inline-flex}.nt-grid{display:grid}.nt-hidden{display:none}.nt-aspect-square{aspect-ratio:1/1}.nt-size-1\\.5{height:.375rem;width:.375rem}.nt-size-2{height:.5rem;width:.5rem}.nt-size-2\\.5{height:.625rem;width:.625rem}.nt-size-3{height:.75rem;width:.75rem}.nt-size-4{height:1rem;width:1rem}.nt-size-5{height:1.25rem;width:1.25rem}.nt-size-8{height:2rem;width:2rem}.nt-size-fit{height:fit-content;width:fit-content}.nt-size-full{height:100%;width:100%}.nt-h-2{height:.5rem}.nt-h-3{height:.75rem}.nt-h-4{height:1rem}.nt-h-5{height:1.25rem}.nt-h-7{height:1.75rem}.nt-h-8{height:2rem}.nt-h-9{height:2.25rem}.nt-h-\\[600px\\]{height:600px}.nt-h-fit{height:fit-content}.nt-h-full{height:100%}.nt-min-h-0{min-height:0}.nt-w-1\\/3{width:33.333333%}.nt-w-2\\/3{width:66.666667%}.nt-w-5{width:1.25rem}.nt-w-7{width:1.75rem}.nt-w-8{width:2rem}.nt-w-\\[260px\\]{width:260px}.nt-w-\\[400px\\]{width:400px}.nt-w-\\[60px\\]{width:60px}.nt-w-\\[calc\\(2ch\\+2rem\\)\\]{width:calc(2ch + 2rem)}.nt-w-fit{width:fit-content}.nt-w-full{width:100%}.nt-w-max{width:max-content}.nt-min-w-52{min-width:13rem}.nt-flex-1{flex:1 1 0%}.nt-shrink-0{flex-shrink:0}.nt-transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.nt-cursor-default{cursor:default}.nt-cursor-pointer{cursor:pointer}.nt-grid-cols-7{grid-template-columns:repeat(7,minmax(0,1fr))}.nt-flex-row{flex-direction:row}.nt-flex-col{flex-direction:column}.nt-flex-wrap{flex-wrap:wrap}.nt-flex-nowrap{flex-wrap:nowrap}.nt-items-start{align-items:flex-start}.nt-items-center{align-items:center}.nt-justify-end{justify-content:flex-end}.nt-justify-center{justify-content:center}.nt-justify-between{justify-content:space-between}.nt-gap-0\\.5{gap:.125rem}.nt-gap-1{gap:.25rem}.nt-gap-1\\.5{gap:.375rem}.nt-gap-2{gap:.5rem}.nt-gap-3{gap:.75rem}.nt-gap-4{gap:1rem}.nt-gap-6{gap:1.5rem}.nt-gap-8{gap:2rem}.nt-self-stretch{align-self:stretch}.nt-overflow-auto{overflow:auto}.nt-overflow-hidden{overflow:hidden}.nt-overflow-y-auto{overflow-y:auto}.nt-truncate{overflow:hidden;text-overflow:ellipsis}.nt-truncate,.nt-whitespace-nowrap{white-space:nowrap}.nt-whitespace-pre-wrap{white-space:pre-wrap}.nt-rounded{border-radius:var(--nv-radius-base)}.nt-rounded-full{border-radius:var(--nv-radius-full)}.nt-rounded-lg{border-radius:var(--nv-radius-lg)}.nt-rounded-md{border-radius:var(--nv-radius-md)}.nt-rounded-sm{border-radius:var(--nv-radius-sm)}.nt-rounded-xl{border-radius:var(--nv-radius-xl)}.nt-border{border-width:1px}.nt-border-b{border-bottom-width:1px}.nt-border-t{border-top-width:1px}.nt-border-background{border-color:var(--nv-color-background)}.nt-border-border{border-color:var(--nv-color-neutral-alpha-100)}.nt-border-neutral-200{--tw-border-opacity:1;border-color:rgb(229 229 229/var(--tw-border-opacity,1))}.nt-border-neutral-alpha-100{border-color:var(--nv-color-neutral-alpha-100)}.nt-border-neutral-alpha-50{border-color:var(--nv-color-neutral-alpha-50)}.nt-border-t-neutral-alpha-200{border-top-color:var(--nv-color-neutral-alpha-200)}.nt-bg-\\[oklch\\(from_var\\(--nv-color-stripes\\)_l_c_h_\\/_0\\.1\\)\\]{background-color:oklch(from var(--nv-color-stripes) l c h/.1)}.nt-bg-background{background-color:var(--nv-color-background)}.nt-bg-counter{background-color:var(--nv-color-counter)}.nt-bg-foreground{background-color:var(--nv-color-foreground)}.nt-bg-neutral-alpha-100{background-color:var(--nv-color-neutral-alpha-100)}.nt-bg-neutral-alpha-25{background-color:var(--nv-color-neutral-alpha-25)}.nt-bg-neutral-alpha-300{background-color:var(--nv-color-neutral-alpha-300)}.nt-bg-neutral-alpha-50{background-color:var(--nv-color-neutral-alpha-50)}.nt-bg-primary{background-color:var(--nv-color-primary)}.nt-bg-primary-alpha-300{background-color:var(--nv-color-primary-alpha-300)}.nt-bg-primary-alpha-400{background-color:var(--nv-color-primary-alpha-400)}.nt-bg-secondary{background-color:var(--nv-color-secondary)}.nt-bg-gradient-to-b{background-image:linear-gradient(to bottom,var(--tw-gradient-stops))}.nt-bg-gradient-to-r{background-image:linear-gradient(to right,var(--tw-gradient-stops))}.nt-from-foreground-alpha-50{--tw-gradient-from:var(--nv-color-foreground-alpha-50) var(--tw-gradient-from-position);--tw-gradient-to:#fff0 var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-from),var(--tw-gradient-to)}.nt-from-primary-foreground-alpha-200{--tw-gradient-from:var(--nv-color-primary-foreground-alpha-200) var(--tw-gradient-from-position);--tw-gradient-to:#fff0 var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-from),var(--tw-gradient-to)}.nt-from-transparent{--tw-gradient-from:#0000 var(--tw-gradient-from-position);--tw-gradient-to:#0000 var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-from),var(--tw-gradient-to)}.nt-from-20\\%{--tw-gradient-from-position:20%}.nt-to-background{--tw-gradient-to:var(--nv-color-background) var(--tw-gradient-to-position)}.nt-to-transparent{--tw-gradient-to:#0000 var(--tw-gradient-to-position)}.nt-object-cover{object-fit:cover}.nt-p-0{padding:0}.nt-p-0\\.5{padding:.125rem}.nt-p-1{padding:.25rem}.nt-p-2{padding:.5rem}.nt-p-2\\.5{padding:.625rem}.nt-p-3{padding:.75rem}.nt-p-4{padding:1rem}.nt-px-1{padding-left:.25rem;padding-right:.25rem}.nt-px-2{padding-left:.5rem;padding-right:.5rem}.nt-px-3{padding-left:.75rem;padding-right:.75rem}.nt-px-4{padding-left:1rem;padding-right:1rem}.nt-px-8{padding-left:2rem;padding-right:2rem}.nt-px-\\[6px\\]{padding-left:6px;padding-right:6px}.nt-py-1{padding-bottom:.25rem;padding-top:.25rem}.nt-py-2{padding-bottom:.5rem;padding-top:.5rem}.nt-py-3{padding-bottom:.75rem;padding-top:.75rem}.nt-py-3\\.5{padding-bottom:.875rem;padding-top:.875rem}.nt-py-4{padding-bottom:1rem;padding-top:1rem}.nt-py-px{padding-bottom:1px;padding-top:1px}.nt-pb-2{padding-bottom:.5rem}.nt-pb-\\[0\\.625rem\\]{padding-bottom:.625rem}.nt-pt-2\\.5{padding-top:.625rem}.nt-text-center{text-align:center}.nt-text-start{text-align:start}.nt-font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.nt-text-\\[0\\.8rem\\]{font-size:.8rem}.nt-text-base{font-size:var(--nv-font-size-base);line-height:var(--nv-line-height-base)}.nt-text-sm{font-size:var(--nv-font-size-sm);line-height:var(--nv-line-height-sm)}.nt-text-xl{font-size:var(--nv-font-size-xl);line-height:var(--nv-line-height-xl)}.nt-text-xs{font-size:var(--nv-font-size-xs);line-height:var(--nv-line-height-xs)}.nt-font-medium{font-weight:500}.nt-font-normal{font-weight:400}.nt-font-semibold{font-weight:600}.nt-leading-none{line-height:1}.nt-text-background{color:var(--nv-color-background)}.nt-text-counter-foreground{color:var(--nv-color-counter-foreground)}.nt-text-foreground{color:var(--nv-color-foreground)}.nt-text-foreground-alpha-300{color:var(--nv-color-foreground-alpha-300)}.nt-text-foreground-alpha-400{color:var(--nv-color-foreground-alpha-400)}.nt-text-foreground-alpha-600{color:var(--nv-color-foreground-alpha-600)}.nt-text-foreground-alpha-700{color:var(--nv-color-foreground-alpha-700)}.nt-text-primary-foreground{color:var(--nv-color-primary-foreground)}.nt-text-secondary-foreground{color:var(--nv-color-secondary-foreground)}.nt-text-stripes{color:var(--nv-color-stripes)}.nt-opacity-0{opacity:0}.nt-opacity-20{opacity:.2}.nt-shadow{--tw-shadow:0 1px 3px 0 #0000001a,0 1px 2px -1px #0000001a;--tw-shadow-colored:0 1px 3px 0 var(--tw-shadow-color),0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.nt-shadow-\\[0_0_0_0\\.5px_var\\(--nv-color-primary-600\\)\\]{--tw-shadow:0 0 0 0.5px var(--nv-color-primary-600);--tw-shadow-colored:0 0 0 0.5px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.nt-shadow-\\[0_0_0_0\\.5px_var\\(--nv-color-secondary-600\\)\\]{--tw-shadow:0 0 0 0.5px var(--nv-color-secondary-600);--tw-shadow-colored:0 0 0 0.5px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.nt-shadow-\\[0px_1px_2px_0px_rgba\\(10\\,13\\,20\\,0\\.03\\)\\]{--tw-shadow:0px 1px 2px 0px #0a0d1408;--tw-shadow-colored:0px 1px 2px 0px var(--tw-shadow-color)}.nt-shadow-\\[0px_1px_2px_0px_rgba\\(10\\,13\\,20\\,0\\.03\\)\\],.nt-shadow-dropdown{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.nt-shadow-dropdown{--tw-shadow:0px 12px 16px -4px oklch(from var(--nv-color-shadow) l c h/0.08),0px 4px 6px -2px oklch(from var(--nv-color-shadow) l c h/0.03);--tw-shadow-colored:0px 12px 16px -4px var(--tw-shadow-color),0px 4px 6px -2px var(--tw-shadow-color)}.nt-shadow-lg{--tw-shadow:0 10px 15px -3px #0000001a,0 4px 6px -4px #0000001a;--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color),0 4px 6px -4px var(--tw-shadow-color)}.nt-shadow-lg,.nt-shadow-popover{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.nt-shadow-popover{--tw-shadow:0px 8px 26px 0px oklch(from var(--nv-color-shadow) l c h/0.08),0px 2px 6px 0px oklch(from var(--nv-color-shadow) l c h/0.12);--tw-shadow-colored:0px 8px 26px 0px var(--tw-shadow-color),0px 2px 6px 0px var(--tw-shadow-color)}.nt-shadow-tooltip{--tw-shadow:0 5px 20px 0 oklch(from var(--nv-color-shadow) l c h/0.08);--tw-shadow-colored:0 5px 20px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.nt-outline-none{outline:2px solid #0000;outline-offset:2px}.nt-backdrop-blur-lg{--tw-backdrop-blur:blur(16px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.nt-transition{transition-duration:.15s;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1)}.nt-transition-all{transition-duration:.15s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1)}.nt-transition-colors{transition-duration:.15s;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1)}.nt-duration-100{transition-duration:.1s}.nt-duration-200{transition-duration:.2s}.nt-ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}@keyframes enter{0%{opacity:var(--tw-enter-opacity,1);transform:translate3d(var(--tw-enter-translate-x,0),var(--tw-enter-translate-y,0),0) scale3d(var(--tw-enter-scale,1),var(--tw-enter-scale,1),var(--tw-enter-scale,1)) rotate(var(--tw-enter-rotate,0))}}@keyframes exit{to{opacity:var(--tw-exit-opacity,1);transform:translate3d(var(--tw-exit-translate-x,0),var(--tw-exit-translate-y,0),0) scale3d(var(--tw-exit-scale,1),var(--tw-exit-scale,1),var(--tw-exit-scale,1)) rotate(var(--tw-exit-rotate,0))}}.nt-animate-in{animation-duration:.15s;animation-name:enter;--tw-enter-opacity:initial;--tw-enter-scale:initial;--tw-enter-rotate:initial;--tw-enter-translate-x:initial;--tw-enter-translate-y:initial}.nt-fade-in{--tw-enter-opacity:0}.nt-slide-in-from-top-2{--tw-enter-translate-y:-0.5rem}.nt-duration-100{animation-duration:.1s}.nt-duration-200{animation-duration:.2s}.nt-ease-out{animation-timing-function:cubic-bezier(0,0,.2,1)}.before\\:nt-absolute:before{content:var(--tw-content);position:absolute}.before\\:nt-inset-0:before{content:var(--tw-content);inset:0}.before\\:-nt-right-\\[calc\\(0\\+var\\(--stripes-size\\)\\)\\]:before{content:var(--tw-content);right:calc(var(--stripes-size)*-1)}@keyframes nt-stripes{0%{content:var(--tw-content);transform:translateX(0)}to{content:var(--tw-content);transform:translateX(calc(var(--stripes-size)*-1))}}.before\\:nt-animate-stripes:before{animation:nt-stripes 1s linear infinite paused;content:var(--tw-content)}.before\\:nt-rounded-lg:before{border-radius:var(--nv-radius-lg);content:var(--tw-content)}.before\\:nt-rounded-md:before{border-radius:var(--nv-radius-md);content:var(--tw-content)}.before\\:nt-rounded-xl:before{border-radius:var(--nv-radius-xl);content:var(--tw-content)}.before\\:nt-border:before{border-width:1px;content:var(--tw-content)}.before\\:nt-border-primary-foreground-alpha-100:before{border-color:var(--nv-color-primary-foreground-alpha-100);content:var(--tw-content)}.before\\:nt-border-secondary-foreground-alpha-100:before{border-color:var(--nv-color-secondary-foreground-alpha-100);content:var(--tw-content)}.before\\:nt-bg-dev-stripes-gradient:before{background-image:repeating-linear-gradient(135deg,oklch(from var(--nv-color-stripes) l c h/.1) 25%,oklch(from var(--nv-color-stripes) l c h/.1) 50%,oklch(from var(--nv-color-stripes) l c h/.2) 50%,oklch(from var(--nv-color-stripes) l c h/.2) 75%);content:var(--tw-content)}.before\\:nt-bg-\\[length\\:var\\(--stripes-size\\)_var\\(--stripes-size\\)\\]:before{background-size:var(--stripes-size) var(--stripes-size);content:var(--tw-content)}.before\\:nt-content-\\[\\"\\"\\]:before{--tw-content:"";content:var(--tw-content)}.before\\:\\[mask-image\\:linear-gradient\\(transparent_0\\%\\2c black\\)\\]:before{content:var(--tw-content);-webkit-mask-image:linear-gradient(#0000,#000);mask-image:linear-gradient(#0000,#000)}.after\\:nt-absolute:after{content:var(--tw-content);position:absolute}.after\\:nt-inset-0:after{content:var(--tw-content);inset:0}.after\\:-nt-top-12:after{content:var(--tw-content);top:-3rem}.after\\:nt-bottom-0:after{bottom:0;content:var(--tw-content)}.after\\:nt-left-0:after{content:var(--tw-content);left:0}.after\\:nt-left-0\\.5:after{content:var(--tw-content);left:.125rem}.after\\:nt-top-0\\.5:after{content:var(--tw-content);top:.125rem}.after\\:nt-size-3:after{content:var(--tw-content);height:.75rem;width:.75rem}.after\\:nt-h-\\[2px\\]:after{content:var(--tw-content);height:2px}.after\\:nt-w-full:after{content:var(--tw-content);width:100%}.after\\:nt-rounded-full:after{border-radius:var(--nv-radius-full);content:var(--tw-content)}.after\\:nt-rounded-lg:after{border-radius:var(--nv-radius-lg);content:var(--tw-content)}.after\\:nt-rounded-md:after{border-radius:var(--nv-radius-md);content:var(--tw-content)}.after\\:nt-rounded-xl:after{border-radius:var(--nv-radius-xl);content:var(--tw-content)}.after\\:nt-border-b-2:after{border-bottom-width:2px;content:var(--tw-content)}.after\\:nt-border-b-primary:after{border-bottom-color:var(--nv-color-primary);content:var(--tw-content)}.after\\:nt-border-b-transparent:after{border-bottom-color:#0000;content:var(--tw-content)}.after\\:nt-bg-background:after{background-color:var(--nv-color-background);content:var(--tw-content)}.after\\:nt-bg-\\[linear-gradient\\(180deg\\2c transparent\\2c oklch\\(from_var\\(--nv-color-background\\)_l_c_h_\\/_0\\.9\\)_55\\%\\2c transparent\\)\\]:after{background-image:linear-gradient(180deg,#0000,oklch(from var(--nv-color-background) l c h/.9) 55%,#0000);content:var(--tw-content)}.after\\:nt-bg-\\[linear-gradient\\(180deg\\2c transparent\\2c oklch\\(from_var\\(--nv-color-stripes\\)_l_c_h_\\/_0\\.07\\)_55\\%\\2c transparent\\)\\2c linear-gradient\\(180deg\\2c transparent\\2c oklch\\(from_var\\(--nv-color-background\\)_l_c_h_\\/_0\\.9\\)_55\\%\\2c transparent\\)\\]:after{background-image:linear-gradient(180deg,#0000,oklch(from var(--nv-color-stripes) l c h/.07) 55%,#0000),linear-gradient(180deg,#0000,oklch(from var(--nv-color-background) l c h/.9) 55%,#0000);content:var(--tw-content)}.after\\:nt-bg-gradient-to-b:after{background-image:linear-gradient(to bottom,var(--tw-gradient-stops));content:var(--tw-content)}.after\\:nt-from-primary-foreground-alpha-50:after{content:var(--tw-content);--tw-gradient-from:var(--nv-color-primary-foreground-alpha-50) var(--tw-gradient-from-position);--tw-gradient-to:#fff0 var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-from),var(--tw-gradient-to)}.after\\:nt-from-secondary-foreground-alpha-50:after{content:var(--tw-content);--tw-gradient-from:var(--nv-color-secondary-foreground-alpha-50) var(--tw-gradient-from-position);--tw-gradient-to:#fff0 var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-from),var(--tw-gradient-to)}.after\\:nt-to-transparent:after{content:var(--tw-content);--tw-gradient-to:#0000 var(--tw-gradient-to-position)}.after\\:nt-opacity-0:after{content:var(--tw-content);opacity:0}.after\\:nt-transition-all:after{content:var(--tw-content);transition-duration:.15s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1)}.after\\:nt-transition-opacity:after{content:var(--tw-content);transition-duration:.15s;transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1)}.after\\:nt-duration-200:after{transition-duration:.2s}.after\\:nt-content-\\[\\"\\"\\]:after,.after\\:nt-content-\\[\\'\\'\\]:after{--tw-content:"";content:var(--tw-content)}.after\\:nt-duration-200:after{animation-duration:.2s;content:var(--tw-content)}.hover\\:nt-bg-neutral-alpha-100:hover{background-color:var(--nv-color-neutral-alpha-100)}.hover\\:nt-bg-neutral-alpha-50:hover{background-color:var(--nv-color-neutral-alpha-50)}.hover\\:nt-bg-primary-600:hover{background-color:var(--nv-color-primary-600)}.hover\\:nt-bg-primary-alpha-25:hover{background-color:var(--nv-color-primary-alpha-25)}.hover\\:nt-bg-primary-alpha-400:hover{background-color:var(--nv-color-primary-alpha-400)}.hover\\:nt-text-foreground-alpha-800:hover{color:var(--nv-color-foreground-alpha-800)}.before\\:hover\\:\\[animation-play-state\\:running\\]:hover:before{animation-play-state:running;content:var(--tw-content)}.hover\\:after\\:nt-opacity-100:hover:after{content:var(--tw-content);opacity:1}.focus\\:nt-outline-none:focus{outline:2px solid #0000;outline-offset:2px}.focus-visible\\:nt-rounded-lg:focus-visible{border-radius:var(--nv-radius-lg)}.focus-visible\\:nt-rounded-md:focus-visible{border-radius:var(--nv-radius-md)}.focus-visible\\:nt-rounded-xl:focus-visible{border-radius:var(--nv-radius-xl)}.focus-visible\\:nt-bg-neutral-alpha-50:focus-visible{background-color:var(--nv-color-neutral-alpha-50)}.focus-visible\\:nt-outline-none:focus-visible{outline:2px solid #0000;outline-offset:2px}.focus-visible\\:nt-ring-2:focus-visible{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.focus-visible\\:nt-ring-primary:focus-visible{--tw-ring-color:var(--nv-color-primary)}.focus-visible\\:nt-ring-ring:focus-visible{--tw-ring-color:var(--nv-color-ring)}.focus-visible\\:nt-ring-offset-2:focus-visible{--tw-ring-offset-width:2px}.disabled\\:nt-pointer-events-none:disabled{pointer-events:none}.disabled\\:nt-opacity-20:disabled{opacity:.2}.disabled\\:nt-opacity-50:disabled{opacity:.5}.nt-group:focus-within .group-focus-within\\:nt-opacity-100,.nt-group:hover .group-hover\\:nt-opacity-100{opacity:1}.nt-peer:checked~.peer-checked\\:nt-border-neutral-alpha-400{border-color:var(--nv-color-neutral-alpha-400)}.nt-peer:checked~.peer-checked\\:nt-bg-primary{background-color:var(--nv-color-primary)}.nt-peer:checked~.peer-checked\\:nt-shadow-none{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.nt-peer:checked~.peer-checked\\:after\\:nt-translate-x-full:after{content:var(--tw-content);--tw-translate-x:100%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.nt-peer:checked~.peer-checked\\:after\\:nt-border-background:after{border-color:var(--nv-color-background);content:var(--tw-content)}.data-\\[open\\=true\\]\\:nt-rotate-180[data-open=true]{--tw-rotate:180deg}.data-\\[open\\=true\\]\\:nt-rotate-180[data-open=true],.data-\\[open\\=true\\]\\:nt-transform[data-open=true]{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.data-\\[disabled\\=true\\]\\:nt-text-foreground-alpha-400[data-disabled=true]{color:var(--nv-color-foreground-alpha-400)}.data-\\[disabled\\=true\\]\\:nt-text-foreground-alpha-600[data-disabled=true]{color:var(--nv-color-foreground-alpha-600)}.data-\\[state\\=active\\]\\:nt-text-foreground[data-state=active]{color:var(--nv-color-foreground)}.data-\\[state\\=active\\]\\:after\\:nt-border-b-2[data-state=active]:after{border-bottom-width:2px;content:var(--tw-content)}.data-\\[state\\=active\\]\\:after\\:nt-border-primary[data-state=active]:after{border-color:var(--nv-color-primary);content:var(--tw-content)}.data-\\[state\\=active\\]\\:after\\:nt-opacity-100[data-state=active]:after{content:var(--tw-content);opacity:1}.\\[\\&\\:not\\(\\:first-child\\)\\]\\:nt-border-t:not(:first-child){border-top-width:1px}.\\[\\&_svg\\]\\:nt-pointer-events-none svg{pointer-events:none}.\\[\\&_svg\\]\\:nt-shrink-0 svg{flex-shrink:0}`;
var appearanceKeys = [
  // Primitives
  "button",
  "input",
  "icon",
  "badge",
  "popoverContent",
  "popoverTrigger",
  "popoverClose",
  "dropdownContent",
  "dropdownTrigger",
  "dropdownItem",
  "dropdownItemLabel",
  "dropdownItemLabelContainer",
  "dropdownItemLeft__icon",
  "dropdownItemRight__icon",
  "dropdownItem__icon",
  "collapsible",
  "tooltipContent",
  "tooltipTrigger",
  "datePicker",
  "datePickerGrid",
  "datePickerGridRow",
  "datePickerGridCell",
  "datePickerGridCellTrigger",
  "datePickerTrigger",
  "datePickerGridHeader",
  "datePickerControl",
  "datePickerControlPrevTrigger",
  "datePickerControlNextTrigger",
  "datePickerControlPrevTrigger__icon",
  "datePickerControlNextTrigger__icon",
  "datePickerCalendar",
  "datePickerHeaderMonth",
  "datePickerCalendarDay__button",
  "timePicker",
  "timePicker__hourSelect",
  "timePicker__minuteSelect",
  "timePicker__periodSelect",
  "timePicker__separator",
  "timePickerHour__input",
  "timePickerMinute__input",
  "snoozeDatePicker",
  "snoozeDatePicker__actions",
  "snoozeDatePickerCancel__button",
  "snoozeDatePickerApply__button",
  "snoozeDatePicker__timePickerContainer",
  "snoozeDatePicker__timePickerLabel",
  "back__button",
  "skeletonText",
  "skeletonAvatar",
  "skeletonSwitch",
  "skeletonSwitchThumb",
  "tabsRoot",
  "tabsList",
  "tabsContent",
  "tabsTrigger",
  "dots",
  // General
  "root",
  "bellIcon",
  "bellContainer",
  "bellDot",
  "preferences__button",
  "preferencesContainer",
  "inboxHeader",
  "loading",
  // Inbox
  "inboxContent",
  "inbox__popoverTrigger",
  "inbox__popoverContent",
  // Notifications
  "notificationListContainer",
  "notificationList",
  "notificationListEmptyNoticeContainer",
  "notificationListEmptyNoticeOverlay",
  "notificationListEmptyNoticeIcon",
  "notificationListEmptyNotice",
  "notificationList__skeleton",
  "notificationList__skeletonContent",
  "notificationList__skeletonItem",
  "notificationList__skeletonAvatar",
  "notificationList__skeletonText",
  "notificationListNewNotificationsNotice__button",
  "notification",
  "notificationContent",
  "notificationTextContainer",
  "notificationDot",
  "notificationSubject",
  "notificationSubject__strong",
  "notificationBody",
  "notificationBody__strong",
  "notificationBodyContainer",
  "notificationImage",
  "notificationImageLoadingFallback",
  "notificationDate",
  "notificationDateActionsContainer",
  "notificationDefaultActions",
  "notificationCustomActions",
  "notificationPrimaryAction__button",
  "notificationSecondaryAction__button",
  "notificationRead__button",
  "notificationUnread__button",
  "notificationArchive__button",
  "notificationUnarchive__button",
  "notificationSnooze__button",
  "notificationUnsnooze__button",
  "notificationRead__icon",
  "notificationUnread__icon",
  "notificationArchive__icon",
  "notificationUnarchive__icon",
  "notificationSnooze__icon",
  "notificationUnsnooze__icon",
  // Notifications tabs
  "notificationsTabs__tabsRoot",
  "notificationsTabs__tabsList",
  "notificationsTabs__tabsContent",
  "notificationsTabs__tabsTrigger",
  "notificationsTabsTriggerLabel",
  "notificationsTabsTriggerCount",
  // Inbox status
  "inboxStatus__title",
  "inboxStatus__dropdownTrigger",
  "inboxStatus__dropdownContent",
  "inboxStatus__dropdownItem",
  "inboxStatus__dropdownItemLabel",
  "inboxStatus__dropdownItemLabelContainer",
  "inboxStatus__dropdownItemLeft__icon",
  "inboxStatus__dropdownItemRight__icon",
  "inboxStatus__dropdownItem__icon",
  "inboxStatus__dropdownItemCheck__icon",
  // More actions
  "moreActionsContainer",
  "moreActions__dropdownTrigger",
  "moreActions__dropdownContent",
  "moreActions__dropdownItem",
  "moreActions__dropdownItemLabel",
  "moreActions__dropdownItemLeft__icon",
  "moreActions__dots",
  // More tabs
  "moreTabs__button",
  "moreTabs__icon",
  "moreTabs__dropdownTrigger",
  "moreTabs__dropdownContent",
  "moreTabs__dropdownItem",
  "moreTabs__dropdownItemLabel",
  "moreTabs__dropdownItemRight__icon",
  // workflow
  "workflowContainer",
  "workflowLabel",
  "workflowLabelHeader",
  "workflowLabelContainer",
  "workflowContainerDisabledNotice",
  "workflowLabelDisabled__icon",
  "workflowContainerRight__icon",
  "workflowArrow__icon",
  "workflowDescription",
  // channel
  "channelContainer",
  "channelIconContainer",
  "channel__icon",
  "channelsContainerCollapsible",
  "channelsContainer",
  "channelLabel",
  "channelLabelContainer",
  "channelName",
  "channelSwitchContainer",
  "channelSwitch",
  "channelSwitchThumb",
  // Preferences Header
  "preferencesHeader",
  "preferencesHeader__back__button",
  "preferencesHeader__back__button__icon",
  "preferencesHeader__title",
  "preferencesHeader__icon",
  // Preferences Loading
  "preferencesListEmptyNoticeContainer",
  "preferencesListEmptyNotice",
  "preferencesList__skeleton",
  "preferencesList__skeletonContent",
  "preferencesList__skeletonItem",
  "preferencesList__skeletonIcon",
  "preferencesList__skeletonSwitch",
  "preferencesList__skeletonSwitchThumb",
  "preferencesList__skeletonText",
  // Notification Snooze
  "notificationSnooze__dropdownContent",
  "notificationSnooze__dropdownItem",
  "notificationSnooze__dropdownItem__icon",
  "notificationSnoozeCustomTime_popoverContent",
  // Notification Delivered At
  "notificationDeliveredAt__badge",
  "notificationDeliveredAt__icon",
  "notificationSnoozedUntil__icon",
  // Text formatting
  "strong"
];
var defaultLocalization = {
  locale: "en-US",
  "inbox.filters.dropdownOptions.unread": "Unread only",
  "inbox.filters.dropdownOptions.default": "Unread & read",
  "inbox.filters.dropdownOptions.archived": "Archived",
  "inbox.filters.dropdownOptions.snoozed": "Snoozed",
  "inbox.filters.labels.unread": "Unread",
  "inbox.filters.labels.default": "Inbox",
  "inbox.filters.labels.archived": "Archived",
  "inbox.filters.labels.snoozed": "Snoozed",
  "notifications.emptyNotice": "Quiet for now. Check back later.",
  "notifications.actions.readAll": "Mark all as read",
  "notifications.actions.archiveAll": "Archive all",
  "notifications.actions.archiveRead": "Archive read",
  "notifications.newNotifications": ({ notificationCount }) => `${notificationCount > 99 ? "99+" : notificationCount} new ${notificationCount === 1 ? "notification" : "notifications"}`,
  "notification.actions.read.tooltip": "Mark as read",
  "notification.actions.unread.tooltip": "Mark as unread",
  "notification.actions.archive.tooltip": "Archive",
  "notification.actions.unarchive.tooltip": "Unarchive",
  "notification.actions.snooze.tooltip": "Snooze",
  "notification.actions.unsnooze.tooltip": "Unsnooze",
  "notification.snoozedUntil": "Snoozed until",
  "preferences.title": "Preferences",
  "preferences.emptyNotice": "No notification specific preferences yet.",
  "preferences.global": "Global Preferences",
  "preferences.workflow.disabled.notice": "Contact admin to enable subscription management for this critical notification.",
  "preferences.workflow.disabled.tooltip": "Contact admin to edit",
  "snooze.datePicker.timePickerLabel": "Time",
  "snooze.datePicker.apply": "Apply",
  "snooze.datePicker.cancel": "Cancel",
  "snooze.options.anHourFromNow": "An hour from now",
  "snooze.datePicker.pastDateTooltip": "Selected time must be at least 3 minutes in the future",
  "snooze.datePicker.noDateSelectedTooltip": "Please select a date",
  "snooze.datePicker.exceedingLimitTooltip": ({ days }) => `Selected time cannot exceed ${days === 1 ? "24 hours" : `${days} days`} from now`,
  "snooze.options.customTime": "Custom time...",
  "snooze.options.inOneDay": "Tomorrow",
  "snooze.options.inOneWeek": "Next week"
};
var [dynamicLocalization, setDynamicLocalization] = createSignal({});
var defaultVariables = {
  colorPrimary: "#7D52F4",
  colorPrimaryForeground: "white",
  colorSecondary: "#FFFFFF",
  colorSecondaryForeground: "#646464",
  colorCounter: "#FB3748",
  colorCounterForeground: "white",
  colorBackground: "#FCFCFC",
  colorRing: "#E1E4EA",
  colorForeground: "#1A1523",
  colorNeutral: "#525252",
  colorShadow: "rgb(0,0,0)",
  fontSize: "1rem",
  borderRadius: "0.375rem",
  colorStripes: "#FF9A68"
};
var DEFAULT_TARGET = "_blank";
var DEFAULT_REFERRER = "noopener noreferrer";
function createInfiniteScroll(fetcher, options) {
  const [data2, setData] = createSignal([]);
  const [initialLoading, setInitialLoading] = createSignal(true);
  const [after, setAfter] = createSignal(void 0);
  const [end, setEnd] = createSignal(false);
  const [contents, { mutate, refetch }] = createResource(
    () => ({ trigger: true, after: after() }),
    (params) => fetcher(params.after)
  );
  let observedElement = null;
  let io = null;
  onMount(() => {
    io = new IntersectionObserver(
      (entries) => {
        var _a;
        const entry = entries[0];
        if (entry && entry.isIntersecting && !end() && !contents.loading) {
          const data22 = (_a = contents.latest) == null ? void 0 : _a.data;
          if (data22) {
            setAfter(data22[data22.length - 1][options.paginationField]);
          }
        }
      },
      {
        threshold: 0.1
      }
    );
    if (observedElement && io) {
      io.observe(observedElement);
    }
    onCleanup(() => {
      io == null ? void 0 : io.disconnect();
      io = null;
    });
  });
  createEffect(() => {
    if (contents.loading) return;
    const content = contents.latest;
    if (!content) return;
    setInitialLoading(false);
    batch(() => {
      if (!content.hasMore) setEnd(true);
      setData(content.data);
      requestAnimationFrame(() => {
        checkVisibilityAndLoadMore();
      });
    });
  });
  const checkVisibilityAndLoadMore = () => {
    if (observedElement && !end() && !contents.loading) {
      const observer = new IntersectionObserver(
        (entries) => {
          var _a;
          const entry = entries[0];
          if (entry.isIntersecting) {
            const data22 = (_a = contents.latest) == null ? void 0 : _a.data;
            if (data22) {
              setAfter(data22[data22.length - 1][options.paginationField]);
            }
          }
          observer.disconnect();
        },
        {
          threshold: [0.1]
        }
      );
      observer.observe(observedElement);
      onCleanup(() => {
        observer.disconnect();
      });
    }
  };
  const setEl = (el) => {
    if (io && observedElement) {
      io.unobserve(observedElement);
    }
    observedElement = el;
    if (io && el) {
      io.observe(el);
    }
    onCleanup(() => {
      if (io && el) io.unobserve(el);
    });
  };
  const reset2 = () => __async(this, null, function* () {
    setData([]);
    setInitialLoading(true);
    setEnd(false);
    if (after() !== void 0) {
      setAfter(void 0);
    } else {
      yield refetch();
    }
  });
  return [
    data2,
    {
      initialLoading,
      setEl,
      after,
      end,
      mutate,
      reset: reset2
    }
  ];
}
var DEFAULT_LOCALE = "en-US";
var SECONDS = {
  inMinute: 60,
  inHour: 3600,
  inDay: 86400,
  inWeek: 604800,
  inMonth: 2592e3
};
function formatToRelativeTime({
  fromDate,
  locale = DEFAULT_LOCALE,
  toDate = /* @__PURE__ */ new Date()
}) {
  const elapsed = toDate.getTime() - fromDate.getTime();
  const formatter = new Intl.RelativeTimeFormat(locale, { style: "narrow" });
  const diffInSeconds = Math.floor(elapsed / 1e3);
  if (Math.abs(diffInSeconds) < SECONDS.inMinute) {
    return "Just now";
  } else if (Math.abs(diffInSeconds) < SECONDS.inHour) {
    return formatter.format(Math.floor(-diffInSeconds / SECONDS.inMinute), "minute");
  } else if (Math.abs(diffInSeconds) < SECONDS.inDay) {
    return formatter.format(Math.floor(-diffInSeconds / SECONDS.inHour), "hour");
  } else if (Math.abs(diffInSeconds) < SECONDS.inMonth) {
    return formatter.format(Math.floor(-diffInSeconds / SECONDS.inDay), "day");
  } else {
    return new Intl.DateTimeFormat(locale, { month: "short", day: "numeric" }).format(fromDate);
  }
}
function formatSnoozedUntil({ untilDate, locale = DEFAULT_LOCALE }) {
  const remaining = untilDate.getTime() - (/* @__PURE__ */ new Date()).getTime();
  const diffInSeconds = Math.floor(remaining / 1e3);
  if (diffInSeconds < 0) {
    return "soon";
  }
  if (diffInSeconds < SECONDS.inMinute) {
    return "a moment";
  } else if (diffInSeconds < SECONDS.inHour) {
    const minutes = Math.floor(diffInSeconds / SECONDS.inMinute);
    return `${minutes} ${minutes === 1 ? "minute" : "minutes"}`;
  } else if (diffInSeconds < SECONDS.inDay) {
    const hours = Math.floor(diffInSeconds / SECONDS.inHour);
    return `${hours} ${hours === 1 ? "hour" : "hours"}`;
  } else if (diffInSeconds < SECONDS.inWeek) {
    const days = Math.floor(diffInSeconds / SECONDS.inDay);
    return `${days} ${days === 1 ? "day" : "days"}`;
  } else {
    return new Intl.DateTimeFormat(locale, { month: "short", day: "numeric" }).format(untilDate);
  }
}
var twMerge2 = extendTailwindMerge({
  prefix: "nt-"
});
var publicFacingTwMerge = extendTailwindMerge({});
function cn(...inputs) {
  return twMerge2(clsx_default(inputs));
}
function generateRandomString(length2) {
  const characters = "abcdefghijklmnopqrstuvwxyz";
  let result = "";
  const charactersLength = characters.length;
  for (let i2 = 0; i2 < length2; i2 += 1) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
function generateUniqueRandomString(set, length2) {
  let randomString;
  do {
    randomString = generateRandomString(length2);
  } while (set.has(randomString));
  return randomString;
}
function cssObjectToString(styles) {
  return Object.entries(styles).map(([key, value2]) => {
    const kebabKey = key.replace(/([A-Z])/g, "-$1").toLowerCase();
    return `${kebabKey}: ${value2};`;
  }).join(" ");
}
function createClassAndRuleFromCssString(classNameSet, styles) {
  const className2 = `novu-css-${generateUniqueRandomString(classNameSet, 8)}`;
  const rule = `.${className2} { ${styles} }`;
  classNameSet.add(className2);
  return { className: className2, rule };
}
var shades = [25, 50, 100, 200, 300, 400, 500, 600, 700, 800, 900];
function generateDefaultColor(props) {
  const cssVariableDefaultRule = `.${props.id} { --nv-${props.key}: oklch(from ${props.color} l c h); }`;
  return cssVariableDefaultRule;
}
function generateSolidShadeRulesFromColor({ color, key, id }) {
  const rules = [];
  const adjustLightness = (factor) => {
    if (factor >= 0) {
      return `min(1, calc(l + ${factor} * (1 - l)))`;
    } else {
      return `max(0, calc(l * (1 + ${factor})))`;
    }
  };
  const lightnessOffsets = {
    25: adjustLightness(0.475),
    50: adjustLightness(0.45),
    100: adjustLightness(0.4),
    200: adjustLightness(0.3),
    300: adjustLightness(0.2),
    400: adjustLightness(0.1),
    500: "l",
    600: adjustLightness(-0.1),
    700: adjustLightness(-0.2),
    800: adjustLightness(-0.3),
    900: adjustLightness(-0.4)
  };
  shades.forEach((shade) => {
    const newLightness = lightnessOffsets[shade];
    const cssVariableRule = `.${id} { --nv-${key}-${shade}: oklch(from ${color} ${newLightness} c h); }`;
    rules.push(cssVariableRule);
  });
  return rules;
}
function generateAlphaShadeRulesFromColor({ color, key, id }) {
  const rules = [];
  const alphaMap = {
    25: 0.025,
    50: 0.05,
    100: 0.1,
    200: 0.2,
    300: 0.3,
    400: 0.4,
    500: 0.5,
    600: 0.6,
    700: 0.7,
    800: 0.8,
    900: 0.9
  };
  Object.entries(alphaMap).forEach(([shade, alpha]) => {
    const cssVariableAlphaRule = `.${id} { --nv-${key}-${shade}: oklch(from ${color} l c h / ${alpha}); }`;
    rules.push(cssVariableAlphaRule);
  });
  return rules;
}
function generateFontSizeRules(props) {
  const { id, baseFontSize } = props;
  const sizeRatios = {
    xs: 0.65625,
    sm: 0.765625,
    base: 0.875,
    lg: 0.984375,
    xl: 1.09375,
    "2xl": 1.3125,
    "3xl": 1.640625,
    "4xl": 1.96875
  };
  const rules = [];
  Object.entries(sizeRatios).forEach(([key, ratio]) => {
    const size2 = `calc(${baseFontSize} * ${ratio})`;
    const lineHeight = `calc(${baseFontSize} * ${ratio} * 1.33)`;
    const cssVariableRule = `.${id} { --nv-font-size-${key}: ${size2}; --nv-line-height-${key}: ${lineHeight}; }`;
    rules.push(cssVariableRule);
  });
  return rules;
}
function generateBorderRadiusRules(props) {
  const { id, baseRadius } = props;
  const radiusRatios = {
    none: 0,
    xs: 0.333,
    sm: 0.667,
    md: 1,
    lg: 1.333,
    xl: 2,
    "2xl": 2.667,
    "3xl": 4,
    full: 9999
  };
  const rules = [];
  Object.entries(radiusRatios).forEach(([key, ratio]) => {
    const value2 = key === "none" ? "0px" : key === "full" ? "9999px" : `calc(${baseRadius} * ${ratio})`;
    const cssVariableRule = `.${id} { --nv-radius-${key}: ${value2}; }`;
    rules.push(cssVariableRule);
  });
  return rules;
}
var parseVariables = (variables, id) => {
  const rules = [
    generateDefaultColor({ color: variables.colorBackground, key: "color-background", id }),
    generateDefaultColor({ color: variables.colorForeground, key: "color-foreground", id }),
    generateDefaultColor({ color: variables.colorPrimary, key: "color-primary", id }),
    generateDefaultColor({ color: variables.colorPrimaryForeground, key: "color-primary-foreground", id }),
    generateDefaultColor({ color: variables.colorSecondary, key: "color-secondary", id }),
    generateDefaultColor({ color: variables.colorSecondaryForeground, key: "color-secondary-foreground", id }),
    generateDefaultColor({ color: variables.colorCounter, key: "color-counter", id }),
    generateDefaultColor({ color: variables.colorCounterForeground, key: "color-counter-foreground", id }),
    generateDefaultColor({ color: variables.colorShadow, key: "color-shadow", id }),
    generateDefaultColor({ color: variables.colorRing, key: "color-ring", id }),
    generateDefaultColor({ color: variables.colorStripes, key: "color-stripes", id }),
    ...generateAlphaShadeRulesFromColor({ color: variables.colorBackground, key: "color-background-alpha", id }),
    ...generateAlphaShadeRulesFromColor({ color: variables.colorForeground, key: "color-foreground-alpha", id }),
    ...generateSolidShadeRulesFromColor({ color: variables.colorPrimary, key: "color-primary", id }),
    ...generateAlphaShadeRulesFromColor({ color: variables.colorPrimary, key: "color-primary-alpha", id }),
    ...generateAlphaShadeRulesFromColor({
      color: variables.colorPrimaryForeground,
      key: "color-primary-foreground-alpha",
      id
    }),
    ...generateSolidShadeRulesFromColor({ color: variables.colorSecondary, key: "color-secondary", id }),
    ...generateAlphaShadeRulesFromColor({ color: variables.colorSecondary, key: "color-secondary-alpha", id }),
    ...generateAlphaShadeRulesFromColor({
      color: variables.colorSecondaryForeground,
      key: "color-secondary-foreground-alpha",
      id
    }),
    ...generateAlphaShadeRulesFromColor({ color: variables.colorNeutral, key: "color-neutral-alpha", id }),
    ...generateFontSizeRules({ id, baseFontSize: variables.fontSize }),
    ...generateBorderRadiusRules({ id, baseRadius: variables.borderRadius })
  ];
  return rules;
};
var parseElements = (elements) => {
  const elementsStyleData = [];
  const generatedClassNames = /* @__PURE__ */ new Set();
  for (const key in elements) {
    if (elements.hasOwnProperty(key)) {
      const value2 = elements[key];
      if (typeof value2 === "object") {
        const cssString = cssObjectToString(value2);
        const { className: className2, rule } = createClassAndRuleFromCssString(generatedClassNames, cssString);
        elementsStyleData.push({ key, rule, className: className2 });
      }
    }
  }
  const sortedElementsStyleData = elementsStyleData.sort((a, b) => {
    const countA = (a.key.match(/__/g) || []).length;
    const countB = (b.key.match(/__/g) || []).length;
    return countA - countB;
  });
  return sortedElementsStyleData;
};
var getTagsFromTab = (tab) => {
  var _a;
  return ((_a = tab == null ? void 0 : tab.filter) == null ? void 0 : _a.tags) || (tab == null ? void 0 : tab.value) || [];
};
var useStyle = () => {
  const appearance = useAppearance();
  const [isServer2, setIsServer] = createSignal(true);
  onMount(() => {
    setIsServer(false);
  });
  const styleFuncMemo = createMemo(() => (appearanceKey, className2) => {
    const appearanceKeyParts = appearanceKey.split("__");
    let finalAppearanceKeys = [];
    for (let i2 = 0; i2 < appearanceKeyParts.length; i2 += 1) {
      const accumulated = appearanceKeyParts.slice(i2).join("__");
      if (appearanceKeys.includes(accumulated)) {
        finalAppearanceKeys.push(accumulated);
      }
    }
    const classes = (className2 == null ? void 0 : className2.split(/\s+/).map((className22) => className22.replace(/^nv-/, ""))) || [];
    const appearanceKeysInClasses = classes.filter(
      (className22) => appearanceKeys.includes(className22)
    );
    finalAppearanceKeys = Array.from(
      /* @__PURE__ */ new Set([...finalAppearanceKeys, ...appearanceKeysInClasses])
    );
    finalAppearanceKeys.sort((a, b) => {
      const countA = (a.match(/__/g) || []).length;
      const countB = (b.match(/__/g) || []).length;
      return countB - countA;
    });
    const finalClassName = classes.filter((className22) => !finalAppearanceKeys.includes(className22)).join(" ");
    let appearanceClassnames = [];
    const reversedFinalAppearanceKeys = finalAppearanceKeys.reverse();
    for (let i2 = 0; i2 < reversedFinalAppearanceKeys.length; i2 += 1) {
      if (typeof appearance.elements()[reversedFinalAppearanceKeys[i2]] === "string") {
        appearanceClassnames.push(appearance.elements()[reversedFinalAppearanceKeys[i2]]);
      }
    }
    appearanceClassnames = [publicFacingTwMerge(appearanceClassnames)];
    const cssInJsClasses = !!finalAppearanceKeys.length && !isServer2() ? finalAppearanceKeys.map((appKey) => appearance.appearanceKeyToCssInJsClass[appKey]) : [];
    return cn(
      ...finalAppearanceKeys.map((key) => `nv-${key}`),
      "🔔",
      finalClassName,
      // default styles
      appearanceClassnames,
      ...cssInJsClasses
    );
  });
  return styleFuncMemo();
};
function useUncontrolledState(props) {
  const [uncontrolledValue, setUncontrolledValue] = createSignal(!!props.fallbackValue);
  if (props.value !== void 0) {
    const accessor = () => !!props.value;
    return [accessor, setUncontrolledValue];
  }
  return [uncontrolledValue, setUncontrolledValue];
}
var AppearanceContext = createContext(void 0);
var AppearanceProvider = (props) => {
  const [store, setStore] = createStore({
    appearanceKeyToCssInJsClass: {}
  });
  const [styleElement, setStyleElement] = createSignal(null);
  const [elementRules, setElementRules] = createSignal([]);
  const [variableRules, setVariableRules] = createSignal([]);
  const themes = createMemo(() => {
    var _a, _b, _c;
    return Array.isArray((_a = props.appearance) == null ? void 0 : _a.baseTheme) ? ((_b = props.appearance) == null ? void 0 : _b.baseTheme) || [] : [((_c = props.appearance) == null ? void 0 : _c.baseTheme) || {}];
  });
  const id = () => props.id;
  const variables = () => {
    var _a;
    return ((_a = props.appearance) == null ? void 0 : _a.variables) || {};
  };
  const animations = () => {
    var _a, _b;
    return (_b = (_a = props.appearance) == null ? void 0 : _a.animations) != null ? _b : true;
  };
  const allElements = createMemo(() => {
    var _a;
    const baseElements = themes().reduce((acc, obj) => __spreadValues(__spreadValues({}, acc), obj.elements || {}), {});
    return __spreadValues(__spreadValues({}, baseElements), ((_a = props.appearance) == null ? void 0 : _a.elements) || {});
  });
  onMount(() => {
    const el = document.getElementById(props.id);
    if (el) {
      setStyleElement(el);
      return;
    }
    const styleEl = document.createElement("style");
    styleEl.id = props.id;
    document.head.appendChild(styleEl);
    setStyleElement(styleEl);
    onCleanup(() => {
      const element = document.getElementById(props.id);
      if (element) {
        element.remove();
      }
    });
  });
  createEffect(() => {
    var _a;
    const styleEl = styleElement();
    if (!styleEl) {
      return;
    }
    const baseVariables = __spreadValues(__spreadValues({}, defaultVariables), themes().reduce((acc, obj) => __spreadValues(__spreadValues({}, acc), obj.variables || {}), {}));
    setVariableRules(parseVariables(__spreadValues(__spreadValues({}, baseVariables), ((_a = props.appearance) == null ? void 0 : _a.variables) || {}), props.id));
  });
  createEffect(() => {
    const styleEl = styleElement();
    if (!styleEl) {
      return;
    }
    const elementsStyleData = parseElements(allElements());
    setStore("appearanceKeyToCssInJsClass", (obj) => __spreadValues(__spreadValues({}, obj), elementsStyleData.reduce((acc, item) => {
      acc[item.key] = item.className;
      return acc;
    }, {})));
    setElementRules(elementsStyleData.map((el) => el.rule));
  });
  createEffect(() => {
    const styleEl = styleElement();
    if (!styleEl) {
      return;
    }
    styleEl.innerHTML = [...variableRules(), ...elementRules()].join(" ");
  });
  return createComponent(AppearanceContext.Provider, {
    get value() {
      return {
        elements: allElements,
        variables,
        appearanceKeyToCssInJsClass: store.appearanceKeyToCssInJsClass,
        // stores are reactive
        animations,
        id
      };
    },
    get children() {
      return props.children;
    }
  });
};
function useAppearance() {
  const context = useContext(AppearanceContext);
  if (!context) {
    throw new Error("useAppearance must be used within an AppearanceProvider");
  }
  return context;
}
var useNovuEvent = ({
  event,
  eventHandler: eventHandler2
}) => {
  const novu = useNovu();
  onMount(() => {
    const cleanup = novu.on(event, eventHandler2);
    onCleanup(() => {
      cleanup();
    });
  });
};
function requestLock(id, cb) {
  let isFulfilled = false;
  let promiseResolve;
  const promise = new Promise((resolve) => {
    promiseResolve = resolve;
  });
  navigator.locks.request(id, () => {
    if (!isFulfilled) {
      cb(id);
    }
    return promise;
  });
  return () => {
    isFulfilled = true;
    promiseResolve();
  };
}
var useBrowserTabsChannel = ({
  channelName,
  onMessage
}) => {
  const [tabsChannel] = createSignal(new BroadcastChannel(channelName));
  const postMessage = (args) => {
    const channel = tabsChannel();
    channel.postMessage(args);
  };
  onMount(() => {
    const listener = (event) => {
      onMessage(event.data);
    };
    const channel = tabsChannel();
    channel.addEventListener("message", listener);
    onCleanup(() => {
      channel.removeEventListener("message", listener);
    });
  });
  return { postMessage };
};
var useWebSocketEvent = ({
  event: webSocketEvent,
  eventHandler: onMessage
}) => {
  const novu = useNovu();
  const channelName = `nv_ws_connection:a=${novu.applicationIdentifier}:s=${novu.subscriberId}:e=${webSocketEvent}`;
  const { postMessage } = useBrowserTabsChannel({ channelName, onMessage });
  const updateReadCount = (data2) => {
    onMessage(data2);
    postMessage(data2);
  };
  onMount(() => {
    let cleanup;
    const resolveLock = requestLock(channelName, () => {
      cleanup = novu.on(webSocketEvent, updateReadCount);
    });
    onCleanup(() => {
      if (cleanup) {
        cleanup();
      }
      resolveLock();
    });
  });
};
var LocalizationContext = createContext(void 0);
var LocalizationProvider = (props) => {
  const localization = createMemo(() => {
    const _a = props.localization || {}, {
      dynamic
    } = _a, localizationObject = __objRest(_a, [
      "dynamic"
    ]);
    return __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultLocalization), dynamicLocalization()), dynamic || {}), localizationObject);
  });
  const t = (key, ...args) => {
    const value2 = localization()[key];
    if (typeof value2 === "function") {
      return value2(args[0]);
    }
    return value2;
  };
  const locale = createMemo(() => localization().locale);
  return createComponent(LocalizationContext.Provider, {
    value: {
      t,
      locale
    },
    get children() {
      return props.children;
    }
  });
};
function useLocalization() {
  const context = useContext(LocalizationContext);
  if (!context) {
    throw new Error("useLocalization must be used within an LocalizationProvider");
  }
  return context;
}
var NotificationStatus2 = ((NotificationStatus22) => {
  NotificationStatus22["UNREAD_READ"] = "unreadRead";
  NotificationStatus22["UNREAD"] = "unread";
  NotificationStatus22["ARCHIVED"] = "archived";
  NotificationStatus22["SNOOZED"] = "snoozed";
  return NotificationStatus22;
})(NotificationStatus2 || {});
var InboxContext = createContext(void 0);
var STATUS_TO_FILTER = {
  [
    "unreadRead"
    /* UNREAD_READ */
  ]: {
    archived: false,
    snoozed: false
  },
  [
    "unread"
    /* UNREAD */
  ]: {
    read: false,
    snoozed: false
  },
  [
    "archived"
    /* ARCHIVED */
  ]: {
    archived: true
  },
  [
    "snoozed"
    /* SNOOZED */
  ]: {
    snoozed: true
  }
};
var DEFAULT_LIMIT = 10;
var InboxProvider = (props) => {
  var _a;
  const [isOpened, setIsOpened] = createSignal(false);
  const [tabs, setTabs] = createSignal(props.tabs);
  const [activeTab, setActiveTab] = createSignal((_a = props.tabs[0] && props.tabs[0].label) != null ? _a : "");
  const [status, setStatus] = createSignal(
    "unreadRead"
    /* UNREAD_READ */
  );
  const [limit, setLimit] = createSignal(DEFAULT_LIMIT);
  const [filter, setFilter] = createSignal(__spreadProps(__spreadValues({}, STATUS_TO_FILTER[
    "unreadRead"
    /* UNREAD_READ */
  ]), {
    tags: props.tabs.length > 0 ? getTagsFromTab(props.tabs[0]) : []
  }));
  const [hideBranding, setHideBranding] = createSignal(false);
  const [isDevelopmentMode, setIsDevelopmentMode] = createSignal(false);
  const [maxSnoozeDurationHours, setMaxSnoozeDurationHours] = createSignal(0);
  const isSnoozeEnabled = createMemo(() => maxSnoozeDurationHours() > 0);
  const [preferencesFilter, setPreferencesFilter] = createSignal(props.preferencesFilter);
  const setNewStatus = (newStatus) => {
    setStatus(newStatus);
    setFilter((old) => __spreadProps(__spreadValues({}, STATUS_TO_FILTER[newStatus]), {
      tags: old.tags
    }));
  };
  const setNewActiveTab = (newActiveTab) => {
    const tab = tabs().find((tab2) => tab2.label === newActiveTab);
    const tags = getTagsFromTab(tab);
    if (!tags) {
      return;
    }
    setActiveTab(newActiveTab);
    setFilter((old) => __spreadProps(__spreadValues({}, old), {
      tags
    }));
  };
  const navigate = (url2, target) => {
    if (!url2) {
      return;
    }
    const isAbsoluteUrl = !url2.startsWith("/");
    if (isAbsoluteUrl) {
      window.open(url2, target != null ? target : DEFAULT_TARGET, DEFAULT_REFERRER);
      return;
    }
    if (props.routerPush) {
      props.routerPush(url2);
      return;
    }
    const fullUrl = new URL(url2, window.location.href);
    const pushState = window.history.pushState.bind(window.history);
    pushState({}, "", fullUrl);
  };
  createEffect(() => {
    var _a2;
    setTabs(props.tabs);
    const firstTab = props.tabs[0];
    const tags = getTagsFromTab(firstTab);
    setActiveTab((_a2 = firstTab == null ? void 0 : firstTab.label) != null ? _a2 : "");
    setFilter((old) => __spreadProps(__spreadValues({}, old), {
      tags
    }));
    setPreferencesFilter(props.preferencesFilter);
  });
  useNovuEvent({
    event: "session.initialize.resolved",
    eventHandler: ({
      data: data2
    }) => {
      if (!data2) {
        return;
      }
      setHideBranding(data2.removeNovuBranding);
      setIsDevelopmentMode(data2.isDevelopmentMode);
      setMaxSnoozeDurationHours(data2.maxSnoozeDurationHours);
    }
  });
  return createComponent(InboxContext.Provider, {
    value: {
      status,
      setStatus: setNewStatus,
      filter,
      tabs,
      activeTab,
      setActiveTab: setNewActiveTab,
      limit,
      setLimit,
      isOpened,
      setIsOpened,
      navigate,
      hideBranding,
      preferencesFilter,
      isDevelopmentMode,
      maxSnoozeDurationHours,
      isSnoozeEnabled
    },
    get children() {
      return props.children;
    }
  });
};
var useInboxContext = () => {
  const context = useContext(InboxContext);
  if (!context) {
    throw new Error("useInboxContext must be used within a InboxProvider");
  }
  return context;
};
var NovuContext = createContext(void 0);
function NovuProvider(props) {
  const novu = createMemo(() => props.novu || new Novu(props.options));
  return createComponent(NovuContext.Provider, {
    get value() {
      return novu();
    },
    get children() {
      return props.children;
    }
  });
}
function useNovu() {
  const context = useContext(NovuContext);
  if (!context) {
    throw new Error("useNovu must be used within a NovuProvider");
  }
  return context;
}
var MIN_AMOUNT_OF_NOTIFICATIONS = 1;
var CountContext = createContext(void 0);
var CountProvider = (props) => {
  const novu = useNovu();
  const {
    isOpened,
    tabs,
    filter,
    limit
  } = useInboxContext();
  const [totalUnreadCount, setTotalUnreadCount] = createSignal(0);
  const [unreadCounts, setUnreadCounts] = createSignal(/* @__PURE__ */ new Map());
  const [newNotificationCounts, setNewNotificationCounts] = createSignal(/* @__PURE__ */ new Map());
  const updateTabCounts = () => __async(void 0, null, function* () {
    if (tabs().length === 0) {
      return;
    }
    const filters = tabs().map((tab) => ({
      tags: getTagsFromTab(tab),
      read: false,
      archived: false,
      snoozed: false
    }));
    const {
      data: data2
    } = yield novu.notifications.count({
      filters
    });
    if (!data2) {
      return;
    }
    const newMap = /* @__PURE__ */ new Map();
    const {
      counts
    } = data2;
    for (let i2 = 0; i2 < counts.length; i2 += 1) {
      const tagsKey = createKey(counts[i2].filter.tags);
      newMap.set(tagsKey, data2 == null ? void 0 : data2.counts[i2].count);
    }
    setUnreadCounts(newMap);
  });
  onMount(() => {
    updateTabCounts();
  });
  useWebSocketEvent({
    event: "notifications.unread_count_changed",
    eventHandler: (data2) => {
      setTotalUnreadCount(data2.result);
      updateTabCounts();
    }
  });
  useNovuEvent({
    event: "session.initialize.resolved",
    eventHandler: ({
      data: data2
    }) => {
      if (!data2) {
        return;
      }
      setTotalUnreadCount(data2.totalUnreadCount);
    }
  });
  const updateNewNotificationCountsOrCache = (notification, tags) => {
    const notificationsCache = novu.notifications.cache;
    const limitValue = limit();
    const tabFilter = __spreadProps(__spreadValues({}, filter()), {
      tags,
      after: void 0,
      limit: limitValue
    });
    const hasEmptyCache = !notificationsCache.has(tabFilter);
    if (!isOpened() && hasEmptyCache) {
      return;
    }
    const cachedData = notificationsCache.getAll(tabFilter) || {
      hasMore: false,
      filter: tabFilter,
      notifications: []
    };
    const hasLessThenMinAmount = ((cachedData == null ? void 0 : cachedData.notifications.length) || 0) < MIN_AMOUNT_OF_NOTIFICATIONS;
    if (hasLessThenMinAmount) {
      notificationsCache.update(tabFilter, __spreadProps(__spreadValues({}, cachedData), {
        notifications: [notification, ...cachedData.notifications]
      }));
      return;
    }
    setNewNotificationCounts((oldMap) => {
      const tagsKey = createKey(tags);
      const newMap = new Map(oldMap);
      newMap.set(tagsKey, (oldMap.get(tagsKey) || 0) + 1);
      return newMap;
    });
  };
  useWebSocketEvent({
    event: "notifications.notification_received",
    eventHandler: (_0) => __async(void 0, [_0], function* ({
      result: notification
    }) {
      if (filter().archived || filter().snoozed) {
        return;
      }
      const tagsMap = tabs().reduce((acc, tab) => {
        const tags = getTagsFromTab(tab);
        const tagsKey = createKey(tags);
        acc.set(tagsKey, tags);
        return acc;
      }, /* @__PURE__ */ new Map());
      const uniqueTags = Array.from(tagsMap.values());
      if (uniqueTags.length > 0) {
        for (let i2 = 0; i2 < uniqueTags.length; i2 += 1) {
          const tags = uniqueTags[i2];
          const allNotifications = tags.length === 0;
          const includesAtLeastOneTag = tags.some((tag) => {
            var _a;
            return (_a = notification.tags) == null ? void 0 : _a.includes(tag);
          });
          if (!allNotifications && !includesAtLeastOneTag) {
            continue;
          }
          updateNewNotificationCountsOrCache(notification, tags);
        }
      } else {
        updateNewNotificationCountsOrCache(notification, []);
      }
    })
  });
  useWebSocketEvent({
    event: "notifications.notification_received",
    eventHandler: updateTabCounts
  });
  const resetNewNotificationCounts = (key) => {
    setNewNotificationCounts((oldMap) => {
      const newMap = new Map(oldMap);
      newMap.set(key, 0);
      return newMap;
    });
  };
  return createComponent(CountContext.Provider, {
    value: {
      totalUnreadCount,
      unreadCounts,
      newNotificationCounts,
      resetNewNotificationCounts
    },
    get children() {
      return props.children;
    }
  });
};
var createKey = (tags) => {
  return JSON.stringify({
    tags: tags != null ? tags : []
  });
};
var useTotalUnreadCount = () => {
  const context = useContext(CountContext);
  if (!context) {
    throw new Error("useTotalUnreadCount must be used within a CountProvider");
  }
  return {
    totalUnreadCount: context.totalUnreadCount
  };
};
var useNewMessagesCount = (props) => {
  const context = useContext(CountContext);
  if (!context) {
    throw new Error("useNewMessagesCount must be used within a CountProvider");
  }
  const key = createMemo(() => createKey(props.filter.tags));
  const count = createMemo(() => context.newNotificationCounts().get(key()) || 0);
  const reset2 = () => context.resetNewNotificationCounts(key());
  return {
    count,
    reset: reset2
  };
};
var useUnreadCount = (props) => {
  const context = useContext(CountContext);
  if (!context) {
    throw new Error("useUnreadCount must be used within a CountProvider");
  }
  const count = createMemo(() => context.unreadCounts().get(createKey(props.filter.tags)) || 0);
  return count;
};
var useUnreadCounts = (props) => {
  const context = useContext(CountContext);
  if (!context) {
    throw new Error("useUnreadCounts must be used within a CountProvider");
  }
  const counts = createMemo(() => props.filters.map((filter) => {
    return context.unreadCounts().get(createKey(filter.tags)) || 0;
  }));
  return counts;
};
function createFocusTrap({ element, enabled }) {
  createEffect(() => {
    const trapElement = element();
    if (!trapElement || !enabled()) return;
    const focusableElementsString = "a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]";
    const getFocusableElements = () => {
      return Array.from(trapElement.querySelectorAll(focusableElementsString)).filter(
        (el) => el.tabIndex >= 0 && !el.hasAttribute("disabled")
      );
    };
    const handleKeyDown = (event) => {
      if (event.key !== "Tab") return;
      const focusableElements2 = getFocusableElements();
      const firstFocusableElement = focusableElements2[0];
      const lastFocusableElement = focusableElements2[focusableElements2.length - 1];
      if (event.shiftKey) {
        if (document.activeElement === firstFocusableElement) {
          lastFocusableElement.focus();
          event.preventDefault();
        }
      } else {
        if (document.activeElement === lastFocusableElement) {
          firstFocusableElement.focus();
          event.preventDefault();
        }
      }
    };
    trapElement.addEventListener("keydown", handleKeyDown);
    const focusableElements = getFocusableElements();
    if (focusableElements.length > 0) {
      focusableElements[0].focus();
    }
    onCleanup(() => {
      trapElement.removeEventListener("keydown", handleKeyDown);
    });
  });
}
var useFocusTrap_default = createFocusTrap;
var FocusManagerContext = createContext(void 0);
var FocusManagerProvider = (props) => {
  const [focusTraps, setFocusTraps] = createSignal([]);
  const setActive = (element) => {
    setFocusTraps((traps) => [...traps, element]);
  };
  const removeActive = (element) => {
    setFocusTraps((traps) => traps.filter((item) => item !== element));
  };
  const active = createMemo(() => focusTraps().length ? focusTraps()[focusTraps().length - 1] : null);
  useFocusTrap_default({
    element: () => active(),
    enabled: () => true
  });
  return createComponent(FocusManagerContext.Provider, {
    value: {
      focusTraps,
      active,
      setActive,
      removeActive
    },
    get children() {
      return props.children;
    }
  });
};
function useFocusManager() {
  const context = useContext(FocusManagerContext);
  if (!context) {
    throw new Error("useFocusManager must be used within an FocusManagerProvider");
  }
  return context;
}
var _tmpl$ = template(`<div>`);
var ExternalElementRenderer = (props) => {
  let ref;
  const [local, rest] = splitProps(props, ["render"]);
  createEffect(() => {
    const unmount = local.render(ref);
    onCleanup(() => {
      unmount();
    });
  });
  return (() => {
    var _el$ = _tmpl$();
    use((el) => {
      ref = el;
    }, _el$);
    spread(_el$, rest, false, false);
    return _el$;
  })();
};
var _tmpl$2 = template(`<svg xmlns=http://www.w3.org/2000/svg fill=none viewBox="0 0 20 20"><path fill=currentColor d="M5.833 8.333L10 12.5l4.166-4.167H5.833z">`);
var ArrowDropDown = (props) => {
  return (() => {
    var _el$ = _tmpl$2();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$3 = template(`<svg viewBox="0 0 20 20"fill=none xmlns=http://www.w3.org/2000/svg><path d="M9.20425 9.99907L12.9168 13.7116L11.8563 14.7721L7.08325 9.99907L11.8563 5.22607L12.9168 6.28657L9.20425 9.99907Z"fill=currentColor>`);
var ArrowLeft = (props) => {
  return (() => {
    var _el$ = _tmpl$3();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$4 = template(`<svg viewBox="0 0 10 12"fill=none xmlns=http://www.w3.org/2000/svg><path d="M5 12C5.6875 12 6.25 11.4462 6.25 10.7692H3.75C3.75 11.4462 4.3125 12 5 12ZM8.75 8.30769V5.23077C8.75 3.34154 7.73125 1.76 5.9375 1.34154V0.923077C5.9375 0.412308 5.51875 0 5 0C4.48125 0 4.0625 0.412308 4.0625 0.923077V1.34154C2.275 1.76 1.25 3.33538 1.25 5.23077V8.30769L0 9.53846V10.1538H10V9.53846L8.75 8.30769ZM7.5 8.92308H2.5V5.23077C2.5 3.70462 3.44375 2.46154 5 2.46154C6.55625 2.46154 7.5 3.70462 7.5 5.23077V8.92308Z"fill=currentColor>`);
function Bell(props) {
  return (() => {
    var _el$ = _tmpl$4();
    spread(_el$, props, true, true);
    return _el$;
  })();
}
var _tmpl$5 = template(`<svg viewBox="0 0 10 10"fill=none xmlns=http://www.w3.org/2000/svg><path d="M0.625 9.375L2.93989 8.86059C3.5538 9.18889 4.25516 9.375 5 9.375C7.41622 9.375 9.375 7.41622 9.375 5C9.375 2.58375 7.41622 0.625 5 0.625C2.58375 0.625 0.625 2.58375 0.625 5C0.625 5.74484 0.81113 6.4462 1.13942 7.0601L0.625 9.375ZM6.50881 2.8125L6.43224 3.68761H7.1875V4.56259H6.35568L6.27912 5.43759H7.1875V6.31259H6.2026L6.12604 7.1875H5.24771L5.32423 6.31259H4.44591L4.36934 7.1875H3.49101L3.56755 6.31259H2.8125V5.43759H3.64411L3.72066 4.56259H2.8125V3.68761H3.79721L3.87377 2.8125H4.75211L4.67555 3.68761H5.55392L5.63048 2.8125H6.50881ZM4.59899 4.56259L4.52247 5.43759H5.40079L5.47736 4.56259H4.59899Z"fill=currentColor>`);
var Chat = (props) => {
  return (() => {
    var _el$ = _tmpl$5();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$6 = template(`<svg viewBox="0 0 8 6"fill=none xmlns=http://www.w3.org/2000/svg><path d="M2.99994 4.58847L7.33298 0L8 0.705765L2.99994 6L0 2.82356L0.666549 2.11779L2.99994 4.58847Z"fill=currentColor>`);
var Check = (props) => {
  return (() => {
    var _el$ = _tmpl$6();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$7 = template(`<svg xmlns=http://www.w3.org/2000/svg fill=none viewBox="0 0 20 20"><path fill=currentColor d="M5 8.333c-.917 0-1.667.75-1.667 1.667s.75 1.667 1.667 1.667c.916 0 1.666-.75 1.666-1.667S5.916 8.333 5 8.333zm10 0c-.917 0-1.667.75-1.667 1.667s.75 1.667 1.667 1.667c.916 0 1.666-.75 1.666-1.667S15.916 8.333 15 8.333zm-5 0c-.917 0-1.667.75-1.667 1.667s.75 1.667 1.667 1.667c.916 0 1.666-.75 1.666-1.667S10.916 8.333 10 8.333z">`);
var Dots = (props) => {
  return (() => {
    var _el$ = _tmpl$7();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$8 = template(`<svg viewBox="0 0 10 10"fill=none xmlns=http://www.w3.org/2000/svg><path d="M4.20703 1.875H2.8125H2.10547H1.875V2.04688V2.8125V3.60156V5.33984L0.00390625 3.95508C0.0351562 3.60156 0.216797 3.27344 0.505859 3.06055L0.9375 2.74023V1.875C0.9375 1.35742 1.35742 0.9375 1.875 0.9375H3.37109L4.3457 0.216797C4.53516 0.0761719 4.76367 0 5 0C5.23633 0 5.46484 0.0761719 5.6543 0.214844L6.62891 0.9375H8.125C8.64258 0.9375 9.0625 1.35742 9.0625 1.875V2.74023L9.49414 3.06055C9.7832 3.27344 9.96484 3.60156 9.99609 3.95508L8.125 5.33984V3.60156V2.8125V2.04688V1.875H7.89453H7.1875H5.79297H4.20508H4.20703ZM0 8.75V4.72852L4.25 7.87695C4.4668 8.03711 4.73047 8.125 5 8.125C5.26953 8.125 5.5332 8.03906 5.75 7.87695L10 4.72852V8.75C10 9.43945 9.43945 10 8.75 10H1.25C0.560547 10 0 9.43945 0 8.75ZM3.4375 3.125H6.5625C6.73438 3.125 6.875 3.26562 6.875 3.4375C6.875 3.60938 6.73438 3.75 6.5625 3.75H3.4375C3.26562 3.75 3.125 3.60938 3.125 3.4375C3.125 3.26562 3.26562 3.125 3.4375 3.125ZM3.4375 4.375H6.5625C6.73438 4.375 6.875 4.51562 6.875 4.6875C6.875 4.85938 6.73438 5 6.5625 5H3.4375C3.26562 5 3.125 4.85938 3.125 4.6875C3.125 4.51562 3.26562 4.375 3.4375 4.375Z"fill=currentColor>`);
var Email = (props) => {
  return (() => {
    var _el$ = _tmpl$8();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$9 = template(`<svg viewBox="0 0 10 12"fill=none xmlns=http://www.w3.org/2000/svg><path d="M4.99962 0.856934C4.64404 0.856934 4.35676 1.14421 4.35676 1.49979V1.88551C2.89024 2.18283 1.78533 3.48059 1.78533 5.03551V5.41318C1.78533 6.35738 1.43779 7.26943 0.810999 7.97658L0.662339 8.14332C0.493589 8.33216 0.45341 8.60336 0.555865 8.83439C0.658321 9.06542 0.889348 9.21408 1.14247 9.21408H8.85676C9.10988 9.21408 9.3389 9.06542 9.44337 8.83439C9.54783 8.60336 9.50564 8.33216 9.33689 8.14332L9.18823 7.97658C8.56145 7.26943 8.2139 6.35939 8.2139 5.41318V5.03551C8.2139 3.48059 7.10899 2.18283 5.64247 1.88551V1.49979C5.64247 1.14421 5.3552 0.856934 4.99962 0.856934ZM5.90966 10.767C6.15073 10.5259 6.28533 10.1985 6.28533 9.85693H4.99962H3.7139C3.7139 10.1985 3.8485 10.5259 4.08957 10.767C4.33064 11.008 4.6581 11.1426 4.99962 11.1426C5.34113 11.1426 5.66859 11.008 5.90966 10.767Z"fill=currentColor>`);
var InApp = (props) => {
  return (() => {
    var _el$ = _tmpl$9();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$10 = template(`<svg viewBox="0 0 10 10"fill=none xmlns=http://www.w3.org/2000/svg><path d="M2.29671 10C1.78742 10 1.39807 9.85716 1.12864 9.57149C0.862497 9.28581 0.729426 8.86623 0.729426 8.31274V2.64594H1.69543V8.29668C1.69543 8.52163 1.74964 8.69487 1.85806 8.81624C1.96978 8.93408 2.12914 8.99301 2.33614 8.99301H7.66389C7.86764 8.99301 8.02366 8.93408 8.13209 8.81624C8.24385 8.69487 8.29965 8.52163 8.29965 8.29668V2.64594H9.27059V8.31274C9.27059 8.8627 9.13591 9.28048 8.86648 9.56608C8.59705 9.85536 8.20931 10 7.70333 10H2.29671ZM3.41056 5.34543C3.29556 5.34543 3.20028 5.30438 3.1247 5.22226C3.04913 5.14015 3.01134 5.03304 3.01134 4.90089V4.72949C3.01134 4.59737 3.04749 4.49204 3.11977 4.41348C3.19535 4.33492 3.29227 4.29564 3.41056 4.29564H6.5944C6.71271 4.29564 6.80795 4.33492 6.88026 4.41348C6.95582 4.49204 6.9936 4.59737 6.9936 4.72949V4.90089C6.9936 5.03304 6.95582 5.14015 6.88026 5.22226C6.8047 5.30438 6.70939 5.34543 6.5944 5.34543H3.41056ZM1.05964 3.16014C0.724502 3.16014 0.463285 3.05301 0.276004 2.83877C0.0920037 2.62095 0 2.33172 0 1.97107V1.18907C0 0.824846 0.0952841 0.535614 0.28586 0.321373C0.476428 0.107124 0.734358 0 1.05964 0H8.94536C9.27715 0 9.53511 0.107124 9.71911 0.321373C9.90642 0.535614 10 0.824846 10 1.18907V1.97107C10 2.33172 9.90642 2.62095 9.71911 2.83877C9.53511 3.05301 9.27715 3.16014 8.94536 3.16014H1.05964ZM1.24693 2.19067H8.75805C8.87304 2.19067 8.95516 2.16211 9.00448 2.10497C9.05372 2.04427 9.07838 1.95322 9.07838 1.83181V1.32833C9.07838 1.20335 9.05372 1.1123 9.00448 1.05517C8.95516 0.99803 8.87304 0.969462 8.75805 0.969462H1.24693C1.13193 0.969462 1.04814 0.99803 0.995567 1.05517C0.946281 1.1123 0.921638 1.20335 0.921638 1.32833V1.83181C0.921638 1.95322 0.946281 2.04427 0.995567 2.10497C1.04814 2.16211 1.13193 2.19067 1.24693 2.19067Z"fill=currentColor>`);
var MarkAsArchived = (props) => {
  return (() => {
    var _el$ = _tmpl$10();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$11 = template(`<svg viewBox="0 0 11 11"fill=none xmlns=http://www.w3.org/2000/svg><path d="M2.17256 10.999C1.69081 10.999 1.3225 10.8562 1.06763 10.5705C0.815875 10.2848 0.689997 9.86525 0.689997 9.31177V3.64497H1.60378V9.2957C1.60378 9.52066 1.65506 9.6939 1.75763 9.81526C1.8633 9.93311 2.01405 9.99203 2.20986 9.99203H7.24963C7.44236 9.99203 7.58995 9.93311 7.69252 9.81526C7.79823 9.6939 7.85102 9.52066 7.85102 9.2957V3.64497H8.76947V9.31177C8.76947 9.86173 8.64208 10.2795 8.38721 10.5651C8.13235 10.8544 7.76556 10.999 7.28693 10.999H2.17256ZM1.00236 4.15916C0.68534 4.15916 0.438242 4.05204 0.261085 3.83779C0.0870305 3.61997 0 3.33074 0 2.97009V2.18809C0 1.82387 0.0901336 1.53464 0.270408 1.3204C0.450675 1.10615 0.694663 0.999023 1.00236 0.999023H8.46182C8.77568 0.999023 9.0197 1.10615 9.19375 1.3204C9.37094 1.53464 9.45946 1.82387 9.45946 2.18809V2.97009C9.45946 3.33074 9.37094 3.61997 9.19375 3.83779C9.0197 4.05204 8.77568 4.15916 8.46182 4.15916H1.00236ZM1.17953 3.1897H8.28464C8.39342 3.1897 8.4711 3.16113 8.51775 3.10399C8.56433 3.04329 8.58765 2.95224 8.58765 2.83083V2.32735C8.58765 2.20238 8.56433 2.11132 8.51775 2.05419C8.4711 1.99705 7.51461 1.96849 7.40583 1.96849H1.17953C1.07074 1.96849 0.991485 1.99705 0.941753 2.05419C0.895131 2.11132 0.87182 2.20238 0.87182 2.32735V2.83083C0.87182 2.95224 0.895131 3.04329 0.941753 3.10399C0.991485 3.16113 1.07074 3.1897 1.17953 3.1897Z"fill=currentColor></path><path d="M9.67298 0.553711C9.84703 0.556646 10.0146 0.614475 10.1535 0.716797L10.2208 0.771484L10.2814 0.833008C10.3958 0.960612 10.4679 1.11928 10.4913 1.28711L10.4992 1.37109L10.4982 1.45605C10.4872 1.64689 10.4124 1.8301 10.2833 1.97559L10.2843 1.97656L7.55482 5.15039L7.55384 5.14941C7.40234 5.3265 7.18382 5.43557 6.94642 5.44336L6.93861 5.44434H6.92005V5.44336C6.69203 5.44397 6.47619 5.35201 6.31947 5.19141L6.31849 5.18945L5.29505 4.13184C5.08531 3.91498 5.00658 3.60427 5.08118 3.31641L5.11634 3.21094C5.2129 2.97124 5.41476 2.78187 5.67396 2.70996L5.78626 2.68652C6.01138 2.65637 6.23763 2.72008 6.41419 2.85938L6.49818 2.93555L6.8849 3.33496L9.0138 0.859375V0.860352C9.15512 0.688807 9.35911 0.576792 9.58509 0.556641L9.67298 0.553711Z"fill=currentColor stroke=white>`);
var MarkAsArchivedRead = (props) => {
  return (() => {
    var _el$ = _tmpl$11();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$12 = template(`<svg viewBox="0 0 10 10"fill=none xmlns=http://www.w3.org/2000/svg><g clip-path=url(#clip0_3445_1172)><path d="M9 9.99902H1C0.867383 9.99902 0.7402 9.94635 0.64645 9.85257C0.552667 9.75882 0.5 9.63164 0.5 9.49902V0.499023C0.5 0.366407 0.552669 0.239223 0.64645 0.145473C0.7402 0.0516901 0.867383 -0.000976562 1 -0.000976562H6.25C6.42865 -0.000976562 6.59368 0.0943401 6.68301 0.249023C6.77233 0.403707 6.77233 0.59434 6.68301 0.749023C6.59368 0.903707 6.42865 0.999023 6.25 0.999023H1.5V8.99902H8.5V4.49902C8.5 4.32037 8.59532 4.15534 8.75 4.06602C8.90468 3.97669 9.09532 3.97669 9.25 4.06602C9.40468 4.15534 9.5 4.32037 9.5 4.49902V9.49902C9.5 9.63164 9.44733 9.75882 9.35355 9.85257C9.2598 9.94636 9.13262 9.99902 9 9.99902Z"fill=currentColor></path><path d="M7.5 8.24902H2.5C2.32135 8.24902 2.15632 8.15371 2.06699 7.99902C1.97767 7.84434 1.97767 7.65371 2.06699 7.49902C2.15632 7.34434 2.32135 7.24902 2.5 7.24902H7.5C7.67865 7.24902 7.84368 7.34434 7.93301 7.49902C8.02233 7.65371 8.02233 7.84434 7.93301 7.99902C7.84368 8.15371 7.67865 8.24902 7.5 8.24902Z"fill=currentColor></path><path d="M4.75 6.49901C4.61709 6.49979 4.48936 6.44761 4.39498 6.35403L2.89498 4.85403C2.76816 4.72717 2.71865 4.54235 2.76507 4.36907C2.81149 4.19583 2.94681 4.06051 3.12005 4.01409C3.29332 3.96767 3.47816 4.01718 3.60501 4.14401L4.73001 5.269L8.37501 1.16901C8.46056 1.06279 8.58578 0.996155 8.72169 0.984497C8.8576 0.972843 8.99233 1.01718 9.09474 1.10728C9.19712 1.19738 9.25825 1.32541 9.26398 1.46167C9.26968 1.59796 9.21948 1.73065 9.12502 1.82902L5.12502 6.32902C5.03371 6.43306 4.90337 6.49461 4.76502 6.49901L4.75 6.49901Z"fill=currentColor></path></g><defs><clipPath id=clip0_3445_1172><rect width=10 height=10 fill=white transform="translate(0 -0.000976562)">`);
var MarkAsRead = (props) => {
  return (() => {
    var _el$ = _tmpl$12();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$13 = template(`<svg viewBox="0 0 10 10"fill=none xmlns=http://www.w3.org/2000/svg><path d="M3.15789 2.99902V4.99902L0 2.49902L3.15789 -0.000976562V1.99902H5.78947C6.90618 1.99902 7.97714 2.42045 8.76677 3.1706C9.55639 3.92074 10 4.93816 10 5.99902C10 7.05989 9.55639 8.0773 8.76677 8.82745C7.97714 9.5776 6.90618 9.99902 5.78947 9.99902H1.05263V8.99902H5.78947C6.627 8.99902 7.43022 8.68295 8.02244 8.12034C8.61466 7.55773 8.94737 6.79467 8.94737 5.99902C8.94737 5.20337 8.61466 4.44031 8.02244 3.8777C7.43022 3.31509 6.627 2.99902 5.78947 2.99902H3.15789Z"fill=currentColor>`);
var MarkAsUnarchived = (props) => {
  return (() => {
    var _el$ = _tmpl$13();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$14 = template(`<svg viewBox="0 0 11 11"fill=none xmlns=http://www.w3.org/2000/svg><path d="M6.8 1.49902H1.5C0.947715 1.49902 0.5 1.94674 0.5 2.49902V9.49902C0.5 10.0513 0.947715 10.499 1.5 10.499H8.5C9.05228 10.499 9.5 10.0513 9.5 9.49902V4.19902"stroke=currentColor stroke-miterlimit=1 stroke-linecap=round></path><circle cx=9.25 cy=1.74902 r=1.25 fill=currentColor>`);
var MarkAsUnread = (props) => {
  return (() => {
    var _el$ = _tmpl$14();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$15 = template(`<svg xmlns=http://www.w3.org/2000/svg fill=none viewBox="0 0 13 12"><path fill=currentColor d="M9.787.98A5.972 5.972 0 006.5 0c-.668 0-1.31.11-1.911.31L9.187 4.94c.221.222.6.065.6-.248V.98z"></path><path fill=currentColor d="M2.879 1.216A5.99 5.99 0 00.5 6c0 1.134.315 2.195.862 3.1V7.309c0-1.966 2.379-2.946 3.764-1.552l4.995 5.027A5.99 5.99 0 0012.5 6a5.972 5.972 0 00-.862-3.1v1.791c0 1.966-2.379 2.946-3.764 1.552L2.879 1.216z"></path><path fill=currentColor d="M8.411 11.69L3.813 7.06a.351.351 0 00-.6.248v3.711c.944.62 2.073.98 3.287.98.668 0 1.31-.11 1.911-.31z">`);
var Novu2 = (props) => {
  return (() => {
    var _el$ = _tmpl$15();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$16 = template(`<svg viewBox="0 0 10 16"fill=none xmlns=http://www.w3.org/2000/svg><path d="M4.12531 1.8999C3.94958 1.8999 3.80713 2.04235 3.80713 2.21808C3.80713 2.39382 3.94958 2.53627 4.12531 2.53627H6.0344C6.21013 2.53627 6.35258 2.39382 6.35258 2.21808C6.35258 2.04235 6.21013 1.8999 6.0344 1.8999H4.12531Z"fill=currentColor></path><path d="M4.12531 1.8999C3.94958 1.8999 3.80713 2.04235 3.80713 2.21808C3.80713 2.39382 3.94958 2.53627 4.12531 2.53627H6.0344C6.21013 2.53627 6.35258 2.39382 6.35258 2.21808C6.35258 2.04235 6.21013 1.8999 6.0344 1.8999H4.12531Z"stroke=currentColor></path><path d="M2.69329 1.46818H7.30693C7.75127 1.46818 8.11147 1.82839 8.11147 2.27273V13.7273C8.11147 14.1716 7.75127 14.5318 7.30693 14.5318H2.69329C2.24896 14.5318 1.88875 14.1716 1.88875 13.7273V2.27273C1.88875 1.82839 2.24896 1.46818 2.69329 1.46818ZM2.69329 0.85C1.90754 0.85 1.27057 1.48698 1.27057 2.27273V2.95695C1.17568 3.00972 1.11147 3.111 1.11147 3.22727V3.54545C1.11147 3.64155 1.15532 3.7274 1.22411 3.78409C1.15532 3.84078 1.11147 3.92663 1.11147 4.02273V4.65909C1.11147 4.75519 1.15532 4.84104 1.22411 4.89773C1.15532 4.95442 1.11147 5.04027 1.11147 5.13636V6.09091C1.11147 6.20718 1.17568 6.30846 1.27057 6.36123V13.7273C1.27057 14.513 1.90754 15.15 2.69329 15.15H7.30693C8.09268 15.15 8.72966 14.513 8.72966 13.7273V6.36123C8.82454 6.30846 8.88875 6.20718 8.88875 6.09091V4.81818C8.88875 4.70191 8.82454 4.60063 8.72966 4.54786V2.27273C8.72966 1.48698 8.09268 0.85 7.30693 0.85H2.69329Z"fill=currentColor stroke=currentColor stroke-width=0.3>`);
var Push = (props) => {
  return (() => {
    var _el$ = _tmpl$16();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$17 = template(`<svg viewBox="0 0 20 20"fill=none xmlns=http://www.w3.org/2000/svg><path d="M10 1.75L17.125 5.875V14.125L10 18.25L2.875 14.125V5.875L10 1.75ZM10 3.48325L4.375 6.73975V13.2603L10 16.5167L15.625 13.2603V6.73975L10 3.48325ZM10 13C9.20435 13 8.44129 12.6839 7.87868 12.1213C7.31607 11.5587 7 10.7956 7 10C7 9.20435 7.31607 8.44129 7.87868 7.87868C8.44129 7.31607 9.20435 7 10 7C10.7956 7 11.5587 7.31607 12.1213 7.87868C12.6839 8.44129 13 9.20435 13 10C13 10.7956 12.6839 11.5587 12.1213 12.1213C11.5587 12.6839 10.7956 13 10 13ZM10 11.5C10.3978 11.5 10.7794 11.342 11.0607 11.0607C11.342 10.7794 11.5 10.3978 11.5 10C11.5 9.60218 11.342 9.22064 11.0607 8.93934C10.7794 8.65804 10.3978 8.5 10 8.5C9.60218 8.5 9.22064 8.65804 8.93934 8.93934C8.65804 9.22064 8.5 9.60218 8.5 10C8.5 10.3978 8.65804 10.7794 8.93934 11.0607C9.22064 11.342 9.60218 11.5 10 11.5Z"fill=currentColor>`);
var Settings = (props) => {
  return (() => {
    var _el$ = _tmpl$17();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$18 = template(`<svg viewBox="0 0 10 10"fill=none xmlns=http://www.w3.org/2000/svg><path d="M5.00051 9.28364C7.76195 9.28364 10 7.20598 10 4.64182C10 2.07766 7.76195 0 5.00051 0C2.23907 0 0.00101462 2.07766 0.00101462 4.64182C0.00101462 5.64829 0.346683 6.57889 0.932561 7.33988C0.895455 7.88663 0.709927 8.37313 0.514634 8.74358C0.407223 8.94889 0.297859 9.11404 0.21779 9.22562C0.176778 9.28141 0.145531 9.32381 0.122096 9.35282C0.110379 9.36621 0.102567 9.37737 0.096708 9.38407L0.0908493 9.39076C0.00101462 9.49342 -0.0243734 9.64517 0.0244497 9.77907C0.0732729 9.91297 0.186543 10 0.313483 10C0.873973 10 1.43837 9.80138 1.90707 9.56929C2.35429 9.34613 2.73511 9.08056 2.96751 8.88641C3.58854 9.14305 4.27597 9.28587 5.00051 9.28587V9.28364ZM1.87582 4.03481C1.87582 3.58179 2.19806 3.21357 2.5945 3.21357H2.96946C3.14132 3.21357 3.28193 3.37425 3.28193 3.57063C3.28193 3.76702 3.14132 3.92769 2.96946 3.92769H2.5945C2.54177 3.92769 2.50076 3.97679 2.50076 4.03481C2.50076 4.07052 2.51638 4.10399 2.54373 4.12408L3.11789 4.56148C3.31904 4.71323 3.43817 4.96987 3.43817 5.2466C3.43817 5.69962 3.11593 6.06784 2.71949 6.06784L2.18829 6.07007C2.01644 6.07007 1.87582 5.9094 1.87582 5.71301C1.87582 5.51663 2.01644 5.35595 2.18829 5.35595H2.71949C2.77222 5.35595 2.81323 5.30685 2.81323 5.24883C2.81323 5.21312 2.79761 5.17965 2.77026 5.15956L2.1961 4.72216C1.99691 4.56818 1.87582 4.31154 1.87582 4.03481ZM7.28153 3.21357H7.65649C7.82834 3.21357 7.96896 3.37425 7.96896 3.57063C7.96896 3.76702 7.82834 3.92769 7.65649 3.92769H7.28153C7.2288 3.92769 7.18779 3.97679 7.18779 4.03481C7.18779 4.07052 7.20341 4.10399 7.23075 4.12408L7.80491 4.56148C8.00411 4.71323 8.12519 4.96987 8.12519 5.2466C8.12519 5.69962 7.80296 6.06784 7.40651 6.06784L6.87532 6.07007C6.70346 6.07007 6.56285 5.9094 6.56285 5.71301C6.56285 5.51663 6.70346 5.35595 6.87532 5.35595H7.40651C7.45924 5.35595 7.50025 5.30685 7.50025 5.24883C7.50025 5.21312 7.48463 5.17965 7.45729 5.15956L6.88313 4.72216C6.68393 4.57041 6.56285 4.31377 6.56285 4.03705C6.56285 3.58402 6.88508 3.2158 7.28153 3.2158V3.21357ZM4.31308 3.35639L5.00051 4.40304L5.68794 3.35639C5.76801 3.23365 5.90862 3.18233 6.03751 3.23142C6.1664 3.28052 6.25038 3.41665 6.25038 3.57063V5.71301C6.25038 5.9094 6.10977 6.07007 5.93791 6.07007C5.76605 6.07007 5.62544 5.9094 5.62544 5.71301V4.64182L5.25048 5.21312C5.19189 5.30239 5.09815 5.35595 5.00051 5.35595C4.90286 5.35595 4.80912 5.30239 4.75053 5.21312L4.37557 4.64182V5.71301C4.37557 5.9094 4.23496 6.07007 4.0631 6.07007C3.89124 6.07007 3.75063 5.9094 3.75063 5.71301V3.57063C3.75063 3.41665 3.83656 3.28052 3.9635 3.23142C4.09044 3.18233 4.23105 3.23365 4.31308 3.35639Z"fill=currentColor>`);
var Sms = (props) => {
  return (() => {
    var _el$ = _tmpl$18();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$19 = template(`<svg viewBox="0 0 10 8"fill=none xmlns=http://www.w3.org/2000/svg><path d="M1.0119 0.347055C1.06274 0.143703 1.26565 -0.000976562 1.5 -0.000976562H8.5C8.73435 -0.000976562 8.93725 0.143703 8.9881 0.347055L9.9881 4.34707C9.996 4.37871 10 4.41102 10 4.44347V7.55458C10 7.80005 9.77615 7.99902 9.5 7.99902H0.5C0.22386 7.99902 0 7.80005 0 7.55458V4.44347C0 4.41102 0.00399495 4.37871 0.011905 4.34707L1.0119 0.347055ZM1.90108 0.887912L1.12331 3.99902H3.5C3.5 4.73542 4.17155 5.33236 5 5.33236C5.82845 5.33236 6.5 4.73542 6.5 3.99902H8.8767L8.0989 0.887912H1.90108ZM7.292 4.88791C6.9062 5.67276 6.02515 6.22125 5 6.22125C3.97484 6.22125 3.0938 5.67276 2.70802 4.88791H1V7.11013H9V4.88791H7.292Z"fill=currentColor>`);
var UnreadRead = (props) => {
  return (() => {
    var _el$ = _tmpl$19();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$20 = template(`<span>`);
var BellContainer = (props) => {
  const style3 = useStyle();
  return (() => {
    var _el$ = _tmpl$20();
    insert(_el$, createComponent(Bell, {
      get ["class"]() {
        return style3("bellIcon", "nt-size-4");
      }
    }), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return props.unreadCount > 0;
      },
      get children() {
        var _el$2 = _tmpl$20();
        createRenderEffect(() => className(_el$2, style3("bellDot", "nt-absolute nt-top-0 nt-right-0 nt-block nt-size-2 nt-transform nt-bg-counter nt-rounded-full nt-border nt-border-background")));
        return _el$2;
      }
    }), null);
    createRenderEffect(() => className(_el$, style3("bellContainer", `nt-size-4 nt-flex nt-justify-center nt-items-center nt-relative nt-text-foreground nt-cursor-pointer`)));
    return _el$;
  })();
};
var Bell2 = (props) => {
  const {
    totalUnreadCount
  } = useTotalUnreadCount();
  return createComponent(Show, {
    get when() {
      return props.renderBell;
    },
    get fallback() {
      return createComponent(BellContainer, {
        get unreadCount() {
          return totalUnreadCount();
        }
      });
    },
    get children() {
      return createComponent(ExternalElementRenderer, {
        render: (el) => props.renderBell(el, totalUnreadCount())
      });
    }
  });
};
function isBrowser() {
  return typeof window !== "undefined";
}
var _tmpl$21 = template(`<span class="nt-z-10 nt-text-xs nt-text-stripes">Development mode`);
var _tmpl$22 = template(`<span class="nt-z-10 nt-text-xs">•`);
var _tmpl$32 = template(`<a target=_blank class="nt-z-10 nt-flex nt-items-center nt-gap-1 nt-justify-center"><span class=nt-text-xs>Inbox by</span><span class=nt-text-xs>Novu`);
var _tmpl$42 = template(`<div>`);
var stripes = `before:nt-content-[""] before:nt-absolute before:nt-inset-0 before:-nt-right-[calc(0+var(--stripes-size))] before:[mask-image:linear-gradient(transparent_0%,black)] before:nt-bg-dev-stripes-gradient before:nt-bg-[length:var(--stripes-size)_var(--stripes-size)] before:nt-animate-stripes before:hover:[animation-play-state:running]`;
var commonAfter = 'after:nt-content-[""] after:nt-absolute after:nt-inset-0 after:-nt-top-12';
var devModeGradient = `${commonAfter} after:nt-bg-[linear-gradient(180deg,transparent,oklch(from_var(--nv-color-stripes)_l_c_h_/_0.07)_55%,transparent),linear-gradient(180deg,transparent,oklch(from_var(--nv-color-background)_l_c_h_/_0.9)_55%,transparent)]`;
var prodModeGradient = `${commonAfter} after:nt-bg-[linear-gradient(180deg,transparent,oklch(from_var(--nv-color-background)_l_c_h_/_0.9)_55%,transparent)]`;
var Footer = () => {
  const {
    hideBranding,
    isDevelopmentMode
  } = useInboxContext();
  return createComponent(Show, {
    get when() {
      return !hideBranding() || isDevelopmentMode();
    },
    get children() {
      var _el$ = _tmpl$42();
      _el$.style.setProperty("--stripes-size", "15px");
      insert(_el$, createComponent(Show, {
        get when() {
          return isDevelopmentMode();
        },
        get children() {
          return _tmpl$21();
        }
      }), null);
      insert(_el$, createComponent(Show, {
        get when() {
          return memo(() => !!isDevelopmentMode())() && !hideBranding();
        },
        get children() {
          return _tmpl$22();
        }
      }), null);
      insert(_el$, createComponent(Show, {
        get when() {
          return !hideBranding();
        },
        get children() {
          var _el$4 = _tmpl$32(), _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling;
          insert(_el$4, createComponent(Novu2, {
            "class": "nt-size-2.5"
          }), _el$6);
          createRenderEffect(() => setAttribute(_el$4, "href", `https://go.novu.co/powered?ref=${getCurrentDomain()}`));
          return _el$4;
        }
      }), null);
      createRenderEffect(() => className(_el$, cn(`nt-relative nt-flex nt-shrink-0 nt-justify-center nt-items-center nt-gap-1 nt-mt-auto nt-py-3 nt-text-foreground-alpha-400`, {
        [stripes]: isDevelopmentMode(),
        [devModeGradient]: isDevelopmentMode(),
        "nt-bg-[oklch(from_var(--nv-color-stripes)_l_c_h_/_0.1)]": isDevelopmentMode(),
        [prodModeGradient]: !isDevelopmentMode()
      })));
      return _el$;
    }
  });
};
function getCurrentDomain() {
  if (isBrowser()) {
    return window.location.hostname;
  }
  return "";
}
var _tmpl$23 = template(`<button>`);
var buttonVariants = cva(cn('nt-inline-flex nt-gap-4 nt-items-center nt-justify-center nt-whitespace-nowrap nt-text-sm nt-font-medium nt-transition-colors disabled:nt-pointer-events-none disabled:nt-opacity-50 after:nt-absolute after:nt-content-[""] before:nt-content-[""] before:nt-absolute [&_svg]:nt-pointer-events-none [&_svg]:nt-shrink-0', `focus-visible:nt-outline-none focus-visible:nt-ring-2 focus-visible:nt-rounded-md focus-visible:nt-ring-ring focus-visible:nt-ring-offset-2`), {
  variants: {
    variant: {
      default: "nt-bg-gradient-to-b nt-from-20% nt-from-primary-foreground-alpha-200 nt-to-transparent nt-bg-primary nt-text-primary-foreground nt-shadow-[0_0_0_0.5px_var(--nv-color-primary-600)] nt-relative before:nt-absolute before:nt-inset-0 before:nt-border before:nt-border-primary-foreground-alpha-100 after:nt-absolute after:nt-inset-0 after:nt-opacity-0 hover:after:nt-opacity-100 after:nt-transition-opacity after:nt-bg-gradient-to-b after:nt-from-primary-foreground-alpha-50 after:nt-to-transparent",
      secondary: "nt-bg-secondary nt-text-secondary-foreground nt-shadow-[0_0_0_0.5px_var(--nv-color-secondary-600)] nt-relative before:nt-absolute before:nt-inset-0 before:nt-border before:nt-border-secondary-foreground-alpha-100 after:nt-absolute after:nt-inset-0 after:nt-opacity-0 hover:after:nt-opacity-100 after:nt-transition-opacity after:nt-bg-gradient-to-b after:nt-from-secondary-foreground-alpha-50 after:nt-to-transparent",
      ghost: "hover:nt-bg-neutral-alpha-100 nt-text-foreground-alpha-600 hover:nt-text-foreground-alpha-800",
      unstyled: ""
    },
    size: {
      none: "",
      iconSm: "nt-p-1 nt-rounded-md after:nt-rounded-md before:nt-rounded-md focus-visible:nt-rounded-md",
      icon: "nt-p-2.5 nt-rounded-xl before:nt-rounded-xl after:nt-rounded-xl focus-visible:nt-rounded-xl",
      default: "nt-px-2 nt-py-1 nt-rounded-lg focus-visible:nt-rounded-lg before:nt-rounded-lg after:nt-rounded-lg",
      sm: "nt-px-1 nt-py-px nt-rounded-md nt-text-xs nt-px-1 before:nt-rounded-md focus-visible:nt-rounded-md after:nt-rounded-md",
      lg: "nt-px-8 nt-py-2 nt-text-base before:nt-rounded-lg after:nt-rounded-lg focus-visible:nt-rounded-lg"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "default"
  }
});
var Button = (props) => {
  const [local, rest] = splitProps(props, ["class", "appearanceKey"]);
  const style3 = useStyle();
  return (() => {
    var _el$ = _tmpl$23();
    spread(_el$, mergeProps({
      get ["data-variant"]() {
        return props.variant;
      },
      get ["data-size"]() {
        return props.size;
      },
      get ["class"]() {
        return style3(local.appearanceKey || "button", cn(buttonVariants({
          variant: props.variant,
          size: props.size
        }), local.class));
      }
    }, rest), false, false);
    return _el$;
  })();
};
var _tmpl$24 = template(`<button>`);
var PopoverClose = (props) => {
  const {
    onClose
  } = usePopover();
  const style3 = useStyle();
  const [local, rest] = splitProps(props, ["onClick", "asChild", "appearanceKey", "class"]);
  const handleClick = (e) => {
    if (typeof local.onClick === "function") {
      local.onClick(e);
    }
    onClose();
  };
  if (local.asChild) {
    return createComponent(Dynamic, mergeProps({
      get component() {
        return local.asChild;
      },
      onClick: handleClick
    }, rest));
  }
  return (() => {
    var _el$ = _tmpl$24();
    _el$.$$click = handleClick;
    spread(_el$, mergeProps({
      get ["class"]() {
        return style3(local.appearanceKey || "popoverClose", local.class);
      }
    }, rest), false, false);
    return _el$;
  })();
};
delegateEvents(["click"]);
var _tmpl$25 = template(`<div>`);
var Portal2 = (props) => {
  const appearance = useAppearance();
  let currentElement;
  return [(() => {
    var _el$ = _tmpl$25();
    use((el) => {
      currentElement = el;
    }, _el$);
    _el$.style.setProperty("display", "none");
    return _el$;
  })(), createComponent(Portal, mergeProps({
    get mount() {
      return closestNovuRootParent(currentElement, appearance.id());
    }
  }, props))];
};
var closestNovuRootParent = (el, id) => {
  let element = el;
  while (element && element.id !== `novu-root-${id}`) {
    element = element.parentElement;
  }
  if (element && element.id === `novu-root-${id}`) {
    return element;
  }
  return void 0;
};
var PopoverContext = createContext(void 0);
function PopoverRoot(props) {
  var _a;
  const [uncontrolledIsOpen, setUncontrolledIsOpen] = createSignal((_a = props.open) != null ? _a : false);
  const onOpenChange = () => {
    var _a2;
    return (_a2 = props.onOpenChange) != null ? _a2 : setUncontrolledIsOpen;
  };
  const open = () => {
    var _a2;
    return (_a2 = props.open) != null ? _a2 : uncontrolledIsOpen();
  };
  const [reference, setReference] = createSignal(null);
  const [floating, setFloating] = createSignal(null);
  const position = useFloating(reference, floating, {
    strategy: "absolute",
    placement: props.placement,
    whileElementsMounted: autoUpdate,
    middleware: [offset2(10), flip2({
      fallbackPlacements: props.fallbackPlacements
    }), shift2()]
  });
  const floatingStyles = createMemo(() => {
    var _a2, _b;
    return {
      position: position.strategy,
      top: `${(_a2 = position.y) != null ? _a2 : 0}px`,
      left: `${(_b = position.x) != null ? _b : 0}px`
    };
  });
  const onClose = () => {
    onOpenChange()(false);
  };
  const onToggle = () => {
    onOpenChange()((prev2) => !prev2);
  };
  return createComponent(PopoverContext.Provider, {
    value: {
      onToggle,
      onClose,
      reference,
      setReference,
      floating,
      setFloating,
      open,
      floatingStyles
    },
    get children() {
      return props.children;
    }
  });
}
function usePopover() {
  const context = useContext(PopoverContext);
  if (!context) {
    throw new Error("usePopover must be used within Popover.Root component");
  }
  return context;
}
var _tmpl$26 = template(`<div>`);
var popoverContentVariants = () => cn("nt-w-[400px] nt-h-[600px] nt-rounded-xl nt-bg-background", "nt-shadow-popover nt-animate-in nt-slide-in-from-top-2 nt-fade-in nt-cursor-default nt-flex nt-flex-col nt-overflow-hidden nt-border nt-border-border nt-z-10");
var PopoverContentBody = (props) => {
  const {
    open,
    setFloating,
    floating,
    floatingStyles
  } = usePopover();
  const {
    setActive,
    removeActive
  } = useFocusManager();
  const [local, rest] = splitProps(props, ["class", "appearanceKey", "style"]);
  const style3 = useStyle();
  onMount(() => {
    const floatingEl = floating();
    setActive(floatingEl);
    onCleanup(() => {
      removeActive(floatingEl);
    });
  });
  return (() => {
    var _el$ = _tmpl$26();
    use(setFloating, _el$);
    spread(_el$, mergeProps({
      get ["class"]() {
        return style3(local.appearanceKey || "popoverContent", cn(popoverContentVariants(), local.class));
      },
      get style() {
        return floatingStyles();
      },
      get ["data-open"]() {
        return open();
      }
    }, rest), false, false);
    return _el$;
  })();
};
var PopoverContent = (props) => {
  const {
    open,
    onClose,
    reference,
    floating
  } = usePopover();
  const {
    active
  } = useFocusManager();
  const handleClickOutside = (e) => {
    var _a, _b;
    if ((_a = reference()) == null ? void 0 : _a.contains(e.target)) {
      return;
    }
    if (active() !== floating() || ((_b = floating()) == null ? void 0 : _b.contains(e.target))) {
      return;
    }
    onClose();
  };
  const handleEscapeKey = (e) => {
    if (active() !== floating()) {
      return;
    }
    if (e.key === "Escape") {
      onClose();
    }
  };
  onMount(() => {
    document.body.addEventListener("click", handleClickOutside);
    document.body.addEventListener("keydown", handleEscapeKey);
  });
  onCleanup(() => {
    document.body.removeEventListener("click", handleClickOutside);
    document.body.removeEventListener("keydown", handleEscapeKey);
  });
  return createComponent(Show, {
    get when() {
      return open();
    },
    get children() {
      return createComponent(Portal2, {
        get children() {
          return createComponent(PopoverContentBody, props);
        }
      });
    }
  });
};
function chain2(callbacks) {
  return (...args) => {
    for (const callback of callbacks) callback && callback(...args);
  };
}
function mergeRefs(...refs) {
  return chain2(refs);
}
var _tmpl$27 = template(`<button>`);
var PopoverTrigger = (props) => {
  const {
    setReference,
    onToggle
  } = usePopover();
  const style3 = useStyle();
  const [local, rest] = splitProps(props, ["appearanceKey", "asChild", "onClick", "ref"]);
  const handleClick = (e) => {
    if (typeof local.onClick === "function") {
      local.onClick(e);
    }
    onToggle();
  };
  const ref = createMemo(() => local.ref ? mergeRefs(setReference, local.ref) : setReference);
  if (local.asChild) {
    return createComponent(Dynamic, mergeProps({
      get component() {
        return local.asChild;
      },
      ref(r$) {
        var _ref$ = ref();
        typeof _ref$ === "function" && _ref$(r$);
      },
      onClick: handleClick
    }, rest));
  }
  return (() => {
    var _el$ = _tmpl$27();
    _el$.$$click = handleClick;
    var _ref$2 = ref();
    typeof _ref$2 === "function" && use(_ref$2, _el$);
    spread(_el$, mergeProps({
      get ["class"]() {
        return style3(local.appearanceKey || "dropdownTrigger");
      }
    }, rest), false, true);
    insert(_el$, () => props.children);
    return _el$;
  })();
};
delegateEvents(["click"]);
var Popover = {
  Root: PopoverRoot,
  /**
   * Popover.Trigger renders a `button` and has no default styling.
   */
  Trigger: PopoverTrigger,
  /**
   * Popover.Content renders a `div` and has popover specific styling.
   */
  Content: PopoverContent,
  /**
   * Popover.Close renders a `button` and has no styling.
   * Closes the popover when clicked.
   * `onClick` function is propagated.
   */
  Close: PopoverClose
};
var dropdownContentVariants = () => "nt-p-1 nt-text-sm nt-min-w-52 nt-shadow-dropdown nt-h-fit nt-min-w-52 nt-w-max";
var DropdownContent = (props) => {
  const [local, rest] = splitProps(props, ["appearanceKey", "class"]);
  return createComponent(Popover.Content, mergeProps({
    get appearanceKey() {
      return local.appearanceKey || "dropdownContent";
    },
    get ["class"]() {
      return cn(dropdownContentVariants(), local.class);
    }
  }, rest));
};
var dropdownItemVariants = () => "focus:nt-outline-none nt-flex nt-items-center nt-gap-1.5 nt-text-sm nt-rounded-lg nt-items-center hover:nt-bg-neutral-alpha-50 focus-visible:nt-bg-neutral-alpha-50 nt-py-1 nt-px-2";
var DropdownItem = (props) => {
  const [local, rest] = splitProps(props, ["appearanceKey", "onClick", "class", "asChild"]);
  const {
    onClose
  } = usePopover();
  const handleClick = (e) => {
    if (typeof local.onClick === "function") {
      local.onClick(e);
    }
    onClose();
  };
  if (local.asChild) {
    return createComponent(Dynamic, mergeProps({
      get component() {
        return local.asChild;
      },
      onClick: handleClick
    }, rest));
  }
  return createComponent(Popover.Close, mergeProps({
    get appearanceKey() {
      return local.appearanceKey || "dropdownItem";
    },
    get ["class"]() {
      return cn(dropdownItemVariants(), local.class);
    },
    onClick: (e) => {
      if (typeof local.onClick === "function") {
        local.onClick(e);
      }
      onClose();
    }
  }, rest));
};
var DropdownRoot = (props) => {
  return createComponent(Popover.Root, mergeProps({
    placement: "bottom",
    fallbackPlacements: ["top"]
  }, props));
};
var dropdownTriggerButtonVariants = () => `nt-relative nt-transition nt-outline-none focus-visible:nt-outline-nonefocus-visible:nt-ring-2 focus-visible:nt-ring-primary focus-visible:nt-ring-offset-2`;
var DropdownTrigger = (props) => {
  const style3 = useStyle();
  const [local, rest] = splitProps(props, ["appearanceKey", "class"]);
  return createComponent(Popover.Trigger, mergeProps({
    get ["class"]() {
      return style3(local.appearanceKey || "dropdownTrigger", cn(dropdownTriggerButtonVariants(), local.class));
    }
  }, rest));
};
var Dropdown = {
  Root: DropdownRoot,
  /**
   * Dropdown.Trigger renders a `button` and has no default styling.
   */
  Trigger: DropdownTrigger,
  /**
   * Dropdown.Content renders a `Popover.Content` by default.
   */
  Content: DropdownContent,
  /**
   * Dropdown.Close renders a `Popover.Close` by default.
   */
  Close: Popover.Close,
  /**
   * Dropdown.Item renders a `Popover.Close` with dropdown specific styling.
   * Closes the popover when clicked.
   * `onClick` function is propagated.
   */
  Item: DropdownItem
};
var Motion2 = new Proxy(Motion, {
  get: (_, tag) => (props) => {
    const {
      animations
    } = useAppearance();
    return createComponent(Motion, mergeProps(props, {
      tag,
      get transition() {
        return animations() ? props.transition : {
          duration: 0
        };
      }
    }));
  }
});
var useKeyboardNavigation = ({
  activeTab,
  setActiveTab,
  tabsContainer
}) => {
  const [keyboardNavigation, setKeyboardNavigation] = createSignal(false);
  createEffect(() => {
    const handleTabKey = (event) => {
      var _a;
      if (event.key !== "Tab") {
        return;
      }
      const tabs = (_a = tabsContainer()) == null ? void 0 : _a.querySelectorAll('[role="tab"]');
      if (!tabs || !document.activeElement) {
        return;
      }
      setKeyboardNavigation(Array.from(tabs).includes(document.activeElement));
    };
    document.addEventListener("keyup", handleTabKey);
    return onCleanup(() => document.removeEventListener("keyup", handleTabKey));
  });
  createEffect(() => {
    const handleArrowKeys = (event) => {
      var _a, _b;
      if (!keyboardNavigation() || event.key !== "ArrowLeft" && event.key !== "ArrowRight") {
        return;
      }
      const tabElements = Array.from((_b = (_a = tabsContainer()) == null ? void 0 : _a.querySelectorAll('[role="tab"]')) != null ? _b : []);
      const tabIds = tabElements.map((tab) => tab.id);
      const currentIndex = tabIds.indexOf(activeTab());
      const { length: length2 } = tabIds;
      let activeIndex = currentIndex;
      let newTab = activeTab();
      if (event.key === "ArrowLeft") {
        activeIndex = currentIndex === 0 ? length2 - 1 : currentIndex - 1;
        newTab = tabIds[activeIndex];
      } else if (event.key === "ArrowRight") {
        activeIndex = currentIndex === length2 - 1 ? 0 : currentIndex + 1;
        newTab = tabIds[activeIndex];
      }
      tabElements[activeIndex].focus();
      setActiveTab(newTab);
    };
    document.addEventListener("keydown", handleArrowKeys);
    return onCleanup(() => document.removeEventListener("keydown", handleArrowKeys));
  });
};
var _tmpl$28 = template(`<div>`);
var TabsContext = createContext(void 0);
var useTabsContext = () => {
  const context = useContext(TabsContext);
  if (!context) {
    throw new Error("useTabsContext must be used within an TabsContext.Provider");
  }
  return context;
};
var tabsRootVariants = () => "nt-flex nt-flex-col";
var TabsRoot = (props) => {
  var _a;
  const [local, rest] = splitProps(props, ["defaultValue", "value", "class", "appearanceKey", "onChange", "children"]);
  const [tabsContainer, setTabsContainer] = createSignal();
  const [visibleTabs, setVisibleTabs] = createSignal([]);
  const [activeTab, setActiveTab] = createSignal((_a = local.defaultValue) != null ? _a : "");
  const style3 = useStyle();
  useKeyboardNavigation({
    tabsContainer,
    activeTab,
    setActiveTab
  });
  createEffect(() => {
    if (local.value) {
      setActiveTab(local.value);
    }
  });
  createEffect(() => {
    var _a2;
    (_a2 = local.onChange) == null ? void 0 : _a2.call(local, activeTab());
  });
  return createComponent(TabsContext.Provider, {
    value: {
      activeTab,
      setActiveTab,
      visibleTabs,
      setVisibleTabs
    },
    get children() {
      var _el$ = _tmpl$28();
      use(setTabsContainer, _el$);
      spread(_el$, mergeProps({
        get ["class"]() {
          return style3(local.appearanceKey || "tabsRoot", cn(tabsRootVariants(), local.class));
        }
      }, rest), false, true);
      insert(_el$, () => local.children);
      return _el$;
    }
  });
};
var _tmpl$29 = template(`<div role=tabpanel>`);
var TabsContent = (props) => {
  const [local, rest] = splitProps(props, ["value", "class", "appearanceKey", "children"]);
  const style3 = useStyle();
  const {
    activeTab
  } = useTabsContext();
  return createComponent(Show, {
    get when() {
      return activeTab() === local.value;
    },
    get children() {
      var _el$ = _tmpl$29();
      spread(_el$, mergeProps({
        get ["class"]() {
          return memo(() => !!local.class)() ? local.class : style3(local.appearanceKey || "tabsContent", activeTab() === local.value ? "nt-block" : "nt-hidden");
        },
        get id() {
          return `tabpanel-${local.value}`;
        },
        get ["aria-labelledby"]() {
          return local.value;
        },
        get ["data-state"]() {
          return activeTab() === local.value ? "active" : "inactive";
        }
      }, rest), false, true);
      insert(_el$, () => local.children);
      return _el$;
    }
  });
};
var _tmpl$30 = template(`<div role=tablist>`);
var _tmpl$210 = template(`<div class="nt-relative nt-z-[-1]">`);
var tabsListVariants = () => "nt-flex nt-gap-6";
var TabsList = (props) => {
  const [local, rest] = splitProps(props, ["class", "appearanceKey", "ref", "children"]);
  const style3 = useStyle();
  return [(() => {
    var _el$ = _tmpl$30();
    var _ref$ = local.ref;
    typeof _ref$ === "function" ? use(_ref$, _el$) : local.ref = _el$;
    spread(_el$, mergeProps({
      get ["class"]() {
        return style3(local.appearanceKey || "tabsList", cn(tabsListVariants(), local.class));
      }
    }, rest), false, true);
    insert(_el$, () => local.children);
    return _el$;
  })(), _tmpl$210()];
};
var tabsTriggerVariants = () => cn("nt-relative nt-transition nt-outline-none nt-text-foreground-alpha-600 nt-pb-[0.625rem]", `after:nt-absolute after:nt-content-[''] after:nt-bottom-0 after:nt-left-0 after:nt-w-full after:nt-h-[2px]`, "after:nt-transition-opacity after:nt-duration-200", "data-[state=active]:after:nt-border-b-2 data-[state=active]:after:nt-border-primary data-[state=active]:after:nt-opacity-100", "data-[state=active]:nt-text-foreground after:nt-border-b-transparent after:nt-opacity-0", "focus-visible:nt-outline-none focus-visible:nt-rounded-lg focus-visible:nt-ring-2 focus-visible:nt-ring-ring focus-visible:nt-ring-offset-2");
var TabsTrigger = (props) => {
  const [local, rest] = splitProps(props, ["value", "class", "appearanceKey", "ref", "onClick", "children"]);
  const style3 = useStyle();
  const {
    activeTab,
    setActiveTab
  } = useTabsContext();
  const clickHandler = () => setActiveTab(local.value);
  return createComponent(Button, mergeProps({
    variant: "unstyled",
    size: "none",
    ref(r$) {
      var _ref$ = local.ref;
      typeof _ref$ === "function" ? _ref$(r$) : local.ref = r$;
    },
    get id() {
      return local.value;
    },
    get appearanceKey() {
      var _a;
      return (_a = local.appearanceKey) != null ? _a : "tabsTrigger";
    },
    get ["class"]() {
      return memo(() => !!local.class)() ? local.class : style3(local.appearanceKey || "tabsTrigger", tabsTriggerVariants());
    },
    get onClick() {
      var _a;
      return (_a = local.onClick) != null ? _a : clickHandler;
    },
    role: "tab",
    tabIndex: 0,
    get ["aria-selected"]() {
      return activeTab() === local.value;
    },
    get ["aria-controls"]() {
      return `tabpanel-${local.value}`;
    },
    get ["data-state"]() {
      return activeTab() === local.value ? "active" : "inactive";
    }
  }, rest, {
    get children() {
      return local.children;
    }
  }));
};
var Tabs = {
  Root: TabsRoot,
  List: TabsList,
  Trigger: TabsTrigger,
  Content: TabsContent
};
var notificationStatusOptionsLocalizationKeys = {
  unreadRead: "inbox.filters.dropdownOptions.default",
  unread: "inbox.filters.dropdownOptions.unread",
  archived: "inbox.filters.dropdownOptions.archived",
  snoozed: "inbox.filters.dropdownOptions.snoozed"
};
var inboxFilterLocalizationKeys = {
  unreadRead: "inbox.filters.labels.default",
  unread: "inbox.filters.labels.unread",
  archived: "inbox.filters.labels.archived",
  snoozed: "inbox.filters.labels.snoozed"
};
var _tmpl$31 = template(`<svg viewBox="0 0 12 12"fill=none xmlns=http://www.w3.org/2000/svg><path d="M6 2.99902V5.99902H8.25M11 5.99902C11 8.76045 8.76142 10.999 6 10.999C3.23858 10.999 1 8.76045 1 5.99902C1 3.2376 3.23858 0.999023 6 0.999023C8.76142 0.999023 11 3.2376 11 5.99902Z"stroke=currentColor stroke-linecap=round stroke-linejoin=round>`);
var Snooze = (props) => {
  return (() => {
    var _el$ = _tmpl$31();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$33 = template(`<span><span></span><span>`);
var cases = [{
  status: "unreadRead",
  icon: UnreadRead
}, {
  status: "unread",
  icon: MarkAsUnread
}, {
  status: "snoozed",
  icon: Snooze
}, {
  status: "archived",
  icon: MarkAsArchived
}];
var StatusOptions = (props) => {
  const {
    isSnoozeEnabled
  } = useInboxContext();
  const filteredCases = () => {
    return cases.filter((c) => c.status !== "snoozed" || isSnoozeEnabled());
  };
  return createComponent(For, {
    get each() {
      return filteredCases();
    },
    children: (c) => createComponent(StatusItem, {
      get localizationKey() {
        return notificationStatusOptionsLocalizationKeys[c.status];
      },
      onClick: () => {
        props.setStatus(c.status);
      },
      get isSelected() {
        return props.status === c.status;
      },
      get icon() {
        return c.icon;
      }
    })
  });
};
var StatusItem = (props) => {
  const style3 = useStyle();
  const {
    t
  } = useLocalization();
  return createComponent(Dropdown.Item, {
    get ["class"]() {
      return style3("inboxStatus__dropdownItem", cn(dropdownItemVariants(), "nt-flex nt-gap-8 nt-justify-between"));
    },
    get onClick() {
      return props.onClick;
    },
    get children() {
      return [(() => {
        var _el$ = _tmpl$33(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
        insert(_el$2, () => props.icon());
        insert(_el$3, () => t(props.localizationKey));
        createRenderEffect((_p$) => {
          var _v$ = style3("inboxStatus__dropdownItemLabelContainer", "nt-flex nt-gap-2 nt-items-center"), _v$2 = style3("inboxStatus__dropdownItemLeft__icon", "nt-size-3"), _v$3 = props.localizationKey, _v$4 = style3("inboxStatus__dropdownItemLabel", "nt-leading-none");
          _v$ !== _p$.e && className(_el$, _p$.e = _v$);
          _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
          _v$3 !== _p$.a && setAttribute(_el$3, "data-localization", _p$.a = _v$3);
          _v$4 !== _p$.o && className(_el$3, _p$.o = _v$4);
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0,
          o: void 0
        });
        return _el$;
      })(), createComponent(Show, {
        get when() {
          return props.isSelected;
        },
        get children() {
          return createComponent(Check, {
            get ["class"]() {
              return style3("inboxStatus__dropdownItemCheck__icon", "nt-size-3");
            }
          });
        }
      })];
    }
  });
};
var _tmpl$34 = template(`<span>`);
var StatusDropdown = () => {
  const style3 = useStyle();
  const {
    status,
    setStatus
  } = useInboxContext();
  const {
    t
  } = useLocalization();
  return createComponent(Dropdown.Root, {
    get children() {
      return [createComponent(Dropdown.Trigger, {
        get ["class"]() {
          return style3("inboxStatus__dropdownTrigger", cn(buttonVariants({
            variant: "unstyled",
            size: "none"
          }), "nt-gap-0.5"));
        },
        asChild: (triggerProps) => createComponent(Button, mergeProps({
          variant: "unstyled",
          size: "none"
        }, triggerProps, {
          get children() {
            return [(() => {
              var _el$ = _tmpl$34();
              insert(_el$, () => t(inboxFilterLocalizationKeys[status()]));
              createRenderEffect((_p$) => {
                var _v$ = inboxFilterLocalizationKeys[status()], _v$2 = style3("inboxStatus__title", "nt-text-base");
                _v$ !== _p$.e && setAttribute(_el$, "data-localization", _p$.e = _v$);
                _v$2 !== _p$.t && className(_el$, _p$.t = _v$2);
                return _p$;
              }, {
                e: void 0,
                t: void 0
              });
              return _el$;
            })(), createComponent(ArrowDropDown, {
              get ["class"]() {
                return style3("inboxStatus__dropdownItemRight__icon", "nt-text-foreground-alpha-600 nt-size-4");
              }
            })];
          }
        }))
      }), createComponent(Dropdown.Content, {
        appearanceKey: "inboxStatus__dropdownContent",
        get children() {
          return createComponent(StatusOptions, {
            setStatus,
            get status() {
              return status();
            }
          });
        }
      })];
    }
  });
};
var useArchiveAll = (props) => {
  const novu = useNovu();
  const archiveAll2 = (..._0) => __async(void 0, [..._0], function* ({ tags } = {}) {
    var _a, _b;
    try {
      yield novu.notifications.archiveAll({ tags });
      (_a = props == null ? void 0 : props.onSuccess) == null ? void 0 : _a.call(props);
    } catch (error) {
      (_b = void 0) == null ? void 0 : _b.call(props, error);
    }
  });
  return { archiveAll: archiveAll2 };
};
var useArchiveAllRead = (props) => {
  const novu = useNovu();
  const archiveAllRead2 = (..._0) => __async(void 0, [..._0], function* ({ tags } = {}) {
    var _a, _b;
    try {
      yield novu.notifications.archiveAllRead({ tags });
      (_a = props == null ? void 0 : props.onSuccess) == null ? void 0 : _a.call(props);
    } catch (error) {
      (_b = void 0) == null ? void 0 : _b.call(props, error);
    }
  });
  return { archiveAllRead: archiveAllRead2 };
};
var useNotificationsInfiniteScroll = (props) => {
  const novu = useNovu();
  let filter = __spreadValues({}, props.options());
  const [data2, { initialLoading, setEl, end, mutate, reset: reset2 }] = createInfiniteScroll(
    (after) => __async(void 0, null, function* () {
      var _a, _b;
      const { data: data22 } = yield novu.notifications.list(__spreadProps(__spreadValues({}, props.options() || {}), { after }));
      return { data: (_a = data22 == null ? void 0 : data22.notifications) != null ? _a : [], hasMore: (_b = data22 == null ? void 0 : data22.hasMore) != null ? _b : false };
    }),
    {
      paginationField: "id"
    }
  );
  onMount(() => {
    const listener = ({ data: data22 }) => {
      if (!data22 || !isSameFilter(filter, data22.filter)) {
        return;
      }
      mutate({ data: data22.notifications, hasMore: data22.hasMore });
    };
    const cleanup = novu.on("notifications.list.updated", listener);
    onCleanup(() => cleanup());
  });
  createEffect(() => __async(void 0, null, function* () {
    const newFilter = __spreadValues({}, props.options());
    if (isSameFilter(filter, newFilter)) {
      return;
    }
    novu.notifications.clearCache();
    yield reset2();
    filter = newFilter;
  }));
  const refetch = (_0) => __async(void 0, [_0], function* ({ filter: filter2 }) {
    novu.notifications.clearCache({ filter: filter2 });
    yield reset2();
  });
  return { data: data2, initialLoading, setEl, end, refetch };
};
var usePreferences = (options) => {
  const novu = useNovu();
  const [loading, setLoading] = createSignal(true);
  const [preferences, { mutate, refetch }] = createResource(options || {}, (_0) => __async(void 0, [_0], function* ({ tags }) {
    try {
      const response = yield novu.preferences.list({ tags });
      return response.data;
    } catch (error) {
      console.error("Error fetching preferences:", error);
      throw error;
    }
  }));
  onMount(() => {
    const listener = ({ data: data2 }) => {
      if (!data2) {
        return;
      }
      mutate(data2);
    };
    const cleanup = novu.on("preferences.list.updated", listener);
    onCleanup(() => cleanup());
  });
  createEffect(() => {
    setLoading(preferences.loading);
  });
  return { preferences, loading, mutate, refetch };
};
var useReadAll = (props) => {
  const novu = useNovu();
  const readAll2 = (..._0) => __async(void 0, [..._0], function* ({ tags } = {}) {
    var _a, _b;
    try {
      yield novu.notifications.readAll({ tags });
      (_a = props == null ? void 0 : props.onSuccess) == null ? void 0 : _a.call(props);
    } catch (error) {
      (_b = void 0) == null ? void 0 : _b.call(props, error);
    }
  });
  return { readAll: readAll2 };
};
var _tmpl$35 = template(`<span>`);
var MoreActionsOptions = () => {
  const {
    filter
  } = useInboxContext();
  const {
    readAll: readAll2
  } = useReadAll();
  const {
    archiveAll: archiveAll2
  } = useArchiveAll();
  const {
    archiveAllRead: archiveAllRead2
  } = useArchiveAllRead();
  return [createComponent(ActionsItem, {
    localizationKey: "notifications.actions.readAll",
    onClick: () => readAll2({
      tags: filter().tags
    }),
    icon: MarkAsRead
  }), createComponent(ActionsItem, {
    localizationKey: "notifications.actions.archiveAll",
    onClick: () => archiveAll2({
      tags: filter().tags
    }),
    icon: MarkAsArchived
  }), createComponent(ActionsItem, {
    localizationKey: "notifications.actions.archiveRead",
    onClick: () => archiveAllRead2({
      tags: filter().tags
    }),
    icon: MarkAsArchivedRead
  })];
};
var ActionsItem = (props) => {
  const style3 = useStyle();
  const {
    t
  } = useLocalization();
  return createComponent(Dropdown.Item, {
    get ["class"]() {
      return style3("moreActions__dropdownItem", cn(dropdownItemVariants(), "nt-flex nt-gap-2"));
    },
    get onClick() {
      return props.onClick;
    },
    get children() {
      return [(() => {
        var _el$ = _tmpl$35();
        insert(_el$, () => props.icon());
        createRenderEffect(() => className(_el$, style3("moreActions__dropdownItemLeft__icon", "nt-size-3")));
        return _el$;
      })(), (() => {
        var _el$2 = _tmpl$35();
        insert(_el$2, () => t(props.localizationKey));
        createRenderEffect((_p$) => {
          var _v$ = props.localizationKey, _v$2 = style3("moreActions__dropdownItemLabel", "nt-leading-none");
          _v$ !== _p$.e && setAttribute(_el$2, "data-localization", _p$.e = _v$);
          _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
          return _p$;
        }, {
          e: void 0,
          t: void 0
        });
        return _el$2;
      })()];
    }
  });
};
var MoreActionsDropdown = () => {
  const style3 = useStyle();
  const {
    status
  } = useInboxContext();
  return createComponent(Show, {
    get when() {
      return memo(
        () => status() !== "archived"
        /* ARCHIVED */
      )() && status() !== "snoozed";
    },
    get children() {
      return createComponent(Dropdown.Root, {
        get children() {
          return [createComponent(Dropdown.Trigger, {
            get ["class"]() {
              return style3("moreActions__dropdownTrigger");
            },
            asChild: (triggerProps) => createComponent(Button, mergeProps({
              variant: "ghost",
              size: "iconSm"
            }, triggerProps, {
              get children() {
                return createComponent(Dots, {
                  get ["class"]() {
                    return style3("moreActions__dots", "nt-size-5");
                  }
                });
              }
            }))
          }), createComponent(Dropdown.Content, {
            appearanceKey: "moreActions__dropdownContent",
            get children() {
              return createComponent(MoreActionsOptions, {});
            }
          })];
        }
      });
    }
  });
};
var _tmpl$36 = template(`<div>`);
var ActionsContainer = (props) => {
  const style3 = useStyle();
  return (() => {
    var _el$ = _tmpl$36();
    insert(_el$, createComponent(MoreActionsDropdown, {}), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return props.showPreferences;
      },
      children: (showPreferences) => createComponent(Button, {
        appearanceKey: "preferences__button",
        variant: "ghost",
        size: "iconSm",
        get onClick() {
          return showPreferences();
        },
        get children() {
          return createComponent(Settings, {
            get ["class"]() {
              return style3("preferences__icon", "nt-size-5");
            }
          });
        }
      })
    }), null);
    createRenderEffect(() => className(_el$, style3("moreActionsContainer", "nt-flex nt-gap-3")));
    return _el$;
  })();
};
var _tmpl$37 = template(`<div>`);
var Header = (props) => {
  const style3 = useStyle();
  return (() => {
    var _el$ = _tmpl$37();
    insert(_el$, createComponent(StatusDropdown, {}), null);
    insert(_el$, createComponent(ActionsContainer, {
      get showPreferences() {
        return props.navigateToPreferences;
      }
    }), null);
    createRenderEffect(() => className(_el$, style3("inboxHeader", cn("nt-flex nt-bg-neutral-alpha-25 nt-shrink-0 nt-justify-between nt-items-center nt-w-full nt-pb-2 nt-pt-2.5 nt-px-4"))));
    return _el$;
  })();
};
var _tmpl$38 = template(`<div>`);
var Root = (props) => {
  const [_, rest] = splitProps(props, ["class"]);
  const {
    id
  } = useAppearance();
  const style3 = useStyle();
  const {
    hideBranding
  } = useInboxContext();
  return [createComponent(Show, {
    get when() {
      return !hideBranding();
    },
    children: new Comment(" Powered by Novu - https://novu.co ")
  }), (() => {
    var _el$ = _tmpl$38();
    spread(_el$, mergeProps({
      get id() {
        return `novu-root-${id()}`;
      },
      get ["class"]() {
        return style3("root"), cn("novu", id(), "nt-text-foreground nt-h-full");
      }
    }, rest), false, false);
    return _el$;
  })()];
};
var _tmpl$39 = template(`<div>`);
var Collapsible = (props) => {
  const style3 = useStyle();
  let contentRef;
  const [enableTransition, setEnableTransition] = createSignal(false);
  createEffect(() => {
    requestAnimationFrame(() => setEnableTransition(true));
  });
  return (() => {
    var _el$ = _tmpl$39();
    var _ref$ = contentRef;
    typeof _ref$ === "function" ? use(_ref$, _el$) : contentRef = _el$;
    spread(_el$, mergeProps({
      get ["class"]() {
        return style3("collapsible", props.class);
      },
      get style() {
        return {
          overflow: "hidden",
          opacity: props.open ? 1 : 0,
          transition: enableTransition() ? "height 250ms ease-in-out, opacity 250ms ease-in-out" : "none",
          height: props.open ? `${contentRef == null ? void 0 : contentRef.scrollHeight}px` : "0px"
        };
      }
    }, props), false, false);
    return _el$;
  })();
};
var _tmpl$40 = template(`<label><input type=checkbox class="nt-peer nt-sr-only"><div>`);
var Switch2 = (props) => {
  const style3 = useStyle();
  return (() => {
    var _el$ = _tmpl$40(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
    _el$2.addEventListener("change", (e) => {
      props.onChange(e.target.checked);
    });
    createRenderEffect((_p$) => {
      var _v$ = style3("channelSwitch", `nt-relative nt-inline-flex nt-cursor-pointer nt-items-center`), _v$2 = style3("channelSwitchThumb", `nt-peer nt-h-4 nt-w-7 nt-rounded-full peer-checked:nt-shadow-none peer-checked:nt-border-neutral-alpha-400 nt-bg-neutral-alpha-300 after:nt-absolute after:nt-top-0.5 after:nt-size-3 after:nt-left-0.5 after:nt-rounded-full after:nt-bg-background after:nt-transition-all after:nt-content-[''] peer-checked:nt-bg-primary peer-checked:after:nt-translate-x-full peer-checked:after:nt-border-background nt-transition-all nt-duration-200 after:nt-duration-200 shadow-sm`), _v$3 = props.checked;
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$3, _p$.t = _v$2);
      _v$3 !== _p$.a && setAttribute(_el$3, "data-checked", _p$.a = _v$3);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    createRenderEffect(() => _el$2.checked = props.checked);
    return _el$;
  })();
};
var _tmpl$41 = template(`<div><div><div></div><span></span></div><div>`);
var ChannelRow = (props) => {
  const style3 = useStyle();
  const updatePreference2 = (enabled) => __async(void 0, null, function* () {
    props.onChange({
      channel: props.channel,
      enabled,
      workflowId: props.workflowId
    });
  });
  const onChange = (checked) => __async(void 0, null, function* () {
    yield updatePreference2(checked);
  });
  return (() => {
    var _el$ = _tmpl$41(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling, _el$5 = _el$2.nextSibling;
    insert(_el$3, createComponent(ChannelIcon, {
      appearanceKey: "channel__icon",
      get channel() {
        return props.channel;
      },
      "class": "nt-size-3"
    }));
    insert(_el$4, () => getLabel(props.channel));
    insert(_el$5, createComponent(Switch2, {
      get checked() {
        return props.enabled;
      },
      onChange: (checked) => onChange(checked)
    }));
    createRenderEffect((_p$) => {
      var _v$ = style3("channelContainer", "nt-flex nt-justify-between nt-items-center nt-gap-2 data-[disabled=true]:nt-text-foreground-alpha-600"), _v$2 = style3("channelLabelContainer", "nt-flex nt-items-center nt-gap-2 nt-text-foreground"), _v$3 = style3("channelIconContainer", "nt-p-1 nt-rounded-md nt-bg-neutral-alpha-25 nt-text-foreground-alpha-300"), _v$4 = style3("channelLabel", "nt-text-sm nt-font-semibold"), _v$5 = style3("channelSwitchContainer", "nt-flex nt-items-center");
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
      _v$3 !== _p$.a && className(_el$3, _p$.a = _v$3);
      _v$4 !== _p$.o && className(_el$4, _p$.o = _v$4);
      _v$5 !== _p$.i && className(_el$5, _p$.i = _v$5);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0
    });
    return _el$;
  })();
};
var ChannelIcon = (props) => {
  const style3 = useStyle();
  switch (props.channel) {
    case "in_app":
      return createComponent(InApp, {
        get ["class"]() {
          return style3(props.appearanceKey, props.class);
        }
      });
    case "email":
      return createComponent(Email, {
        get ["class"]() {
          return style3(props.appearanceKey, props.class);
        }
      });
    case "push":
      return createComponent(Push, {
        get ["class"]() {
          return style3(props.appearanceKey, props.class);
        }
      });
    case "sms":
      return createComponent(Sms, {
        get ["class"]() {
          return style3(props.appearanceKey, props.class);
        }
      });
    case "chat":
      return createComponent(Chat, {
        get ["class"]() {
          return style3(props.appearanceKey, props.class);
        }
      });
    default:
      return null;
  }
};
var getLabel = (channel) => {
  switch (channel) {
    case "in_app":
      return "In-App";
    case "email":
      return "Email";
    case "push":
      return "Push";
    case "sms":
      return "SMS";
    case "chat":
      return "Chat";
    default:
      return "";
  }
};
var _tmpl$43 = template(`<div>`);
var _tmpl$211 = template(`<div><div></div><div>`);
var SkeletonText = (props) => {
  const style3 = useStyle();
  return (() => {
    var _el$ = _tmpl$43();
    createRenderEffect(() => className(_el$, style3(props.appearanceKey, cn("nt-w-full nt-h-3 nt-rounded nt-bg-gradient-to-r nt-from-foreground-alpha-50 nt-to-transparent", props.class))));
    return _el$;
  })();
};
var SkeletonAvatar = (props) => {
  const style3 = useStyle();
  return (() => {
    var _el$2 = _tmpl$43();
    createRenderEffect(() => className(_el$2, style3(props.appearanceKey, cn("nt-size-8 nt-rounded-lg nt-bg-gradient-to-r nt-from-foreground-alpha-50 nt-to-transparent", props.class))));
    return _el$2;
  })();
};
var SkeletonSwitch = (props) => {
  const style3 = useStyle();
  return (() => {
    var _el$3 = _tmpl$211(), _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling;
    createRenderEffect((_p$) => {
      var _v$ = style3(props.appearanceKey, cn("nt-relative nt-inline-flex nt-items-center", props.class)), _v$2 = style3(props.appearanceKey, "nt-h-4 nt-w-7 nt-rounded-full nt-bg-gradient-to-r nt-from-foreground-alpha-50 nt-to-transparent"), _v$3 = style3(props.thumbAppearanceKey, "nt-absolute nt-top-0.5 nt-left-0.5 nt-size-3 nt-rounded-full nt-bg-background nt-shadow");
      _v$ !== _p$.e && className(_el$3, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$4, _p$.t = _v$2);
      _v$3 !== _p$.a && className(_el$5, _p$.a = _v$3);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$3;
  })();
};
var _tmpl$44 = template(`<div>`);
var channelIcons = [InApp, Email, Sms, Push, Chat];
var PreferencesListSkeleton = (props) => {
  const style3 = useStyle();
  const {
    t
  } = useLocalization();
  return (() => {
    var _el$ = _tmpl$44();
    insert(_el$, createComponent(Motion2.div, {
      get animate() {
        return {
          scale: props.loading ? 1 : 0.7
        };
      },
      transition: {
        duration: 0.6,
        easing: [0.39, 0.24, 0.3, 1],
        delay: 0.3
      },
      get ["class"]() {
        return style3("preferencesList__skeleton", "nt-flex nt-relative nt-mx-auto nt-flex-col nt-w-full nt-mb-4");
      },
      get children() {
        return [memo(() => Array.from({
          length: 5
        }).map((_, i2) => {
          const Icon = channelIcons[i2];
          return createComponent(Motion2.div, {
            get animate() {
              return {
                marginBottom: props.loading ? 0 : "16px",
                borderWidth: props.loading ? 0 : "1px",
                borderRadius: props.loading ? 0 : "var(--nv-radius-lg)"
              };
            },
            transition: {
              duration: 0.5,
              delay: 0.3,
              easing: "ease-in-out"
            },
            get ["class"]() {
              return style3("preferencesList__skeletonContent", "nt-flex nt-border-neutral-alpha-50 nt-items-center nt-gap-3 nt-p-3 nt-bg-neutral-alpha-25");
            },
            get children() {
              return [createComponent(Icon, {
                get ["class"]() {
                  return style3("preferencesList__skeletonIcon", "nt-size-8 nt-p-2 nt-rounded-lg nt-bg-neutral-alpha-100");
                }
              }), (() => {
                var _el$3 = _tmpl$44();
                insert(_el$3, createComponent(SkeletonText, {
                  appearanceKey: "notificationList__skeletonText",
                  "class": "nt-h-2 nt-w-1/3 nt-bg-neutral-alpha-50 nt-rounded"
                }), null);
                insert(_el$3, createComponent(SkeletonText, {
                  appearanceKey: "preferencesList__skeletonText",
                  "class": "nt-h-2 nt-w-2/3 nt-bg-neutral-alpha-50 nt-rounded"
                }), null);
                createRenderEffect(() => className(_el$3, style3("preferencesList__skeletonItem", "nt-flex nt-flex-col nt-gap-2 nt-flex-1")));
                return _el$3;
              })(), createComponent(SkeletonSwitch, {
                appearanceKey: "preferencesList__skeletonSwitch",
                thumbAppearanceKey: "preferencesList__skeletonSwitchThumb"
              })];
            }
          });
        })), (() => {
          var _el$2 = _tmpl$44();
          createRenderEffect(() => className(_el$2, style3("notificationListEmptyNoticeOverlay", "nt-absolute nt-size-full nt-z-10 nt-inset-0 nt-bg-gradient-to-b nt-from-transparent nt-to-background")));
          return _el$2;
        })()];
      }
    }), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return !props.loading;
      },
      get children() {
        return createComponent(Motion2.p, {
          initial: {
            opacity: 0,
            y: -4,
            filter: "blur(4px)"
          },
          get animate() {
            return {
              opacity: props.loading ? 0 : 1,
              y: 0,
              filter: "blur(0px)"
            };
          },
          transition: {
            duration: 0.7,
            easing: [0.39, 0.24, 0.3, 1],
            delay: 0.6
          },
          get ["class"]() {
            return style3("preferencesListEmptyNotice"), "nt-text-center";
          },
          "data-localization": "preferences.emptyNotice",
          get children() {
            return t("preferences.emptyNotice");
          }
        });
      }
    }), null);
    createRenderEffect(() => className(_el$, style3("preferencesListEmptyNoticeContainer", "nt-flex nt-flex-col nt-items-center nt-h-fit nt-w-full nt-text-sm nt-text-foreground-alpha-400 nt-text-center")));
    return _el$;
  })();
};
var _tmpl$45 = template(`<div>`);
var _tmpl$212 = template(`<span>`);
var _tmpl$310 = template(`<div><div><div><div></div></div><span>`);
var Preferences2 = () => {
  var _a;
  const style3 = useStyle();
  const {
    preferencesFilter
  } = useInboxContext();
  const {
    preferences,
    loading
  } = usePreferences({
    tags: (_a = preferencesFilter()) == null ? void 0 : _a.tags
  });
  const allPreferences = createMemo(() => {
    var _a2, _b;
    const globalPreference = (_a2 = preferences()) == null ? void 0 : _a2.find(
      (preference) => preference.level === "global"
      /* GLOBAL */
    );
    const workflowPreferences = (_b = preferences()) == null ? void 0 : _b.filter(
      (preference) => preference.level === "template"
      /* TEMPLATE */
    );
    const workflowPreferencesIds = workflowPreferences == null ? void 0 : workflowPreferences.map((preference) => {
      var _a3;
      return (_a3 = preference.workflow) == null ? void 0 : _a3.id;
    });
    return {
      globalPreference,
      workflowPreferences,
      workflowPreferencesIds
    };
  });
  createEffect(() => {
    setDynamicLocalization((prev2) => {
      var _a2;
      return __spreadValues(__spreadValues({}, prev2), (_a2 = allPreferences().workflowPreferences) == null ? void 0 : _a2.reduce((acc, preference) => {
        acc[preference.workflow.identifier] = preference.workflow.name;
        return acc;
      }, {}));
    });
  });
  const optimisticUpdate = (preference) => (_0) => __async(void 0, [_0], function* ({
    channel,
    enabled
  }) {
    yield preference == null ? void 0 : preference.update({
      channels: {
        [channel]: enabled
      }
    });
  });
  return (() => {
    var _el$ = _tmpl$45();
    insert(_el$, createComponent(PreferencesRow, {
      localizationKey: "preferences.global",
      get channels() {
        var _a2;
        return ((_a2 = allPreferences().globalPreference) == null ? void 0 : _a2.channels) || {};
      },
      get onChange() {
        return optimisticUpdate(allPreferences().globalPreference);
      }
    }), null);
    insert(_el$, createComponent(Show, {
      get when() {
        var _a2;
        return (_a2 = allPreferences().workflowPreferences) == null ? void 0 : _a2.length;
      },
      get fallback() {
        return createComponent(PreferencesListSkeleton, {
          get loading() {
            return loading();
          }
        });
      },
      get children() {
        return createComponent(For, {
          get each() {
            return allPreferences().workflowPreferencesIds;
          },
          children: (_, index) => {
            const preference = () => {
              var _a2;
              return (_a2 = allPreferences().workflowPreferences) == null ? void 0 : _a2[index()];
            };
            if (!preference()) {
              return null;
            }
            return createComponent(PreferencesRow, {
              get localizationKey() {
                return preference().workflow.identifier;
              },
              get channels() {
                return preference().channels;
              },
              get workflowId() {
                var _a2;
                return (_a2 = preference().workflow) == null ? void 0 : _a2.id;
              },
              get onChange() {
                return optimisticUpdate(preference());
              }
            });
          }
        });
      }
    }), null);
    createRenderEffect(() => className(_el$, style3("preferencesContainer", "nt-px-3 nt-py-4 nt-flex nt-flex-col nt-gap-1 nt-overflow-y-auto nt-h-full")));
    return _el$;
  })();
};
var WorkflowDescription = (props) => {
  const style3 = useStyle();
  const channelNames = () => {
    const channels = [];
    for (const key in props.channels) {
      if (props.channels[key] !== void 0) {
        const isDisabled = !props.channels[key];
        const element = (() => {
          var _el$2 = _tmpl$212();
          setAttribute(_el$2, "data-disabled", isDisabled);
          insert(_el$2, () => getLabel(key));
          createRenderEffect(() => className(_el$2, style3("channelName", "data-[disabled=true]:nt-text-foreground-alpha-400")));
          return _el$2;
        })();
        channels.push(element);
      }
    }
    return channels.map((c, index) => [c, memo(() => index < channels.length - 1 && ", ")]);
  };
  return (() => {
    var _el$3 = _tmpl$45();
    insert(_el$3, channelNames);
    createRenderEffect(() => className(_el$3, style3(props.appearanceKey, cn("nt-text-sm nt-text-foreground-alpha-600 nt-text-start", props.class))));
    return _el$3;
  })();
};
var PreferencesRow = (props) => {
  const style3 = useStyle();
  const [isOpenDescription, setIsOpenDescription] = createSignal(true);
  const [isOpenChannels, setIsOpenChannels] = createSignal(false);
  const {
    t
  } = useLocalization();
  const channels = createMemo(() => Object.keys(props.channels));
  return createComponent(Show, {
    get when() {
      return channels().length > 0;
    },
    get children() {
      var _el$4 = _tmpl$310(), _el$5 = _el$4.firstChild, _el$6 = _el$5.firstChild, _el$7 = _el$6.firstChild, _el$8 = _el$6.nextSibling;
      _el$5.$$click = () => {
        setIsOpenChannels((prev2) => !prev2);
        setIsOpenDescription((prev2) => !prev2);
      };
      insert(_el$7, () => t(props.localizationKey));
      insert(_el$6, createComponent(Collapsible, {
        get open() {
          return isOpenDescription();
        },
        get children() {
          return createComponent(WorkflowDescription, {
            get channels() {
              return props.channels;
            },
            appearanceKey: "workflowDescription",
            "class": "nt-overflow-hidden"
          });
        }
      }), null);
      insert(_el$8, createComponent(ArrowDropDown, {
        get ["class"]() {
          return style3("workflowArrow__icon", "nt-text-foreground-alpha-600 nt-size-4");
        }
      }));
      insert(_el$4, createComponent(Collapsible, {
        get open() {
          return isOpenChannels();
        },
        get children() {
          var _el$9 = _tmpl$45();
          insert(_el$9, createComponent(For, {
            get each() {
              return channels();
            },
            children: (channel) => createComponent(ChannelRow, {
              channel,
              get enabled() {
                return !!props.channels[channel];
              },
              get workflowId() {
                return props.workflowId;
              },
              get onChange() {
                return props.onChange;
              }
            })
          }));
          createRenderEffect(() => className(_el$9, style3("channelsContainer", "nt-flex nt-bg-background nt-border nt-border-neutral-alpha-50 nt-rounded-lg nt-p-2 nt-flex-col nt-gap-1 nt-overflow-hidden")));
          return _el$9;
        }
      }), null);
      createRenderEffect((_p$) => {
        var _v$ = style3("workflowContainer", `nt-p-1 nt-bg-neutral-alpha-25 nt-rounded-lg`), _v$2 = isOpenChannels(), _v$3 = style3("workflowLabelContainer", "nt-flex nt-justify-between nt-p-1 nt-flex-nowrap nt-self-stretch nt-cursor-pointer nt-items-center nt-overflow-hidden"), _v$4 = style3("workflowLabelHeader", "nt-overflow-hidden"), _v$5 = style3("workflowLabel", "nt-text-sm nt-font-semibold nt-truncate"), _v$6 = props.localizationKey, _v$7 = isOpenChannels(), _v$8 = style3("workflowContainerRight__icon", `nt-text-foreground-alpha-600 nt-transition-all nt-duration-200 data-[open=true]:nt-transform data-[open=true]:nt-rotate-180`), _v$9 = isOpenChannels();
        _v$ !== _p$.e && className(_el$4, _p$.e = _v$);
        _v$2 !== _p$.t && setAttribute(_el$4, "data-open", _p$.t = _v$2);
        _v$3 !== _p$.a && className(_el$5, _p$.a = _v$3);
        _v$4 !== _p$.o && className(_el$6, _p$.o = _v$4);
        _v$5 !== _p$.i && className(_el$7, _p$.i = _v$5);
        _v$6 !== _p$.n && setAttribute(_el$7, "data-localization", _p$.n = _v$6);
        _v$7 !== _p$.s && setAttribute(_el$7, "data-open", _p$.s = _v$7);
        _v$8 !== _p$.h && className(_el$8, _p$.h = _v$8);
        _v$9 !== _p$.r && setAttribute(_el$8, "data-open", _p$.r = _v$9);
        return _p$;
      }, {
        e: void 0,
        t: void 0,
        a: void 0,
        o: void 0,
        i: void 0,
        n: void 0,
        s: void 0,
        h: void 0,
        r: void 0
      });
      return _el$4;
    }
  });
};
delegateEvents(["click"]);
var _tmpl$46 = template(`<div><div data-localization=preferences.title>`);
var PreferencesHeader = (props) => {
  const style3 = useStyle();
  const {
    t
  } = useLocalization();
  return (() => {
    var _el$ = _tmpl$46(), _el$2 = _el$.firstChild;
    insert(_el$, createComponent(Show, {
      get when() {
        return props.navigateToNotifications;
      },
      children: (navigateToNotifications) => createComponent(Button, {
        appearanceKey: "preferencesHeader__back__button",
        "class": "nt-text-foreground-alpha-600",
        variant: "unstyled",
        size: "none",
        get onClick() {
          return navigateToNotifications();
        },
        get children() {
          return createComponent(ArrowLeft, {
            get ["class"]() {
              return style3("preferencesHeader__back__button__icon", "nt-size-4");
            }
          });
        }
      })
    }), _el$2);
    insert(_el$2, () => t("preferences.title"));
    createRenderEffect((_p$) => {
      var _v$ = style3("preferencesHeader", "nt-flex nt-bg-neutral-alpha-25 nt-shrink-0 nt-border-b nt-border-border nt-items-center nt-py-3.5 nt-px-4 nt-gap-2"), _v$2 = style3("preferencesHeader__title", "nt-text-base nt-font-medium");
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$;
  })();
};
var useTabsDropdown = ({ tabs }) => {
  const [tabsList, setTabsList] = createSignal();
  const [visibleTabs, setVisibleTabs] = createSignal([]);
  const [dropdownTabs, setDropdownTabs] = createSignal([]);
  onMount(() => {
    const tabsListEl = tabsList();
    if (!tabsListEl) return;
    const tabsElements = [...tabsListEl.querySelectorAll('[role="tab"]')];
    const observer = new IntersectionObserver(
      (entries) => {
        let visibleTabIds = entries.filter((entry) => entry.isIntersecting && entry.intersectionRatio === 1).map((entry) => entry.target.id);
        if (tabsElements.length === visibleTabIds.length) {
          setVisibleTabs(tabs.filter((tab) => visibleTabIds.includes(tab.label)));
          observer.disconnect();
          return;
        }
        visibleTabIds = visibleTabIds.slice(0, -1);
        setVisibleTabs(tabs.filter((tab) => visibleTabIds.includes(tab.label)));
        setDropdownTabs(tabs.filter((tab) => !visibleTabIds.includes(tab.label)));
        observer.disconnect();
      },
      { root: tabsListEl }
    );
    for (const tabElement of tabsElements) {
      observer.observe(tabElement);
    }
  });
  return { dropdownTabs, setTabsList, visibleTabs };
};
var _tmpl$47 = template(`<svg viewBox="0 0 20 20"fill=none xmlns=http://www.w3.org/2000/svg><path d="M10.0001 10.879L13.7126 7.1665L14.7731 8.227L10.0001 13L5.22705 8.227L6.28755 7.1665L10.0001 10.879Z"fill=currentColor>`);
var ArrowDown = (props) => {
  return (() => {
    var _el$ = _tmpl$47();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$48 = template(`<svg viewBox="0 0 12 12"fill=none xmlns=http://www.w3.org/2000/svg><g clip-path=url(#clip0_3188_15050)><path d="M6 3V6L8 7M11 6C11 8.76142 8.76142 11 6 11C3.23858 11 1 8.76142 1 6C1 3.23858 3.23858 1 6 1C8.76142 1 11 3.23858 11 6Z"stroke=currentColor stroke-linecap=round stroke-linejoin=round>`);
var Clock = (props) => {
  return (() => {
    var _el$ = _tmpl$48();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$49 = template(`<strong>`);
var _tmpl$213 = template(`<p>`);
var Bold = (props) => {
  const style3 = useStyle();
  return (() => {
    var _el$ = _tmpl$49();
    insert(_el$, () => props.children);
    createRenderEffect(() => className(_el$, style3(props.appearanceKey || "strong", "nt-font-semibold")));
    return _el$;
  })();
};
var Text = (props) => props.children;
var Markdown = (props) => {
  const [local, rest] = splitProps(props, ["class", "children", "appearanceKey", "strongAppearanceKey"]);
  const style3 = useStyle();
  const tokens = createMemo(() => parseMarkdownIntoTokens(local.children));
  return (() => {
    var _el$2 = _tmpl$213();
    spread(_el$2, mergeProps({
      get ["class"]() {
        return style3(local.appearanceKey, cn(local.class));
      }
    }, rest), false, true);
    insert(_el$2, createComponent(For, {
      get each() {
        return tokens();
      },
      children: (token) => {
        if (token.type === "bold") {
          return createComponent(Bold, {
            get appearanceKey() {
              return local.strongAppearanceKey;
            },
            get children() {
              return token.content;
            }
          });
        } else {
          return createComponent(Text, {
            get children() {
              return token.content;
            }
          });
        }
      }
    }));
    return _el$2;
  })();
};
var Markdown_default = Markdown;
var _tmpl$50 = template(`<span>`);
var badgeVariants = cva(cn("nt-inline-flex nt-flex-row nt-gap-1 nt-items-center"), {
  variants: {
    variant: {
      secondary: "nt-bg-neutral-alpha-50"
    },
    size: {
      default: "nt-px-1 nt-py-px nt-rounded-sm nt-text-xs nt-px-1"
    }
  },
  defaultVariants: {
    variant: "secondary",
    size: "default"
  }
});
var Badge = (props) => {
  const [local, rest] = splitProps(props, ["class", "appearanceKey"]);
  const style3 = useStyle();
  return (() => {
    var _el$ = _tmpl$50();
    spread(_el$, mergeProps({
      get ["data-variant"]() {
        return props.variant;
      },
      get ["data-size"]() {
        return props.size;
      },
      get ["class"]() {
        return style3(local.appearanceKey || "badge", cn(badgeVariants({
          variant: props.variant,
          size: props.size
        }), local.class));
      }
    }, rest), false, false);
    return _el$;
  })();
};
var _tmpl$51 = template(`<svg viewBox="0 0 10 10"fill=none xmlns=http://www.w3.org/2000/svg><path d="M4.99992 2.91634V4.99967M4.79992 5.39616L3.27392 6.46553M1.66659 1.66634L8.33325 8.33301M9.16658 4.99967C9.16658 7.30086 7.30111 9.16634 4.99992 9.16634C2.69873 9.16634 0.833252 7.30086 0.833252 4.99967C0.833252 2.69849 2.69873 0.833008 4.99992 0.833008C7.30111 0.833008 9.16658 2.69849 9.16658 4.99967Z"stroke=currentColor stroke-linecap=round stroke-linejoin=round>`);
var Unsnooze = (props) => {
  return (() => {
    var _el$ = _tmpl$51();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var TooltipContext = createContext(void 0);
function TooltipRoot(props) {
  const [reference, setReference] = createSignal(null);
  const [floating, setFloating] = createSignal(null);
  const position = useFloating(reference, floating, {
    placement: props.placement || "top",
    strategy: "absolute",
    whileElementsMounted: autoUpdate,
    middleware: [offset2(10), flip2({
      fallbackPlacements: props.fallbackPlacements || ["bottom"]
    }), shift2()]
  });
  const [isOpen, setIsOpen] = useUncontrolledState({
    value: props.open,
    fallbackValue: false
  });
  return createComponent(TooltipContext.Provider, {
    value: {
      reference,
      setReference,
      floating,
      setFloating,
      open: isOpen,
      setOpen: setIsOpen,
      floatingStyles: () => {
        var _a, _b;
        return {
          position: position.strategy,
          top: `${(_a = position.y) != null ? _a : 0}px`,
          left: `${(_b = position.x) != null ? _b : 0}px`
        };
      }
    },
    get children() {
      return props.children;
    }
  });
}
function useTooltip() {
  const context = useContext(TooltipContext);
  if (!context) {
    throw new Error("useTooltip must be used within Tooltip.Root component");
  }
  return context;
}
var _tmpl$52 = template(`<div>`);
var tooltipContentVariants = () => "nt-bg-foreground nt-p-2 nt-shadow-tooltip nt-rounded-lg nt-text-background nt-text-xs";
var TooltipContentBody = (props) => {
  const {
    open,
    setFloating,
    floating,
    floatingStyles
  } = useTooltip();
  const {
    setActive,
    removeActive
  } = useFocusManager();
  const [local, rest] = splitProps(props, ["class", "appearanceKey", "style"]);
  const style3 = useStyle();
  onMount(() => {
    const floatingEl = floating();
    setActive(floatingEl);
    onCleanup(() => {
      removeActive(floatingEl);
    });
  });
  return (() => {
    var _el$ = _tmpl$52();
    use(setFloating, _el$);
    spread(_el$, mergeProps({
      get ["class"]() {
        return memo(() => !!local.class)() ? local.class : style3(local.appearanceKey || "tooltipContent", tooltipContentVariants());
      },
      get style() {
        return __spreadProps(__spreadValues({}, floatingStyles()), {
          "z-index": 99999
        });
      },
      get ["data-open"]() {
        return open();
      }
    }, rest), false, false);
    return _el$;
  })();
};
var TooltipContent = (props) => {
  const {
    open
  } = useTooltip();
  return createComponent(Show, {
    get when() {
      return open();
    },
    get children() {
      return createComponent(Portal, {
        get children() {
          return createComponent(Root, {
            get children() {
              return createComponent(TooltipContentBody, props);
            }
          });
        }
      });
    }
  });
};
var _tmpl$53 = template(`<button>`);
var TooltipTrigger = (props) => {
  const {
    setReference,
    setOpen
  } = useTooltip();
  const style3 = useStyle();
  const [local, rest] = splitProps(props, ["appearanceKey", "asChild", "onClick", "onMouseEnter", "onMouseLeave", "ref"]);
  const handleMouseEnter = (e) => {
    if (typeof local.onMouseEnter === "function") {
      local.onMouseEnter(e);
    }
    setOpen(true);
  };
  const ref = createMemo(() => local.ref ? mergeRefs(setReference, local.ref) : setReference);
  const handleMouseLeave = (e) => {
    if (typeof local.onMouseLeave === "function") {
      local.onMouseLeave(e);
    }
    setOpen(false);
  };
  if (local.asChild) {
    return createComponent(Dynamic, mergeProps({
      get component() {
        return local.asChild;
      },
      ref(r$) {
        var _ref$ = ref();
        typeof _ref$ === "function" && _ref$(r$);
      },
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave
    }, rest));
  }
  return (() => {
    var _el$ = _tmpl$53();
    _el$.addEventListener("mouseleave", () => {
      setOpen(false);
    });
    _el$.addEventListener("mouseenter", () => {
      setOpen(true);
    });
    var _ref$2 = ref();
    typeof _ref$2 === "function" && use(_ref$2, _el$);
    spread(_el$, mergeProps({
      get ["class"]() {
        return style3(local.appearanceKey || "tooltipTrigger");
      }
    }, rest), false, true);
    insert(_el$, () => props.children);
    return _el$;
  })();
};
var Tooltip = {
  Root: TooltipRoot,
  /**
   * Tooltip.Trigger renders a `button` and has no default styling.
   */
  Trigger: TooltipTrigger,
  /**
   * Tooltip.Content renders a `div` and has popover specific styling.
   */
  Content: TooltipContent
};
var _tmpl$54 = template(`<svg viewBox="0 0 20 20"fill=none xmlns=http://www.w3.org/2000/svg><path d="M10.7957 10.0009L7.08325 6.2884L8.14375 5.2279L12.9168 10.0009L8.14375 14.7739L7.08325 13.7134L10.7957 10.0009Z"fill=currentColor>`);
var ArrowRight = (props) => {
  return (() => {
    var _el$ = _tmpl$54();
    spread(_el$, props, true, true);
    return _el$;
  })();
};
var _tmpl$55 = template(`<div>`);
var _tmpl$214 = template(`<div><span>`);
var DatePickerContext = createContext({
  currentDate: () => /* @__PURE__ */ new Date(),
  setCurrentDate: () => {
  },
  viewMonth: () => /* @__PURE__ */ new Date(),
  setViewMonth: () => {
  },
  selectedDate: () => null,
  setSelectedDate: () => {
  },
  maxDays: () => 0
});
var useDatePicker = () => useContext(DatePickerContext);
var DatePicker = (props) => {
  const [local, rest] = splitProps(props, ["children", "value", "onDateChange", "class", "maxDays"]);
  const style3 = useStyle();
  const today = /* @__PURE__ */ new Date();
  today.setHours(0, 0, 0, 0);
  const [currentDate, setCurrentDate] = createSignal(today);
  const [viewMonth, setViewMonth] = createSignal(today);
  const [selectedDate, setSelectedDate] = createSignal(local.value ? new Date(local.value) : null);
  const handleDateSelect = (date) => {
    setSelectedDate(date);
    if (local.onDateChange) {
      local.onDateChange(date);
    }
  };
  return createComponent(DatePickerContext.Provider, {
    value: {
      currentDate,
      setCurrentDate,
      viewMonth,
      setViewMonth,
      selectedDate,
      setSelectedDate: handleDateSelect,
      maxDays: () => props.maxDays
    },
    get children() {
      var _el$ = _tmpl$55();
      spread(_el$, mergeProps({
        get ["class"]() {
          return style3("datePicker", cn("nt-p-2", local.class));
        }
      }, rest), false, true);
      insert(_el$, () => local.children);
      return _el$;
    }
  });
};
var DatePickerHeader = (props) => {
  const [local, rest] = splitProps(props, ["class", "appearanceKey", "children"]);
  const style3 = useStyle();
  const {
    viewMonth,
    setViewMonth,
    currentDate,
    maxDays
  } = useDatePicker();
  const handlePrevMonth = () => {
    const date = new Date(viewMonth());
    date.setMonth(date.getMonth() - 1);
    const currentMonth = currentDate();
    if (date.getFullYear() < currentMonth.getFullYear() || date.getFullYear() === currentMonth.getFullYear() && date.getMonth() < currentMonth.getMonth()) {
      return;
    }
    setViewMonth(date);
  };
  const handleNextMonth = () => {
    const date = new Date(viewMonth());
    date.setMonth(date.getMonth() + 1);
    const maxDaysValue = maxDays();
    if (maxDaysValue > 0) {
      const maxDate = new Date(currentDate());
      maxDate.setDate(maxDate.getDate() + maxDaysValue);
      if (date.getFullYear() > maxDate.getFullYear() || date.getFullYear() === maxDate.getFullYear() && date.getMonth() > maxDate.getMonth()) {
        return;
      }
    }
    setViewMonth(date);
  };
  const isPrevDisabled = () => {
    const current = currentDate();
    const view = viewMonth();
    return view.getFullYear() === current.getFullYear() && view.getMonth() === current.getMonth();
  };
  const isNextDisabled = () => {
    const maxDaysValue = maxDays();
    if (maxDaysValue === 0) return false;
    const view = viewMonth();
    const maxDate = new Date(currentDate());
    maxDate.setDate(maxDate.getDate() + maxDaysValue);
    return view.getFullYear() === maxDate.getFullYear() && view.getMonth() === maxDate.getMonth();
  };
  return (() => {
    var _el$2 = _tmpl$214(), _el$3 = _el$2.firstChild;
    spread(_el$2, mergeProps({
      get ["class"]() {
        return style3(local.appearanceKey || "datePickerControl", cn("nt-flex nt-items-center nt-justify-between nt-gap-1.5 nt-h-7 nt-p-1 nt-mb-2 nt-rounded-lg nt-bg-background", local.class));
      }
    }, rest), false, true);
    insert(_el$2, createComponent(Button, {
      appearanceKey: "datePickerControlPrevTrigger",
      variant: "ghost",
      onClick: (e) => {
        e.stopPropagation();
        handlePrevMonth();
      },
      get disabled() {
        return isPrevDisabled();
      },
      "class": "nt-flex nt-justify-center nt-items-center nt-gap-0.5 nt-w-5 nt-h-5 nt-p-0 nt-rounded-md nt-bg-background nt-shadow-[0px_1px_2px_0px_rgba(10,13,20,0.03)]",
      get children() {
        return createComponent(ArrowLeft, {
          get ["class"]() {
            return style3("datePickerControlPrevTrigger__icon", "nt-size-4 nt-text-foreground-alpha-700");
          }
        });
      }
    }), _el$3);
    insert(_el$3, () => viewMonth().toLocaleDateString("en-US", {
      month: "long",
      year: "numeric"
    }));
    insert(_el$2, createComponent(Button, {
      appearanceKey: "datePickerControlNextTrigger",
      variant: "ghost",
      onClick: (e) => {
        e.stopPropagation();
        handleNextMonth();
      },
      get disabled() {
        return isNextDisabled();
      },
      "class": "nt-flex nt-justify-center nt-items-center nt-gap-0.5 nt-w-5 nt-h-5 nt-p-0 nt-rounded-md nt-bg-background nt-shadow-[0px_1px_2px_0px_rgba(10,13,20,0.03)]",
      get children() {
        return createComponent(ArrowRight, {
          get ["class"]() {
            return style3("datePickerControlNextTrigger__icon", "nt-size-4 nt-text-foreground-alpha-700");
          }
        });
      }
    }), null);
    createRenderEffect(() => className(_el$3, style3("datePickerHeaderMonth", "nt-text-sm nt-font-medium nt-text-foreground-alpha-700")));
    return _el$2;
  })();
};
var DatePickerGridCellTrigger = (props) => {
  const [local, rest] = splitProps(props, ["class", "appearanceKey", "date"]);
  const {
    selectedDate,
    viewMonth,
    setSelectedDate,
    currentDate,
    maxDays
  } = useDatePicker();
  const {
    t
  } = useLocalization();
  const isCurrentMonth = props.date.getMonth() === viewMonth().getMonth();
  const isPastDate = () => {
    const today = currentDate();
    return props.date < today;
  };
  const isFutureDate = () => {
    const maxDaysValue = maxDays();
    if (maxDaysValue === 0) return false;
    const maxDate = new Date(currentDate());
    maxDate.setDate(maxDate.getDate() + maxDaysValue);
    return props.date > maxDate;
  };
  const isDisabled = !isCurrentMonth || isPastDate() || isFutureDate();
  const isExceedingLimit = () => {
    return isCurrentMonth && isFutureDate();
  };
  const buttonElement = createComponent(Button, mergeProps({
    appearanceKey: "datePickerCalendarDay__button",
    variant: "ghost",
    disabled: isDisabled,
    onClick: (e) => {
      e.stopPropagation();
      setSelectedDate(local.date);
    },
    get ["class"]() {
      var _a;
      return cn("nt-size-8 nt-w-full nt-rounded-md nt-flex nt-items-center nt-justify-center", {
        "nt-text-muted-foreground disabled:nt-opacity-20": !isCurrentMonth || isPastDate(),
        "nt-text-foreground-alpha-700": isCurrentMonth && !isPastDate() && !isFutureDate()
      }, {
        "nt-bg-primary-alpha-300 hover:nt-bg-primary-alpha-400": ((_a = selectedDate()) == null ? void 0 : _a.toDateString()) === local.date.toDateString()
      });
    }
  }, rest, {
    get children() {
      return local.date.getDate();
    }
  }));
  if (isExceedingLimit()) {
    return createComponent(Tooltip.Root, {
      get children() {
        return [createComponent(Tooltip.Trigger, {
          children: buttonElement
        }), createComponent(Tooltip.Content, {
          get children() {
            return t("snooze.datePicker.exceedingLimitTooltip", {
              days: maxDays()
            });
          }
        })];
      }
    });
  }
  return buttonElement;
};
var DatePickerCalendar = (props) => {
  const [local, rest] = splitProps(props, ["class", "appearanceKey"]);
  const style3 = useStyle();
  const {
    viewMonth
  } = useDatePicker();
  const getDaysInMonth = () => {
    const year = viewMonth().getFullYear();
    const month = viewMonth().getMonth();
    const firstDay = new Date(year, month, 1);
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const startingDay = firstDay.getDay();
    const days = [];
    for (let i2 = 0; i2 < startingDay; i2 += 1) {
      const prevMonthDay = new Date(year, month, -i2);
      days.unshift(prevMonthDay);
    }
    for (let i2 = 1; i2 <= daysInMonth; i2 += 1) {
      days.push(new Date(year, month, i2));
    }
    const remainingCells = 7 - days.length % 7;
    if (remainingCells < 7) {
      for (let i2 = 1; i2 <= remainingCells; i2 += 1) {
        days.push(new Date(year, month + 1, i2));
      }
    }
    return days;
  };
  return (() => {
    var _el$8 = _tmpl$55();
    _el$8.$$click = (e) => e.stopPropagation();
    spread(_el$8, mergeProps({
      get ["class"]() {
        return style3(local.appearanceKey || "datePickerCalendar", cn("nt-grid nt-grid-cols-7 nt-gap-1", local.class));
      }
    }, rest), false, true);
    insert(_el$8, () => getDaysInMonth().map((date) => {
      return createComponent(DatePickerGridCellTrigger, {
        date
      });
    }));
    return _el$8;
  })();
};
delegateEvents(["click"]);
var _tmpl$56 = template(`<input>`);
var inputVariants = cva(cn(`focus-visible:nt-outline-none focus-visible:nt-ring-2 focus-visible:nt-rounded-md focus-visible:nt-ring-ring focus-visible:nt-ring-offset-2`), {
  variants: {
    variant: {
      default: "nt-border nt-border-neutral-200 nt-rounded-md nt-p-1 nt-bg-background"
    },
    size: {
      default: "nt-h-9",
      sm: "nt-h-8 nt-text-sm"
    }
  },
  defaultVariants: {
    variant: "default",
    size: "default"
  }
});
var Input = (props) => {
  const [local, rest] = splitProps(props, ["class", "appearanceKey"]);
  const style3 = useStyle();
  return (() => {
    var _el$ = _tmpl$56();
    spread(_el$, mergeProps({
      get ["data-variant"]() {
        return props.variant;
      },
      get ["data-size"]() {
        return props.size;
      },
      get ["class"]() {
        return style3(local.appearanceKey || "input", cn(inputVariants({
          variant: props.variant,
          size: props.size
        }), local.class));
      }
    }, rest), false, false);
    return _el$;
  })();
};
var _tmpl$57 = template(`<div><span>:</span><select><option value=AM>AM</option><option value=PM>PM`);
var TimePicker = (props) => {
  const [local, rest] = splitProps(props, ["value", "onChange", "class", "appearanceKey"]);
  const style3 = useStyle();
  const initialValue = local.value || {
    hour: 12,
    minute: 0,
    isPM: true
  };
  const [hour, setHour] = createSignal(initialValue.hour);
  const [minute, setMinute] = createSignal(initialValue.minute);
  const [isPM, setIsPM] = createSignal(initialValue.isPM);
  const notifyChange = () => {
    if (local.onChange) {
      local.onChange({
        hour: hour(),
        minute: minute(),
        isPM: isPM()
      });
    }
  };
  const handleHourChange = (newHour) => {
    setHour(newHour);
    notifyChange();
  };
  const handleMinuteChange = (newMinute) => {
    setMinute(newMinute);
    notifyChange();
  };
  const handlePeriodChange = (newIsPM) => {
    setIsPM(newIsPM);
    notifyChange();
  };
  const handleKeyDown = (e) => {
    const allowedKeys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Backspace", "Delete", "Tab"];
    if (!allowedKeys.includes(e.key)) {
      e.preventDefault();
    }
  };
  return (() => {
    var _el$ = _tmpl$57(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
    _el$.$$click = (e) => e.stopPropagation();
    spread(_el$, mergeProps({
      get ["class"]() {
        return style3(local.appearanceKey || "timePicker", cn("nt-flex nt-items-center nt-gap-1", local.class));
      }
    }, rest), false, true);
    insert(_el$, createComponent(Input, {
      size: "sm",
      type: "number",
      min: "1",
      max: "12",
      onKeyDown: (e) => {
        e.stopPropagation();
        handleKeyDown(e);
      },
      get value() {
        return hour().toString();
      },
      onInput: (e) => {
        e.stopPropagation();
        enforceMinMax(e.currentTarget);
        handleHourChange(Number(e.currentTarget.value));
      },
      get ["class"]() {
        return style3("timePickerHour__input", "nt-flex nt-font-mono nt-justify-center nt-items-center nt-text-center nt-h-7 nt-w-[calc(2ch+2rem)] nt-px-2");
      }
    }), _el$2);
    insert(_el$, createComponent(Input, {
      size: "sm",
      type: "number",
      min: "0",
      max: "59",
      onKeyDown: (e) => {
        e.stopPropagation();
        handleKeyDown(e);
      },
      get value() {
        return minute().toString().padStart(2, "0");
      },
      onInput: (e) => {
        e.stopPropagation();
        enforceMinMax(e.currentTarget);
        handleMinuteChange(Number(e.currentTarget.value));
      },
      get ["class"]() {
        return style3("timePickerHour__input", "nt-flex nt-font-mono nt-justify-center nt-items-center nt-text-center nt-h-7 nt-w-[calc(2ch+2rem)] nt-px-2");
      }
    }), _el$3);
    _el$3.addEventListener("change", (e) => {
      e.stopPropagation();
      handlePeriodChange(e.target.value === "PM");
    });
    _el$3.$$click = (e) => e.stopPropagation();
    createRenderEffect((_p$) => {
      var _v$ = style3("timePicker__separator", "nt-text-xl"), _v$2 = style3("timePicker__periodSelect", `${inputVariants({
        size: "sm"
      })} nt-h-7 nt-font-mono`);
      _v$ !== _p$.e && className(_el$2, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$3, _p$.t = _v$2);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    createRenderEffect(() => _el$3.value = isPM() ? "PM" : "AM");
    return _el$;
  })();
};
var enforceMinMax = (el) => {
  if (el.value !== "") {
    const value2 = parseInt(el.value, 10);
    const min2 = parseInt(el.min, 10);
    const max2 = parseInt(el.max, 10);
    if (value2 < min2 || value2 > max2) {
      el.value = el.value.slice(0, -1);
      const newValue = parseInt(el.value, 10);
      if (Number.isNaN(newValue) || newValue < min2) {
        el.value = el.min;
      } else if (newValue > max2) {
        el.value = el.max;
      }
    }
  }
};
delegateEvents(["click"]);
var _tmpl$58 = template(`<div><div><p></p></div><div>`);
var fiveMinutesFromNow = () => {
  const futureTime = new Date(Date.now() + 5 * 60 * 1e3);
  const hours = futureTime.getHours();
  const isPM = hours >= 12;
  let hour;
  if (hours === 0) {
    hour = 12;
  } else if (hours === 12) {
    hour = 12;
  } else {
    hour = hours % 12;
  }
  return {
    hour,
    minute: futureTime.getMinutes(),
    isPM
  };
};
var convertTo24Hour = (time2) => {
  if (time2.isPM) {
    return time2.hour === 12 ? 12 : time2.hour + 12;
  } else {
    return time2.hour === 12 ? 0 : time2.hour;
  }
};
var REFRESH_INTERVAL = 5e3;
var SnoozeDateTimePicker = (props) => {
  const style3 = useStyle();
  const {
    t
  } = useLocalization();
  const [selectedDate, setSelectedDate] = createSignal(null);
  const [timeValue, setTimeValue] = createSignal(fiveMinutesFromNow());
  const [currentTime, setCurrentTime] = createSignal(/* @__PURE__ */ new Date());
  createEffect(() => {
    const interval = setInterval(() => {
      setCurrentTime(/* @__PURE__ */ new Date());
    }, REFRESH_INTERVAL);
    onCleanup(() => clearInterval(interval));
  });
  const onDateTimeSelect = () => {
    var _a;
    if (selectedDate() && timeValue()) {
      const date = new Date(selectedDate());
      const hours = convertTo24Hour(timeValue());
      date.setHours(hours, timeValue().minute, 0, 0);
      (_a = props.onSelect) == null ? void 0 : _a.call(props, date);
    }
  };
  const maxDays = () => {
    if (!props.maxDurationHours) return 0;
    return Math.ceil(props.maxDurationHours / 24);
  };
  const getSelectedDateTime = () => {
    if (!selectedDate() || !timeValue()) return null;
    const date = new Date(selectedDate());
    const hours = convertTo24Hour(timeValue());
    date.setHours(hours, timeValue().minute, 0, 0);
    return date;
  };
  const isTimeInPast = createMemo(() => {
    const dateTime = getSelectedDateTime();
    if (!dateTime) return false;
    const minAllowedDateTime = new Date(currentTime().getTime() + 3 * 60 * 1e3);
    return dateTime < minAllowedDateTime;
  });
  const isTimeExceedingMaxDuration = createMemo(() => {
    const dateTime = getSelectedDateTime();
    if (!dateTime || !props.maxDurationHours) return false;
    const maxAllowedDateTime = new Date(currentTime().getTime() + props.maxDurationHours * 60 * 60 * 1e3);
    return dateTime > maxAllowedDateTime;
  });
  const applyButtonEnabled = createMemo(() => {
    if (!selectedDate() || !timeValue()) {
      return false;
    }
    if (isTimeInPast()) {
      return false;
    }
    if (props.maxDurationHours && isTimeExceedingMaxDuration()) {
      return false;
    }
    return true;
  });
  const getTooltipMessage = createMemo(() => {
    if (isTimeInPast()) {
      return t("snooze.datePicker.pastDateTooltip");
    }
    if (isTimeExceedingMaxDuration()) {
      return t("snooze.datePicker.exceedingLimitTooltip", {
        days: maxDays()
      });
    }
    return t("snooze.datePicker.noDateSelectedTooltip");
  });
  return (() => {
    var _el$ = _tmpl$58(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$2.nextSibling;
    _el$.$$click = (e) => e.stopPropagation();
    insert(_el$, createComponent(DatePicker, {
      onDateChange: (date) => setSelectedDate(date),
      get maxDays() {
        return maxDays();
      },
      get children() {
        return [createComponent(DatePickerHeader, {}), createComponent(DatePickerCalendar, {})];
      }
    }), _el$2);
    insert(_el$3, () => t("snooze.datePicker.timePickerLabel"));
    insert(_el$2, createComponent(TimePicker, {
      get value() {
        return timeValue();
      },
      onChange: setTimeValue
    }), null);
    insert(_el$4, createComponent(Button, {
      appearanceKey: "snoozeDatePickerCancel__button",
      variant: "secondary",
      "class": "nt-h-7 nt-w-[60px] nt-px-2",
      get onClick() {
        return props.onCancel;
      },
      get children() {
        return t("snooze.datePicker.cancel");
      }
    }), null);
    insert(_el$4, createComponent(Show, {
      get when() {
        return applyButtonEnabled();
      },
      get fallback() {
        return createComponent(Tooltip.Root, {
          get children() {
            return [createComponent(Tooltip.Trigger, {
              asChild: (props2) => createComponent(Button, mergeProps({
                appearanceKey: "snoozeDatePickerApply__button",
                "class": "nt-h-7 nt-w-[60px] nt-px-2 !nt-pointer-events-auto",
                onClick: onDateTimeSelect,
                disabled: true
              }, props2, {
                get children() {
                  return t("snooze.datePicker.apply");
                }
              }))
            }), createComponent(Tooltip.Content, {
              get children() {
                return getTooltipMessage();
              }
            })];
          }
        });
      },
      get children() {
        return createComponent(Button, {
          appearanceKey: "snoozeDatePickerApply__button",
          "class": "nt-h-7 nt-w-[60px] nt-px-2",
          onClick: onDateTimeSelect,
          get children() {
            return t("snooze.datePicker.apply");
          }
        });
      }
    }), null);
    createRenderEffect((_p$) => {
      var _v$ = style3("snoozeDatePicker", "nt-bg-background nt-rounded-md nt-shadow-lg nt-w-[260px]"), _v$2 = style3("snoozeDatePicker__timePickerContainer", "nt-flex nt-flex-row nt-justify-between nt-p-2 nt-items-center nt-border-t nt-border-neutral-200 nt-border-b"), _v$3 = style3("snoozeDatePicker__timePickerLabel", "nt-text-sm nt-font-medium nt-text-foreground-alpha-700 nt-p-2"), _v$4 = style3("snoozeDatePicker__actions", "nt-flex nt-flex-row nt-justify-end nt-gap-2 nt-p-2");
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
      _v$3 !== _p$.a && className(_el$3, _p$.a = _v$3);
      _v$4 !== _p$.o && className(_el$4, _p$.o = _v$4);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0
    });
    return _el$;
  })();
};
delegateEvents(["click"]);
var _tmpl$59 = template(`<div><span>`);
var _tmpl$215 = template(`<span>`);
var SNOOZE_PRESETS = [{
  key: "snooze.options.anHourFromNow",
  hours: 1,
  getDate: () => new Date(Date.now() + 1 * 60 * 60 * 1e3)
}, {
  key: "snooze.options.inOneDay",
  hours: 24,
  getDate: () => {
    const date = new Date(Date.now() + 1 * 24 * 60 * 60 * 1e3);
    date.setHours(9, 0, 0, 0);
    return date;
  }
}, {
  key: "snooze.options.inOneWeek",
  hours: 168,
  getDate: () => {
    const date = new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3);
    date.setHours(9, 0, 0, 0);
    return date;
  }
}];
var formatSnoozeOption = (preset, t, locale) => {
  const date = preset.getDate();
  const dayName = new Intl.DateTimeFormat(locale, {
    weekday: "short"
  }).format(date);
  const dateMonth = new Intl.DateTimeFormat(locale, {
    day: "numeric",
    month: "short"
  }).format(date);
  const timeString = new Intl.DateTimeFormat(locale, {
    hour: "numeric",
    minute: "numeric"
  }).format(date);
  return {
    label: t(preset.key),
    time: `${dayName}, ${dateMonth}, ${timeString}`
  };
};
var SnoozeDropdownItem = (props) => {
  const style3 = useStyle();
  const content = [(() => {
    var _el$ = _tmpl$59(), _el$2 = _el$.firstChild;
    insert(_el$, createComponent(Clock, {
      get ["class"]() {
        return style3("notificationSnooze__dropdownItem__icon", "nt-size-3 nt-text-foreground-alpha-400 nt-mr-2");
      }
    }), _el$2);
    insert(_el$2, () => props.label);
    createRenderEffect((_p$) => {
      var _v$ = style3("dropdownItem", "nt-flex nt-items-center nt-flex-1"), _v$2 = style3("dropdownItemLabel");
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$;
  })(), (() => {
    var _el$3 = _tmpl$215();
    insert(_el$3, () => props.time);
    createRenderEffect(() => className(_el$3, style3("dropdownItemRight__icon", "nt-text-foreground-alpha-300 nt-ml-2 nt-text-xs")));
    return _el$3;
  })()];
  if (props.asChild) {
    return props.asChild({
      class: style3("notificationSnooze__dropdownItem", dropdownItemVariants()),
      onClick: props.onClick,
      children: content
    });
  }
  return createComponent(Dropdown.Item, {
    appearanceKey: "notificationSnooze__dropdownItem",
    get onClick() {
      return props.onClick;
    },
    get ["class"]() {
      return style3("dropdownItem", "nt-justify-between");
    },
    children: content
  });
};
var ReadButton = (props) => {
  const style3 = useStyle();
  const {
    t
  } = useLocalization();
  return createComponent(Tooltip.Root, {
    get children() {
      return [createComponent(Tooltip.Trigger, {
        asChild: (childProps) => createComponent(Button, mergeProps({
          appearanceKey: "notificationRead__button",
          size: "iconSm",
          variant: "ghost"
        }, childProps, {
          onClick: (e) => __async(this, null, function* () {
            e.stopPropagation();
            yield props.notification.read();
          }),
          get children() {
            return createComponent(MarkAsRead, {
              get ["class"]() {
                return style3("notificationRead__icon", "nt-size-3");
              }
            });
          }
        }))
      }), createComponent(Tooltip.Content, {
        "data-localization": "notification.actions.read.tooltip",
        get children() {
          return t("notification.actions.read.tooltip");
        }
      })];
    }
  });
};
var UnreadButton = (props) => {
  const style3 = useStyle();
  const {
    t
  } = useLocalization();
  return createComponent(Tooltip.Root, {
    get children() {
      return [createComponent(Tooltip.Trigger, {
        asChild: (childProps) => createComponent(Button, mergeProps({
          appearanceKey: "notificationUnread__button",
          size: "iconSm",
          variant: "ghost"
        }, childProps, {
          onClick: (e) => __async(this, null, function* () {
            e.stopPropagation();
            yield props.notification.unread();
          }),
          get children() {
            return createComponent(MarkAsUnread, {
              get ["class"]() {
                return style3("notificationUnread__icon", "nt-size-3");
              }
            });
          }
        }))
      }), createComponent(Tooltip.Content, {
        "data-localization": "notification.actions.unread.tooltip",
        get children() {
          return t("notification.actions.unread.tooltip");
        }
      })];
    }
  });
};
var ArchiveButton = (props) => {
  const style3 = useStyle();
  const {
    t
  } = useLocalization();
  return createComponent(Tooltip.Root, {
    get children() {
      return [createComponent(Tooltip.Trigger, {
        asChild: (childProps) => createComponent(Button, mergeProps({
          appearanceKey: "notificationArchive__button",
          size: "iconSm",
          variant: "ghost"
        }, childProps, {
          onClick: (e) => __async(this, null, function* () {
            e.stopPropagation();
            yield props.notification.archive();
          }),
          get children() {
            return createComponent(MarkAsArchived, {
              get ["class"]() {
                return style3("notificationArchive__icon", "nt-size-3");
              }
            });
          }
        }))
      }), createComponent(Tooltip.Content, {
        "data-localization": "notification.actions.archive.tooltip",
        get children() {
          return t("notification.actions.archive.tooltip");
        }
      })];
    }
  });
};
var UnarchiveButton = (props) => {
  const style3 = useStyle();
  const {
    t
  } = useLocalization();
  return createComponent(Tooltip.Root, {
    get children() {
      return [createComponent(Tooltip.Trigger, {
        asChild: (childProps) => createComponent(Button, mergeProps({
          appearanceKey: "notificationUnarchive__button",
          size: "iconSm",
          variant: "ghost"
        }, childProps, {
          onClick: (e) => __async(this, null, function* () {
            e.stopPropagation();
            yield props.notification.unarchive();
          }),
          get children() {
            return createComponent(MarkAsUnarchived, {
              get ["class"]() {
                return style3("notificationArchive__icon", "nt-size-3");
              }
            });
          }
        }))
      }), createComponent(Tooltip.Content, {
        "data-localization": "notification.actions.unarchive.tooltip",
        get children() {
          return t("notification.actions.unarchive.tooltip");
        }
      })];
    }
  });
};
var UnsnoozeButton = (props) => {
  const style3 = useStyle();
  const {
    t
  } = useLocalization();
  return createComponent(Tooltip.Root, {
    get children() {
      return [createComponent(Tooltip.Trigger, {
        asChild: (childProps) => createComponent(Button, mergeProps({
          appearanceKey: "notificationUnsnooze__button",
          size: "iconSm",
          variant: "ghost"
        }, childProps, {
          onClick: (e) => __async(this, null, function* () {
            e.stopPropagation();
            yield props.notification.unsnooze();
          }),
          get children() {
            return createComponent(Unsnooze, {
              get ["class"]() {
                return style3("notificationUnsnooze__icon", "nt-size-3");
              }
            });
          }
        }))
      }), createComponent(Tooltip.Content, {
        "data-localization": "notification.actions.unsnooze.tooltip",
        get children() {
          return t("notification.actions.unsnooze.tooltip");
        }
      })];
    }
  });
};
var SnoozeButton = (props) => {
  const style3 = useStyle();
  const {
    t,
    locale
  } = useLocalization();
  const {
    maxSnoozeDurationHours
  } = useInboxContext();
  const [isSnoozeDateTimePickerOpen, setIsSnoozeDateTimePickerOpen] = createSignal(false);
  const availableSnoozePresets = createMemo(() => {
    if (!maxSnoozeDurationHours()) return SNOOZE_PRESETS;
    return SNOOZE_PRESETS.filter((preset) => preset.hours <= maxSnoozeDurationHours());
  });
  return createComponent(Tooltip.Root, {
    get children() {
      return [createComponent(Tooltip.Trigger, {
        asChild: (tooltipProps) => createComponent(Dropdown.Root, {
          get children() {
            return [createComponent(Dropdown.Trigger, mergeProps(tooltipProps, {
              asChild: (popoverProps) => createComponent(Button, mergeProps({
                appearanceKey: "notificationSnooze__button",
                size: "iconSm",
                variant: "ghost"
              }, popoverProps, {
                onClick: (e) => {
                  var _a;
                  e.stopPropagation();
                  (_a = popoverProps.onClick) == null ? void 0 : _a.call(popoverProps, e);
                },
                get children() {
                  return createComponent(Snooze, {
                    get ["class"]() {
                      return style3("notificationSnooze__icon", "nt-size-3");
                    }
                  });
                }
              }))
            })), createComponent(Dropdown.Content, {
              portal: true,
              appearanceKey: "notificationSnooze__dropdownContent",
              get children() {
                return [createComponent(For, {
                  get each() {
                    return availableSnoozePresets();
                  },
                  children: (preset) => {
                    const option = formatSnoozeOption(preset, t, locale());
                    return createComponent(SnoozeDropdownItem, {
                      get label() {
                        return option.label;
                      },
                      get time() {
                        return option.time;
                      },
                      onClick: (e) => __async(this, null, function* () {
                        e.stopPropagation();
                        yield props.notification.snooze(preset.getDate().toISOString());
                      })
                    });
                  }
                }), createComponent(Popover.Root, {
                  get open() {
                    return isSnoozeDateTimePickerOpen();
                  },
                  onOpenChange: setIsSnoozeDateTimePickerOpen,
                  placement: "bottom-start",
                  get children() {
                    return [createComponent(SnoozeDropdownItem, {
                      get label() {
                        return t("snooze.options.customTime");
                      },
                      time: "",
                      asChild: (childProps) => createComponent(Popover.Trigger, mergeProps(childProps, {
                        onClick: (e) => {
                          var _a;
                          e.stopPropagation();
                          (_a = childProps.onClick) == null ? void 0 : _a.call(childProps, e);
                        }
                      }))
                    }), createComponent(Popover.Content, {
                      portal: true,
                      get ["class"]() {
                        return style3("notificationSnoozeCustomTime_popoverContent", "nt-size-fit nt-w-[260px]");
                      },
                      get children() {
                        return createComponent(SnoozeDateTimePicker, {
                          get maxDurationHours() {
                            return maxSnoozeDurationHours();
                          },
                          onSelect: (date) => __async(this, null, function* () {
                            yield props.notification.snooze(date.toISOString());
                          }),
                          onCancel: () => {
                            setIsSnoozeDateTimePickerOpen(false);
                          }
                        });
                      }
                    })];
                  }
                })];
              }
            })];
          }
        })
      }), createComponent(Tooltip.Content, {
        "data-localization": "notification.actions.snooze.tooltip",
        get children() {
          return t("notification.actions.snooze.tooltip");
        }
      })];
    }
  });
};
var renderNotificationActions = (notification, status) => {
  const {
    isSnoozeEnabled
  } = useInboxContext();
  if (notification.isSnoozed) {
    return createComponent(UnsnoozeButton, {
      notification
    });
  }
  if (notification.isArchived) {
    return createComponent(UnarchiveButton, {
      notification
    });
  }
  return [memo(() => memo(
    () => status() !== "archived"
    /* ARCHIVED */
  )() && (notification.isRead ? createComponent(UnreadButton, {
    notification
  }) : createComponent(ReadButton, {
    notification
  }))), memo(() => memo(() => !!isSnoozeEnabled())() && createComponent(SnoozeButton, {
    notification
  })), createComponent(ArchiveButton, {
    notification
  })];
};
var _tmpl$60 = template(`<img>`);
var _tmpl$216 = template(`<div>`);
var _tmpl$311 = template(`<span>`);
var _tmpl$410 = template(`<a><div><div></div><div></div><div>`);
var DefaultNotification = (props) => {
  const style3 = useStyle();
  const {
    t,
    locale
  } = useLocalization();
  const {
    navigate,
    status
  } = useInboxContext();
  const [minutesPassed, setMinutesPassed] = createSignal(0);
  const createdAt = createMemo(() => {
    minutesPassed();
    return formatToRelativeTime({
      fromDate: new Date(props.notification.createdAt),
      locale: locale()
    });
  });
  const snoozedUntil = createMemo(() => {
    minutesPassed();
    if (!props.notification.snoozedUntil) {
      return null;
    }
    return formatSnoozedUntil({
      untilDate: new Date(props.notification.snoozedUntil),
      locale: locale()
    });
  });
  const deliveredAt = createMemo(() => {
    minutesPassed();
    if (!props.notification.deliveredAt || !Array.isArray(props.notification.deliveredAt)) {
      return null;
    }
    return props.notification.deliveredAt.map((date) => formatToRelativeTime({
      fromDate: new Date(date),
      locale: locale()
    }));
  });
  createEffect(() => {
    const interval = setInterval(() => {
      setMinutesPassed((prev2) => prev2 + 1);
    }, 1e3 * 60);
    return () => clearInterval(interval);
  });
  const handleNotificationClick = (e) => __async(void 0, null, function* () {
    var _a, _b, _c;
    e.stopPropagation();
    e.preventDefault();
    if (!props.notification.isRead) {
      yield props.notification.read();
    }
    (_a = props.onNotificationClick) == null ? void 0 : _a.call(props, props.notification);
    navigate((_b = props.notification.redirect) == null ? void 0 : _b.url, (_c = props.notification.redirect) == null ? void 0 : _c.target);
  });
  const handleActionButtonClick = (action, e) => __async(void 0, null, function* () {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    e.stopPropagation();
    if (action === "primary") {
      yield props.notification.completePrimary();
      (_a = props.onPrimaryActionClick) == null ? void 0 : _a.call(props, props.notification);
      navigate((_c = (_b = props.notification.primaryAction) == null ? void 0 : _b.redirect) == null ? void 0 : _c.url, (_e = (_d = props.notification.primaryAction) == null ? void 0 : _d.redirect) == null ? void 0 : _e.target);
    } else {
      yield props.notification.completeSecondary();
      (_f = props.onSecondaryActionClick) == null ? void 0 : _f.call(props, props.notification);
      navigate((_h = (_g = props.notification.secondaryAction) == null ? void 0 : _g.redirect) == null ? void 0 : _h.url, (_j = (_i = props.notification.secondaryAction) == null ? void 0 : _i.redirect) == null ? void 0 : _j.target);
    }
  });
  return (() => {
    var _el$ = _tmpl$410(), _el$3 = _el$.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling, _el$7 = _el$5.nextSibling;
    _el$.$$click = handleNotificationClick;
    insert(_el$, createComponent(Show, {
      get when() {
        return props.notification.avatar;
      },
      get fallback() {
        return (() => {
          var _el$9 = _tmpl$216();
          createRenderEffect(() => className(_el$9, style3("notificationImageLoadingFallback", "nt-size-8 nt-rounded-lg nt-shrink-0 nt-aspect-square")));
          return _el$9;
        })();
      },
      get children() {
        var _el$2 = _tmpl$60();
        createRenderEffect((_p$) => {
          var _v$ = style3("notificationImage", "nt-size-8 nt-rounded-lg nt-object-cover nt-aspect-square"), _v$2 = props.notification.avatar;
          _v$ !== _p$.e && className(_el$2, _p$.e = _v$);
          _v$2 !== _p$.t && setAttribute(_el$2, "src", _p$.t = _v$2);
          return _p$;
        }, {
          e: void 0,
          t: void 0
        });
        return _el$2;
      }
    }), _el$3);
    insert(_el$4, createComponent(Show, {
      get when() {
        return props.renderSubject;
      },
      get fallback() {
        return createComponent(Show, {
          get when() {
            return props.notification.subject;
          },
          children: (subject) => createComponent(Markdown_default, {
            appearanceKey: "notificationSubject",
            "class": "nt-text-start nt-font-medium",
            strongAppearanceKey: "notificationSubject__strong",
            get children() {
              return subject();
            }
          })
        });
      },
      children: (renderSubject) => createComponent(ExternalElementRenderer, {
        render: (el) => renderSubject()(el, props.notification)
      })
    }), null);
    insert(_el$4, createComponent(Show, {
      get when() {
        return props.renderBody;
      },
      get fallback() {
        return createComponent(Markdown_default, {
          appearanceKey: "notificationBody",
          strongAppearanceKey: "notificationBody__strong",
          "class": "nt-text-start nt-whitespace-pre-wrap nt-text-foreground-alpha-600",
          get children() {
            return props.notification.body;
          }
        });
      },
      children: (renderBody) => createComponent(ExternalElementRenderer, {
        render: (el) => renderBody()(el, props.notification)
      })
    }), null);
    insert(_el$5, () => renderNotificationActions(props.notification, status));
    insert(_el$3, createComponent(Show, {
      get when() {
        return props.notification.primaryAction || props.notification.secondaryAction;
      },
      get children() {
        var _el$6 = _tmpl$216();
        insert(_el$6, createComponent(Show, {
          get when() {
            return props.notification.primaryAction;
          },
          keyed: true,
          children: (primaryAction) => createComponent(Button, {
            appearanceKey: "notificationPrimaryAction__button",
            variant: "default",
            onClick: (e) => handleActionButtonClick("primary", e),
            get children() {
              return primaryAction.label;
            }
          })
        }), null);
        insert(_el$6, createComponent(Show, {
          get when() {
            return props.notification.secondaryAction;
          },
          keyed: true,
          children: (secondaryAction) => createComponent(Button, {
            appearanceKey: "notificationSecondaryAction__button",
            variant: "secondary",
            onClick: (e) => handleActionButtonClick("secondary", e),
            get children() {
              return secondaryAction.label;
            }
          })
        }), null);
        createRenderEffect(() => className(_el$6, style3("notificationCustomActions", "nt-flex nt-flex-wrap nt-gap-2")));
        return _el$6;
      }
    }), _el$7);
    insert(_el$7, createComponent(Show, {
      get when() {
        return snoozedUntil();
      },
      get fallback() {
        return createComponent(Show, {
          get when() {
            return deliveredAt();
          },
          get fallback() {
            return memo(createdAt);
          },
          children: (deliveredAt2) => createComponent(Show, {
            get when() {
              return deliveredAt2().length >= 2;
            },
            get children() {
              return [" ", createComponent(For, {
                get each() {
                  return deliveredAt2().slice(-2);
                },
                children: (date, index) => [createComponent(Show, {
                  get when() {
                    return index() === 0;
                  },
                  get children() {
                    return [date, " ·"];
                  }
                }), createComponent(Show, {
                  get when() {
                    return index() === 1;
                  },
                  get children() {
                    return createComponent(Badge, {
                      appearanceKey: "notificationDeliveredAt__badge",
                      get children() {
                        return [createComponent(Clock, {
                          get ["class"]() {
                            return style3("notificationDeliveredAt__icon", "nt-size-3");
                          }
                        }), date];
                      }
                    });
                  }
                })]
              })];
            }
          })
        });
      },
      children: (snoozedUntil2) => [createComponent(Clock, {
        get ["class"]() {
          return style3("notificationSnoozedUntil__icon", "nt-size-3");
        }
      }), memo(() => t("notification.snoozedUntil")), " · ", memo(snoozedUntil2)]
    }));
    insert(_el$, createComponent(Show, {
      get when() {
        return !props.notification.isRead;
      },
      get children() {
        var _el$8 = _tmpl$311();
        createRenderEffect(() => className(_el$8, style3("notificationDot", "nt-size-1.5 nt-bg-primary nt-rounded-full nt-shrink-0")));
        return _el$8;
      }
    }), null);
    createRenderEffect((_p$) => {
      var _a;
      var _v$3 = style3("notification", cn("nt-w-full nt-text-sm hover:nt-bg-primary-alpha-25 nt-group nt-relative nt-flex nt-items-start nt-p-4 nt-gap-2", "[&:not(:first-child)]:nt-border-t nt-border-neutral-alpha-100", {
        "nt-cursor-pointer": !props.notification.isRead || !!((_a = props.notification.redirect) == null ? void 0 : _a.url)
      })), _v$4 = style3("notificationContent", "nt-flex nt-flex-col nt-gap-2 nt-w-full"), _v$5 = style3("notificationTextContainer"), _v$6 = style3("notificationDefaultActions", `nt-absolute nt-transition nt-duration-100 nt-ease-out nt-gap-0.5 nt-flex nt-shrink-0 nt-opacity-0 group-hover:nt-opacity-100 group-focus-within:nt-opacity-100 nt-justify-center nt-items-center nt-bg-background/90 nt-right-3 nt-top-3 nt-border nt-border-neutral-alpha-100 nt-rounded-lg nt-backdrop-blur-lg nt-p-0.5`), _v$7 = style3("notificationDate", "nt-text-foreground-alpha-400 nt-flex nt-items-center nt-gap-1");
      _v$3 !== _p$.e && className(_el$, _p$.e = _v$3);
      _v$4 !== _p$.t && className(_el$3, _p$.t = _v$4);
      _v$5 !== _p$.a && className(_el$4, _p$.a = _v$5);
      _v$6 !== _p$.o && className(_el$5, _p$.o = _v$6);
      _v$7 !== _p$.i && className(_el$7, _p$.i = _v$7);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0
    });
    return _el$;
  })();
};
delegateEvents(["click"]);
var Notification2 = (props) => {
  return createComponent(Show, {
    get when() {
      return props.renderNotification;
    },
    get fallback() {
      return createComponent(DefaultNotification, {
        get notification() {
          return props.notification;
        },
        get renderSubject() {
          return props.renderSubject;
        },
        get renderBody() {
          return props.renderBody;
        },
        get onNotificationClick() {
          return props.onNotificationClick;
        },
        get onPrimaryActionClick() {
          return props.onPrimaryActionClick;
        },
        get onSecondaryActionClick() {
          return props.onSecondaryActionClick;
        }
      });
    },
    get children() {
      return createComponent(ExternalElementRenderer, {
        render: (el) => props.renderNotification(el, props.notification)
      });
    }
  });
};
var NewMessagesCta = (props) => {
  const shouldRender = createMemo(() => !!props.count);
  const {
    t
  } = useLocalization();
  return createComponent(Show, {
    get when() {
      return shouldRender();
    },
    get children() {
      return createComponent(Button, {
        appearanceKey: "notificationListNewNotificationsNotice__button",
        "class": "nt-absolute nt-w-fit nt-h-fit nt-top-0 nt-mx-auto nt-inset-2 nt-z-10 nt-rounded-full hover:nt-bg-primary-600 nt-animate-in nt-slide-in-from-top-2 nt-fade-in",
        get onClick() {
          return props.onClick;
        },
        "data-localization": "notifications.newNotifications",
        get children() {
          return t("notifications.newNotifications", {
            notificationCount: props.count
          });
        }
      });
    }
  });
};
var _tmpl$61 = template(`<div>`);
var NotificationListSkeleton = (props) => {
  const style3 = useStyle();
  const {
    t
  } = useLocalization();
  return (() => {
    var _el$ = _tmpl$61();
    insert(_el$, createComponent(Motion2.div, {
      get animate() {
        return {
          scale: props.loading ? 1 : 0.7
        };
      },
      transition: {
        duration: 0.6,
        easing: [0.39, 0.24, 0.3, 1],
        delay: 0.3
      },
      get ["class"]() {
        return style3("notificationList__skeleton", "nt-flex nt-relative nt-mx-auto nt-flex-col nt-w-full nt-mb-4");
      },
      get children() {
        return [memo(() => Array.from({
          length: 5
        }).map((_, i2) => createComponent(Motion2.div, {
          get animate() {
            return {
              marginBottom: props.loading ? 0 : "16px",
              borderWidth: props.loading ? 0 : "1px",
              borderRadius: props.loading ? 0 : "var(--nv-radius-lg)"
            };
          },
          transition: {
            duration: 0.5,
            delay: 0.3,
            easing: "ease-in-out"
          },
          get ["class"]() {
            return style3("notificationList__skeletonContent", "nt-flex nt-border-neutral-alpha-50 nt-items-center nt-gap-3 nt-p-3 nt-bg-neutral-alpha-25");
          },
          get children() {
            return [createComponent(SkeletonAvatar, {
              appearanceKey: "notificationList__skeletonAvatar",
              "class": "nt-w-8 nt-h-8 nt-rounded-full nt-bg-neutral-alpha-100"
            }), (() => {
              var _el$3 = _tmpl$61();
              insert(_el$3, createComponent(SkeletonText, {
                appearanceKey: "notificationList__skeletonText",
                "class": "nt-h-2 nt-w-1/3 nt-bg-neutral-alpha-50 nt-rounded"
              }), null);
              insert(_el$3, createComponent(SkeletonText, {
                appearanceKey: "notificationList__skeletonText",
                "class": "nt-h-2 nt-w-2/3 nt-bg-neutral-alpha-50 nt-rounded"
              }), null);
              createRenderEffect(() => className(_el$3, style3("notificationList__skeletonItem", "nt-flex nt-flex-col nt-gap-2 nt-flex-1")));
              return _el$3;
            })()];
          }
        }))), (() => {
          var _el$2 = _tmpl$61();
          createRenderEffect(() => className(_el$2, style3("notificationListEmptyNoticeOverlay", "nt-absolute nt-size-full nt-z-10 nt-inset-0 nt-bg-gradient-to-b nt-from-transparent nt-to-background")));
          return _el$2;
        })()];
      }
    }), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return !props.loading;
      },
      get children() {
        return createComponent(Motion2.p, {
          initial: {
            opacity: 0,
            y: -4,
            filter: "blur(4px)"
          },
          get animate() {
            return {
              opacity: props.loading ? 0 : 1,
              y: 0,
              filter: "blur(0px)"
            };
          },
          transition: {
            duration: 0.7,
            easing: [0.39, 0.24, 0.3, 1],
            delay: 0.6
          },
          get ["class"]() {
            return style3("notificationListEmptyNotice", "nt-text-center");
          },
          "data-localization": "notifications.emptyNotice",
          get children() {
            return t("notifications.emptyNotice");
          }
        });
      }
    }), null);
    createRenderEffect(() => className(_el$, style3("notificationListEmptyNoticeContainer", "nt-flex nt-flex-col nt-items-center nt-h-fit nt-w-full nt-text-sm nt-text-foreground-alpha-400 nt-text-center")));
    return _el$;
  })();
};
var _tmpl$62 = template(`<div>`);
var _tmpl$217 = template(`<div><div>`);
var NotificationList = (props) => {
  var _a, _b;
  const options = createMemo(() => __spreadProps(__spreadValues({}, props.filter), {
    limit: props.limit
  }));
  const style3 = useStyle();
  const {
    data: data2,
    setEl,
    end,
    refetch,
    initialLoading
  } = useNotificationsInfiniteScroll({
    options
  });
  const {
    count,
    reset: resetNewMessagesCount
  } = useNewMessagesCount({
    filter: {
      tags: (_b = (_a = props.filter) == null ? void 0 : _a.tags) != null ? _b : []
    }
  });
  const {
    setLimit
  } = useInboxContext();
  const ids = createMemo(() => data2().map((n) => n.id));
  let notificationListElement;
  createEffect(() => {
    setLimit(props.limit || DEFAULT_LIMIT);
  });
  const handleOnNewMessagesClick = (e) => __async(void 0, null, function* () {
    e.stopPropagation();
    resetNewMessagesCount();
    refetch({
      filter: props.filter
    });
    notificationListElement.scrollTo({
      top: 0
    });
  });
  return (() => {
    var _el$ = _tmpl$217(), _el$2 = _el$.firstChild;
    insert(_el$, createComponent(NewMessagesCta, {
      get count() {
        return count();
      },
      onClick: handleOnNewMessagesClick
    }), _el$2);
    use((el) => {
      notificationListElement = el;
    }, _el$2);
    insert(_el$2, createComponent(Show, {
      get when() {
        return data2().length > 0;
      },
      get fallback() {
        return createComponent(NotificationListSkeleton, {
          get loading() {
            return initialLoading();
          }
        });
      },
      get children() {
        return [createComponent(For, {
          get each() {
            return ids();
          },
          children: (_, index) => {
            const notification = () => data2()[index()];
            return createComponent(Notification2, {
              get notification() {
                return notification();
              },
              get renderNotification() {
                return props.renderNotification;
              },
              get renderSubject() {
                return props.renderSubject;
              },
              get renderBody() {
                return props.renderBody;
              },
              get onNotificationClick() {
                return props.onNotificationClick;
              },
              get onPrimaryActionClick() {
                return props.onPrimaryActionClick;
              },
              get onSecondaryActionClick() {
                return props.onSecondaryActionClick;
              }
            });
          }
        }), createComponent(Show, {
          get when() {
            return !end();
          },
          get children() {
            var _el$3 = _tmpl$62();
            use(setEl, _el$3);
            insert(_el$3, createComponent(NotificationListSkeleton, {
              loading: true
            }));
            return _el$3;
          }
        })];
      }
    }));
    createRenderEffect((_p$) => {
      var _v$ = style3("notificationListContainer", "nt-relative nt-border-t nt-border-t-neutral-alpha-200 nt-h-full nt-overflow-hidden"), _v$2 = style3("notificationList", "nt-relative nt-h-full nt-flex nt-flex-col nt-overflow-y-auto");
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$;
  })();
};
var _tmpl$63 = template(`<span>`);
var getDisplayCount = (count) => count >= 100 ? "99+" : count;
var InboxTabUnreadNotificationsCount = (props) => {
  const style3 = useStyle();
  const displayCount = createMemo(() => getDisplayCount(props.count));
  return (() => {
    var _el$ = _tmpl$63();
    insert(_el$, displayCount);
    createRenderEffect(() => className(_el$, style3("notificationsTabsTriggerCount", "nt-rounded-full nt-bg-counter nt-px-[6px] nt-text-counter-foreground nt-text-sm")));
    return _el$;
  })();
};
var InboxTab = (props) => {
  const {
    status
  } = useInboxContext();
  const style3 = useStyle();
  const unreadCount = useUnreadCount({
    filter: {
      tags: getTagsFromTab(props)
    }
  });
  return createComponent(Tabs.Trigger, {
    get value() {
      return props.label;
    },
    get ["class"]() {
      return style3("notificationsTabs__tabsTrigger", cn(tabsTriggerVariants(), "nt-flex nt-gap-2", props.class));
    },
    get children() {
      return [(() => {
        var _el$2 = _tmpl$63();
        insert(_el$2, () => props.label);
        createRenderEffect(() => className(_el$2, style3("notificationsTabsTriggerLabel", "nt-text-sm nt-font-medium")));
        return _el$2;
      })(), createComponent(Show, {
        get when() {
          return memo(
            () => status() !== "archived"
            /* ARCHIVED */
          )() && unreadCount();
        },
        get children() {
          return createComponent(InboxTabUnreadNotificationsCount, {
            get count() {
              return unreadCount();
            }
          });
        }
      })];
    }
  });
};
var InboxDropdownTab = (props) => {
  const {
    status
  } = useInboxContext();
  const style3 = useStyle();
  const unreadCount = useUnreadCount({
    filter: {
      tags: getTagsFromTab(props)
    }
  });
  return createComponent(Dropdown.Item, {
    get ["class"]() {
      return style3("moreTabs__dropdownItem", cn(dropdownItemVariants(), "nt-flex nt-justify-between nt-gap-2"));
    },
    get onClick() {
      return props.onClick;
    },
    get children() {
      return [(() => {
        var _el$3 = _tmpl$63();
        insert(_el$3, () => props.label);
        createRenderEffect(() => className(_el$3, style3("moreTabs__dropdownItemLabel", "nt-mr-auto")));
        return _el$3;
      })(), memo(() => props.rightIcon), createComponent(Show, {
        get when() {
          return memo(
            () => status() !== "archived"
            /* ARCHIVED */
          )() && unreadCount();
        },
        get children() {
          return createComponent(InboxTabUnreadNotificationsCount, {
            get count() {
              return unreadCount();
            }
          });
        }
      })];
    }
  });
};
var tabsDropdownTriggerVariants = () => `nt-relative after:nt-absolute after:nt-content-[''] after:nt-bottom-0 after:nt-left-0 after:nt-w-full after:nt-h-[2px] after:nt-border-b-2 nt-mb-[0.625rem]`;
var InboxTabs = (props) => {
  const style3 = useStyle();
  const {
    activeTab,
    status,
    setActiveTab,
    filter
  } = useInboxContext();
  const {
    dropdownTabs,
    setTabsList,
    visibleTabs
  } = useTabsDropdown({
    tabs: props.tabs
  });
  const dropdownTabsUnreadCounts = useUnreadCounts({
    filters: dropdownTabs().map((tab) => ({
      tags: getTagsFromTab(tab)
    }))
  });
  const options = createMemo(() => dropdownTabs().map((tab) => __spreadProps(__spreadValues({}, tab), {
    rightIcon: tab.label === activeTab() ? createComponent(Check, {
      get ["class"]() {
        return style3("moreTabs__dropdownItemRight__icon", "nt-size-3");
      }
    }) : void 0
  })));
  const dropdownTabsUnreadSum = createMemo(() => dropdownTabsUnreadCounts().reduce((accumulator, currentValue) => accumulator + currentValue, 0));
  const isTabsDropdownActive = createMemo(() => dropdownTabs().map((tab) => tab.label).includes(activeTab()));
  return createComponent(Tabs.Root, {
    appearanceKey: "notificationsTabs__tabsRoot",
    "class": "nt-flex nt-flex-col nt-flex-1 nt-min-h-0",
    get value() {
      return activeTab();
    },
    onChange: setActiveTab,
    get children() {
      return [createComponent(Show, {
        get when() {
          return visibleTabs().length > 0;
        },
        get fallback() {
          return createComponent(Tabs.List, {
            ref: setTabsList,
            appearanceKey: "notificationsTabs__tabsList",
            "class": "nt-bg-neutral-alpha-25 nt-px-4",
            get children() {
              return props.tabs.map((tab) => createComponent(InboxTab, mergeProps(tab, {
                "class": "nt-invisible"
              })));
            }
          });
        },
        get children() {
          return createComponent(Tabs.List, {
            appearanceKey: "notificationsTabs__tabsList",
            "class": "nt-bg-neutral-alpha-25 nt-px-4",
            get children() {
              return [createComponent(For, {
                get each() {
                  return visibleTabs();
                },
                children: (tab) => createComponent(InboxTab, tab)
              }), createComponent(Show, {
                get when() {
                  return dropdownTabs().length > 0;
                },
                get children() {
                  return createComponent(Dropdown.Root, {
                    get children() {
                      return [createComponent(Dropdown.Trigger, {
                        appearanceKey: "moreTabs__dropdownTrigger",
                        asChild: (triggerProps) => createComponent(Button, mergeProps({
                          variant: "unstyled",
                          size: "iconSm",
                          appearanceKey: "moreTabs__button"
                        }, triggerProps, {
                          get ["class"]() {
                            return cn(tabsDropdownTriggerVariants(), "nt-ml-auto", isTabsDropdownActive() ? "after:nt-border-b-primary" : "after:nt-border-b-transparent nt-text-foreground-alpha-700");
                          },
                          get children() {
                            return [createComponent(ArrowDown, {
                              get ["class"]() {
                                return style3("moreTabs__icon", "nt-size-5");
                              }
                            }), createComponent(Show, {
                              get when() {
                                return memo(
                                  () => status() !== "archived"
                                  /* ARCHIVED */
                                )() && dropdownTabsUnreadSum();
                              },
                              get children() {
                                return createComponent(InboxTabUnreadNotificationsCount, {
                                  get count() {
                                    return dropdownTabsUnreadSum();
                                  }
                                });
                              }
                            })];
                          }
                        }))
                      }), createComponent(Dropdown.Content, {
                        appearanceKey: "moreTabs__dropdownContent",
                        get children() {
                          return createComponent(For, {
                            get each() {
                              return options();
                            },
                            children: (option) => createComponent(InboxDropdownTab, mergeProps({
                              onClick: () => setActiveTab(option.label)
                            }, option))
                          });
                        }
                      })];
                    }
                  });
                }
              })];
            }
          });
        }
      }), memo(() => props.tabs.map((tab) => createComponent(Tabs.Content, {
        get value() {
          return tab.label;
        },
        get ["class"]() {
          return style3("notificationsTabs__tabsContent", cn(activeTab() === tab.label ? "nt-block" : "nt-hidden", "nt-overflow-auto nt-flex-1 nt-flex nt-flex-col nt-min-h-0"));
        },
        get children() {
          return createComponent(NotificationList, {
            get renderNotification() {
              return props.renderNotification;
            },
            get renderSubject() {
              return props.renderSubject;
            },
            get renderBody() {
              return props.renderBody;
            },
            get onNotificationClick() {
              return props.onNotificationClick;
            },
            get onPrimaryActionClick() {
              return props.onPrimaryActionClick;
            },
            get onSecondaryActionClick() {
              return props.onSecondaryActionClick;
            },
            get filter() {
              return __spreadProps(__spreadValues({}, filter()), {
                tags: getTagsFromTab(tab)
              });
            }
          });
        }
      })))];
    }
  });
};
var _tmpl$64 = template(`<div>`);
var InboxPage = function(InboxPage2) {
  InboxPage2["Notifications"] = "notifications";
  InboxPage2["Preferences"] = "preferences";
  return InboxPage2;
}({});
var InboxContent = (props) => {
  const [currentPage, setCurrentPage] = createSignal(props.initialPage || InboxPage.Notifications);
  const {
    tabs,
    filter
  } = useInboxContext();
  const style3 = useStyle();
  const navigateToPage = createMemo(() => (page) => {
    if (props.hideNav) {
      return void 0;
    }
    return () => {
      setCurrentPage(page);
    };
  });
  return (() => {
    var _el$ = _tmpl$64();
    insert(_el$, createComponent(Switch, {
      get children() {
        return [createComponent(Match, {
          get when() {
            return currentPage() === InboxPage.Notifications;
          },
          get children() {
            return [createComponent(Header, {
              get navigateToPreferences() {
                return navigateToPage()(InboxPage.Preferences);
              }
            }), createComponent(Show, {
              keyed: true,
              get when() {
                return memo(() => !!tabs())() && tabs().length > 0;
              },
              get fallback() {
                return createComponent(NotificationList, {
                  get renderNotification() {
                    return props.renderNotification;
                  },
                  get renderSubject() {
                    return props.renderSubject;
                  },
                  get renderBody() {
                    return props.renderBody;
                  },
                  get onNotificationClick() {
                    return props.onNotificationClick;
                  },
                  get onPrimaryActionClick() {
                    return props.onPrimaryActionClick;
                  },
                  get onSecondaryActionClick() {
                    return props.onSecondaryActionClick;
                  },
                  get filter() {
                    return filter();
                  }
                });
              },
              get children() {
                return createComponent(InboxTabs, {
                  get renderNotification() {
                    return props.renderNotification;
                  },
                  get renderSubject() {
                    return props.renderSubject;
                  },
                  get renderBody() {
                    return props.renderBody;
                  },
                  get onNotificationClick() {
                    return props.onNotificationClick;
                  },
                  get onPrimaryActionClick() {
                    return props.onPrimaryActionClick;
                  },
                  get onSecondaryActionClick() {
                    return props.onSecondaryActionClick;
                  },
                  get tabs() {
                    return tabs();
                  }
                });
              }
            })];
          }
        }), createComponent(Match, {
          get when() {
            return currentPage() === InboxPage.Preferences;
          },
          get children() {
            return [createComponent(PreferencesHeader, {
              get navigateToNotifications() {
                return navigateToPage()(InboxPage.Notifications);
              }
            }), createComponent(Preferences2, {})];
          }
        })];
      }
    }), null);
    insert(_el$, createComponent(Footer, {}), null);
    createRenderEffect(() => className(_el$, style3("inboxContent", "nt-h-full nt-flex nt-flex-col")));
    return _el$;
  })();
};
var Inbox = (props) => {
  const style3 = useStyle();
  const {
    isOpened,
    setIsOpened
  } = useInboxContext();
  const isOpen = () => {
    var _a;
    return (_a = props == null ? void 0 : props.open) != null ? _a : isOpened();
  };
  return createComponent(Popover.Root, {
    get open() {
      return isOpen();
    },
    onOpenChange: setIsOpened,
    get placement() {
      return props.placement;
    },
    get offset() {
      return props.placementOffset;
    },
    get children() {
      return [createComponent(Popover.Trigger, {
        asChild: (triggerProps) => createComponent(Button, mergeProps({
          get ["class"]() {
            return style3("inbox__popoverTrigger");
          },
          variant: "ghost",
          size: "icon"
        }, triggerProps, {
          get children() {
            return createComponent(Bell2, {
              get renderBell() {
                return props.renderBell;
              }
            });
          }
        }))
      }), createComponent(Popover.Content, {
        appearanceKey: "inbox__popoverContent",
        portal: true,
        get children() {
          return createComponent(Show, {
            get when() {
              return props.renderNotification;
            },
            get fallback() {
              return createComponent(InboxContent, {
                get renderSubject() {
                  return props.renderSubject;
                },
                get renderBody() {
                  return props.renderBody;
                },
                get onNotificationClick() {
                  return props.onNotificationClick;
                },
                get onPrimaryActionClick() {
                  return props.onPrimaryActionClick;
                },
                get onSecondaryActionClick() {
                  return props.onSecondaryActionClick;
                }
              });
            },
            get children() {
              return createComponent(InboxContent, {
                get renderNotification() {
                  return props.renderNotification;
                },
                get onNotificationClick() {
                  return props.onNotificationClick;
                },
                get onPrimaryActionClick() {
                  return props.onPrimaryActionClick;
                },
                get onSecondaryActionClick() {
                  return props.onSecondaryActionClick;
                }
              });
            }
          });
        }
      })];
    }
  });
};
var novuComponents = {
  Inbox,
  InboxContent,
  Bell: Bell2,
  Notifications: (props) => {
    if (props.renderNotification) {
      const _a = props, propsWithoutBodyAndSubject = __objRest(_a, [
        "renderBody",
        "renderSubject"
      ]);
      return createComponent(InboxContent, mergeProps(propsWithoutBodyAndSubject, {
        hideNav: true,
        get initialPage() {
          return InboxPage.Notifications;
        }
      }));
    }
    const _b = props, propsWithoutRenderNotification = __objRest(_b, [
      "renderNotification"
    ]);
    return createComponent(InboxContent, mergeProps(propsWithoutRenderNotification, {
      hideNav: true,
      get initialPage() {
        return InboxPage.Notifications;
      }
    }));
  },
  Preferences: (props) => {
    if (props.renderNotification) {
      const _a = props, propsWithoutBodyAndSubject = __objRest(_a, [
        "renderBody",
        "renderSubject"
      ]);
      return createComponent(InboxContent, mergeProps(propsWithoutBodyAndSubject, {
        hideNav: true,
        get initialPage() {
          return InboxPage.Preferences;
        }
      }));
    }
    const _b = props, propsWithoutRenderNotification = __objRest(_b, [
      "renderNotification"
    ]);
    return createComponent(InboxContent, mergeProps(propsWithoutRenderNotification, {
      hideNav: true,
      get initialPage() {
        return InboxPage.Preferences;
      }
    }));
  }
};
var Renderer = (props) => {
  const nodes = () => [...props.nodes.keys()];
  onMount(() => {
    const id = "novu-default-css";
    const el = document.getElementById(id);
    if (el) {
      return;
    }
    const styleEl = document.createElement("style");
    styleEl.id = id;
    document.head.insertBefore(styleEl, document.head.firstChild);
    styleEl.innerHTML = ui_default;
    onCleanup(() => {
      const element = document.getElementById(id);
      element == null ? void 0 : element.remove();
    });
  });
  return createComponent(NovuProvider, {
    get options() {
      return props.options;
    },
    get novu() {
      return props.novu;
    },
    get children() {
      return createComponent(LocalizationProvider, {
        get localization() {
          return props.localization;
        },
        get children() {
          return createComponent(AppearanceProvider, {
            get id() {
              return props.novuUI.id;
            },
            get appearance() {
              return props.appearance;
            },
            get children() {
              return createComponent(FocusManagerProvider, {
                get children() {
                  return createComponent(InboxProvider, {
                    get tabs() {
                      return props.tabs;
                    },
                    get preferencesFilter() {
                      return props.preferencesFilter;
                    },
                    get routerPush() {
                      return props.routerPush;
                    },
                    get children() {
                      return createComponent(CountProvider, {
                        get children() {
                          return createComponent(For, {
                            get each() {
                              return nodes();
                            },
                            children: (node) => {
                              const novuComponent = () => props.nodes.get(node);
                              let portalDivElement;
                              const Component = novuComponents[novuComponent().name];
                              onMount(() => {
                                if (!["Notifications", "Preferences", "InboxContent"].includes(novuComponent().name)) return;
                                if (node instanceof HTMLElement) {
                                  node.style.height = "100%";
                                }
                                if (portalDivElement) {
                                  portalDivElement.style.height = "100%";
                                }
                              });
                              return createComponent(Portal, {
                                mount: node,
                                ref: (el) => {
                                  portalDivElement = el;
                                },
                                get children() {
                                  return createComponent(Root, {
                                    get children() {
                                      return createComponent(Component, mergeProps(() => novuComponent().props));
                                    }
                                  });
                                }
                              });
                            }
                          });
                        }
                      });
                    }
                  });
                }
              });
            }
          });
        }
      });
    }
  });
};
var _dispose;
var _rootElement;
var _mountedElements;
var _setMountedElements;
var _appearance;
var _setAppearance;
var _localization;
var _setLocalization;
var _options2;
var _setOptions;
var _tabs;
var _setTabs;
var _routerPush;
var _setRouterPush;
var _preferencesFilter;
var _setPreferencesFilter;
var _predefinedNovu;
var _NovuUI_instances;
var mountComponentRenderer_fn;
var updateComponentProps_fn;
var NovuUI = class {
  constructor(props) {
    __privateAdd(this, _NovuUI_instances);
    __privateAdd(this, _dispose, null);
    __privateAdd(this, _rootElement);
    __privateAdd(this, _mountedElements);
    __privateAdd(this, _setMountedElements);
    __privateAdd(this, _appearance);
    __privateAdd(this, _setAppearance);
    __privateAdd(this, _localization);
    __privateAdd(this, _setLocalization);
    __privateAdd(this, _options2);
    __privateAdd(this, _setOptions);
    __privateAdd(this, _tabs);
    __privateAdd(this, _setTabs);
    __privateAdd(this, _routerPush);
    __privateAdd(this, _setRouterPush);
    __privateAdd(this, _preferencesFilter);
    __privateAdd(this, _setPreferencesFilter);
    __privateAdd(this, _predefinedNovu);
    var _a;
    this.id = generateRandomString(16);
    const [appearance, setAppearance] = createSignal(props.appearance);
    const [localization, setLocalization] = createSignal(props.localization);
    const [options, setOptions] = createSignal(props.options);
    const [mountedElements, setMountedElements] = createSignal(/* @__PURE__ */ new Map());
    const [tabs, setTabs] = createSignal((_a = props.tabs) != null ? _a : []);
    const [preferencesFilter, setPreferencesFilter] = createSignal(props.preferencesFilter);
    const [routerPush, setRouterPush] = createSignal(props.routerPush);
    __privateSet(this, _mountedElements, mountedElements);
    __privateSet(this, _setMountedElements, setMountedElements);
    __privateSet(this, _appearance, appearance);
    __privateSet(this, _setAppearance, setAppearance);
    __privateSet(this, _localization, localization);
    __privateSet(this, _setLocalization, setLocalization);
    __privateSet(this, _options2, options);
    __privateSet(this, _setOptions, setOptions);
    __privateSet(this, _tabs, tabs);
    __privateSet(this, _setTabs, setTabs);
    __privateSet(this, _routerPush, routerPush);
    __privateSet(this, _setRouterPush, setRouterPush);
    __privateSet(this, _predefinedNovu, props.novu);
    __privateSet(this, _preferencesFilter, preferencesFilter);
    __privateSet(this, _setPreferencesFilter, setPreferencesFilter);
    __privateMethod(this, _NovuUI_instances, mountComponentRenderer_fn).call(this);
  }
  mountComponent({
    name,
    element,
    props: componentProps
  }) {
    if (__privateGet(this, _mountedElements).call(this).has(element)) {
      return __privateMethod(this, _NovuUI_instances, updateComponentProps_fn).call(this, element, componentProps);
    }
    __privateGet(this, _setMountedElements).call(this, (oldNodes) => {
      const newNodes = new Map(oldNodes);
      newNodes.set(element, {
        name,
        props: componentProps
      });
      return newNodes;
    });
  }
  unmountComponent(element) {
    __privateGet(this, _setMountedElements).call(this, (oldMountedElements) => {
      const newMountedElements = new Map(oldMountedElements);
      newMountedElements.delete(element);
      return newMountedElements;
    });
  }
  updateAppearance(appearance) {
    __privateGet(this, _setAppearance).call(this, appearance);
  }
  updateLocalization(localization) {
    __privateGet(this, _setLocalization).call(this, localization);
  }
  updateOptions(options) {
    __privateGet(this, _setOptions).call(this, options);
  }
  updateTabs(tabs) {
    __privateGet(this, _setTabs).call(this, tabs != null ? tabs : []);
  }
  updatePreferencesFilter(preferencesFilter) {
    __privateGet(this, _setPreferencesFilter).call(this, preferencesFilter);
  }
  updateRouterPush(routerPush) {
    __privateGet(this, _setRouterPush).call(this, () => routerPush);
  }
  unmount() {
    var _a, _b;
    (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this);
    __privateSet(this, _dispose, null);
    (_b = __privateGet(this, _rootElement)) == null ? void 0 : _b.remove();
  }
};
_dispose = /* @__PURE__ */ new WeakMap();
_rootElement = /* @__PURE__ */ new WeakMap();
_mountedElements = /* @__PURE__ */ new WeakMap();
_setMountedElements = /* @__PURE__ */ new WeakMap();
_appearance = /* @__PURE__ */ new WeakMap();
_setAppearance = /* @__PURE__ */ new WeakMap();
_localization = /* @__PURE__ */ new WeakMap();
_setLocalization = /* @__PURE__ */ new WeakMap();
_options2 = /* @__PURE__ */ new WeakMap();
_setOptions = /* @__PURE__ */ new WeakMap();
_tabs = /* @__PURE__ */ new WeakMap();
_setTabs = /* @__PURE__ */ new WeakMap();
_routerPush = /* @__PURE__ */ new WeakMap();
_setRouterPush = /* @__PURE__ */ new WeakMap();
_preferencesFilter = /* @__PURE__ */ new WeakMap();
_setPreferencesFilter = /* @__PURE__ */ new WeakMap();
_predefinedNovu = /* @__PURE__ */ new WeakMap();
_NovuUI_instances = /* @__PURE__ */ new WeakSet();
mountComponentRenderer_fn = function() {
  if (__privateGet(this, _dispose) !== null) {
    return;
  }
  __privateSet(this, _rootElement, document.createElement("div"));
  __privateGet(this, _rootElement).setAttribute("id", `novu-ui-${this.id}`);
  document.body.appendChild(__privateGet(this, _rootElement));
  const dispose2 = render(() => {
    const _self$ = this;
    return createComponent(Renderer, {
      novuUI: _self$,
      get nodes() {
        var _a;
        return __privateGet(_a = _self$, _mountedElements).call(_a);
      },
      get options() {
        var _a;
        return __privateGet(_a = _self$, _options2).call(_a);
      },
      get appearance() {
        var _a;
        return __privateGet(_a = _self$, _appearance).call(_a);
      },
      get localization() {
        var _a;
        return __privateGet(_a = _self$, _localization).call(_a);
      },
      get tabs() {
        var _a;
        return __privateGet(_a = _self$, _tabs).call(_a);
      },
      get preferencesFilter() {
        var _a;
        return __privateGet(_a = _self$, _preferencesFilter).call(_a);
      },
      get routerPush() {
        var _a;
        return __privateGet(_a = _self$, _routerPush).call(_a);
      },
      get novu() {
        return __privateGet(_self$, _predefinedNovu);
      }
    });
  }, __privateGet(this, _rootElement));
  __privateSet(this, _dispose, dispose2);
};
updateComponentProps_fn = function(element, props) {
  __privateGet(this, _setMountedElements).call(this, (oldMountedElements) => {
    const newMountedElements = new Map(oldMountedElements);
    const mountedElement = newMountedElements.get(element);
    if (mountedElement) {
      newMountedElements.set(element, __spreadProps(__spreadValues({}, mountedElement), {
        props
      }));
    }
    return newMountedElements;
  });
};
export {
  NotificationStatus2 as NotificationStatus,
  NovuUI
};
//# sourceMappingURL=@novu_js_ui.js.map
